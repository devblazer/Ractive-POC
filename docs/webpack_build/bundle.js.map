{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 70afc96cca3fc0a1967e","webpack:///./~/ractive/ractive.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./src/ractivePOC/components/main/main.scss?5067","webpack:///./src/ractivePOC/components/main/main.js","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.js","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.js","webpack:///./src/ractivePOC/entry.js","webpack:///./src/ractivePOC/components/main/main.scss","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.scss","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.scss","webpack:///./~/jquery/dist/jquery.js","webpack:///./src/ractivePOC/components/main/main.hbs","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.hbs","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.hbs","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.scss?17a5","webpack:///./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.scss?4680"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","global","factory","this","createDocumentFragment","doc","getElement","input","output","win","nodeType","getElementById","querySelector","detachNode","node","parentNode","removeChild","safeToStringValue","value","toString","safeAttributeString","string","replace","decamelize","decamel","s","toLowerCase","extendObj","target","sources","len","arguments","length","prop","forEach","source","hasOwn","fillGaps","key","isArray","thing","isEqual","a","b","isNumeric","isNaN","parseFloat","isFinite","isObject","noop","format","message","args","shift","fatal","Error","logIfDebug","Ractive","DEBUG","log","apply","warn","printWarning","warnOnce","alreadyWarned","warnIfDebug","warnOnceIfDebug","findInViewHierarchy","registryName","ractive","name","instance","findInstance","isolated","parent","interpolate","from","to","type","interpol","missingPlugin","interpolators","number","array","object","snap","addToArray","index","indexOf","push","arrayContains","i","arrayContentsMatch","ensureArray","x","undefined","lastItem","removeFromArray","member","splice","toArray","arrayLike","wait","callback","setTimeout","makeDispatcher","handlers","result","handler","resolve","promise","fulfil","reject","then","TypeError","_Promise","e","called","resolvePromise","rejectPromise","y","r","detach","element","_detachNodes","tm","detachNodes","check","ready","outros","outroChildren","outrosComplete","decrementOutros","intros","totalChildren","notifiedTotal","decrementTotal","detachImmediate","manager","trans","queue","detachQueue","collectAllOutros","j","start","contains","list","children","concat","dispatch","observer","flushChanges","which","batch","immediateObservers","fragment","fragments","ractives","Object","keys","viewmodel","changes","changeHook","fire","update","ractive$1","transitionManager","deferredObservers","tasks","escapeKey","escapeKeyPattern","normalise","ref","refPattern","splitKeypathI","keypath","match","splitPattern","exec","substr","unescapeKey","unescapeKeyPattern","bind","fn","context","test","bound","set","pairs","runloop","model","end","gather","base","star","findMatches","joinAll","build","sets","loop","k","hasOwnProperty","map","add","d","pair","get","errorMessage","Ractive$add","getOptions","options","easing","linear","duration","complete","step","protoAnimate","noAnimation","interpolator","animate","Ractive$animate","join","Ractive$detach","isDetached","el","__ractive_instances__","detachHook","Ractive$find","selector","find","sortByDocumentPosition","otherNode","compareDocumentPosition","bitmask","sortByItemPosition","mutualAncestor","ancestryA","getAncestry","component","_ractive","proxy","ancestryB","oldestA","oldestB","pop","fragmentA","parentFragment","fragmentB","indexA","items","indexB","iterations","indexA$1","indexB$1","getParent","item","owner","ancestry","ancestor","Ractive$findAll","liveQueries","_liveQueries","query","live","slice","Query","findAll","init","Ractive$findAllComponents","_liveComponentQueries","findAllComponents","Ractive$findComponent","findComponent","Ractive$findContainer","container","findContainer","Ractive$findParent","findParent","enqueue","event","_eventQueue","dequeue","getPotentialWildcardMatches","starMap","mapper","wildcardKeypath","starMaps","getStarMap","num","max","binary","l","ones","parseInt","digit","fireEvent","eventName","_noArg","eventNames","getWildcardNames","fireEventAs","wildcardCache","initialFire","subscribers","bubble","_subs","notifySubscribers","fullName","originalEvent","stopEvent","off","original","preventDefault","stopPropagation","Ractive$fire","badReference","resolveAmbiguousReference","hasContextChain","crossedComponentBoundary","aliases","localViewmodel","findContext","root","isIteration","keyRef","getKeyModel","indexRef","isRoot","has","createLink","joinKey","componentParent","startCapturing","stack","captureGroup","stopCapturing","dependencies","capture","bind$1","cancel","handleChange","mark","marked","notifiedUpstream","render","teardown","unbind","unrender","unrenderAndDestroy","toString$1","toEscapedString","updateFromBindings","findBoundValue","checked","fireShuffleTasks","stage","shuffleTasks","register","registerQueue","rebindMatch","template","next","previous","isKey","isKeypath","parts","split","shuffling","tick","ticker","now","getTime","tickers","rAF","running","prefixKeypath","obj","prefix","prefixed","getPrefixer","rootKeypath","rootDot","prefixers","relativeKeypath","recreateArray","childByKey","resolveReference","keypathExpr","getKeypathModel","match$1","model$1","repeater","findRepeatingFragment","getRactiveModel","GlobalModel$1","part","Ractive$get","opts","gatherRefs","getNewIndices","methodName","spliceArguments","removeStart","removeEnd","balance","newIndices","getSpliceEquivalent","Math","min","startIndex","touchedFrom","makeArrayMethod","path","mdl","result$1","arrayProto","promise$1","getKeypath","shuffle","getComparator","option","JSON","stringify","comparators","merge$1","comparator","compare","merge","thisRactive$merge","update$2","wrapper","adapt","registerChange","clearUnresolveds","notifyUpstream","updateHook","Ractive$update","build$1","findModel","_element","resolve$1","frag","add$1","val","link","dest","there","here","modelPop","values","modelPush","reverse","modelReverse","set$1","modelShift","drop","unshift","modelSplice","sort","modelSort","subtract","toggle","unlink","_link","modelUnshift","update$1","updateModel","cascade","isBound","getBindingModel","getBindingPath","getBinding","ctx","binding","setBinding","rootpath","addHelpers","defineProperties","staticInfo","document","storage","getNodeInfo","Ractive$insert","anchor","rendered","insertBefore","fireInsertHook","insertHook","child","link$1","sourcePath","observe","this$1","observers","keypaths","filter","createObserver","_observers","wildcardIndex","Observer","baseModel","PatternObserver","observeList","ListObserver","negativeOne","observeOnce","onceOptions","trim","str","notEmptyString","Ractive$off","Ractive$on","n","listeners","on","listener","Ractive$once","addCSS","styleDefinition","styleDefinitions","isDirty","applyCSS","useCssText","styleElement","styleSheet","cssText","getCSS","innerHTML","cssIds","filteredStyleDefinitions","style","reduce","styles","PREFIX","render$1","occupants","transitionsEnabled","noIntro","scheduleTask","renderHook","cssId","docFrag","completeHook","Ractive$render","torndown","Promise","append","others","enhance","childNodes","combine","trim$1","extractString","unit","transformSelector","selectorUnits","selectorUnitPattern","modifiers","transformed","appended","prepended","transformCss","css","dataAttr","dataRvcGuidPattern","commentsPattern","selectorsPattern","$1","excludePattern","selectors","s4","floor","random","substring","uuid","validate","data","constructor","combine$1","parentValue","childValue","parentIsFn","childIsFn","callDataFunction","fromProperties","primary","secondary","fromExpression","body","Array","Function","fromComputationString","bindTo","hasThis","functionBody","pattern","getFunction","functions","createFunction","addFunctions","exp","readDelimiterChange","parser","opening","closing","matchString","pos","allowWhitespace","matchPattern","delimiterChangePattern","whitespacePattern","readNumberLiteral","regexpPattern","t","REGEXP_LITERAL","v","escapeRegExp","pattern$1","getLowestIndex","haystack","needles","search","regExpCache","RegExp","decodeCharacterReferences","html","entityPattern","entity","code","htmlEntities","codeToChar","validateCode","escapeHtml","amp","lessThan","greaterThan","controlCharacters","invalid","codePointSupport","readNumberLiteral$1","numberPattern","NUMBER_LITERAL","readBooleanLiteral","remaining","BOOLEAN_LITERAL","makeQuotedStringMatcher","okQuote","literal","done","stringMiddlePattern","escapeSequencePattern","lineContinuationPattern","charCodeAt","parse","readStringLiteral","getDoubleQuotedString","STRING_LITERAL","getSingleQuotedString","readKey","token","identifier","namePattern","readKeyValuePair","refKey","nextChar","readExpression","KEY_VALUE_PAIR","error","REFERENCE","readKeyValuePairs","keyValuePairs","readObjectLiteral","OBJECT_LITERAL","readExpressionList","expr","expressions","expectedExpression","readArrayLiteral","expressionList","ARRAY_LITERAL","readLiteral","readReference","startPos","reference","fullLength","lastDotIndex","spread","specials","specialCall","spreadArgs","spreadPattern","prefixPattern","relaxedNames","relaxedName","legalReference","keywords","globals","GLOBAL","lastIndexOf","refLength","readBracketedExpression","expectedParen","BRACKETED","readPrimary","readRefinement","strictRefinement","REFINEMENT","readMemberOrInvocation","expression","refinement","MEMBER","INVOCATION","o","getConditional","ifTrue","ifFalse","readLogicalOr$1","CONDITIONAL","flattenExpression","getVars","vars","count","String","PREFIX_OPERATOR","INFIX_OPERATOR","refs","stringified","extractRefs","getKeyValuePair","valueToken","read","parseJSON","JsonParser","processDirective","tokens","parentParser","colonIndex","directiveName","directiveArgs","parsed","DECORATOR","TRANSITION","ExpressionParser","EVENT","methodCallPattern","getContextMessage","parser$1","readAttribute","attr","nearest","idx","attributeNamePattern","tags","open","readAttributeValue","f","valueStart","startDepth","sectionDepth","readQuotedAttributeValue","readUnquotedAttributeValue","readUnquotedAttributeValueToken","text","unquotedAttributeValueTextPattern","inAttribute","readMustache","quoteMark","readQuotedStringToken","readAttributeOrDirective","attribute","directive","directives","decoratorPattern","transitionPattern","proxyEventPattern","reservedEventNames","sanitizeEventAttributes","onPattern","exclude","ATTRIBUTE","mustache","inside","readMustacheOfType","inTag","tag","reader","close","sortMustacheTags","delimiterChangeToken","rewind","readers","isStatic","includeLinePositions","getLinePos","refineExpression","referenceExpression","getReferenceExpression","rx","members","readTriple","triple","TRIPLE","readUnescaped","readAliases","alias","readAlias","asRE","legalAlias","readPartial","partial","PARTIAL","ALIAS","z","SECTION","SECTION_WITH","readComment","COMMENT","readExpressionOrReference","expectedFollowers","readInterpolator","err","charAt","INTERPOLATOR","readYielder","yieldPattern","yielder","YIELDER","readClosing","CLOSING","readElse","elsePattern","ELSE","readElseIf","elsePattern$1","ELSEIF","readSection","section","hasElse","block","unlessBlock","conditions","closed","expectedClose","aliasOnly","SECTION_UNLESS","standardDelimiters","handlebarsBlockPattern","handlebarsBlockCodes","indexRefPattern","extra","keyIndexRefPattern","SECTION_IF","READERS","readHtmlComment","content","endIndex","comment","textOnlyMode","OPEN_COMMENT","CLOSE_COMMENT","stripStandalones","current","backOne","backTwo","lastSectionItem","isString","isComment","trailingLinebreak","leadingLinebreak","isSection","DELIMCHANGE","INVERTED","trimWhitespace","leadingPattern","trailingPattern","cleanup","stripComments","preserveWhitespace","removeLeadingWhitespace","removeTrailingWhitespace","previousItem","nextItem","preserveWhitespaceInsideFragment","removeLeadingWhitespaceInsideFragment","removeTrailingWhitespaceInsideFragment","leadingWhitespace$1","trailingWhitespace","isPreserveWhitespaceElement","ELEMENT","preserveWhitespaceElements","leadingNewLine","trailingNewLine","contiguousWhitespace","readClosingTag","closingTagPattern","CLOSING_TAG","readElement","selfClosing","partials","hasPartials","closingTag","DOCTYPE","tagNamePattern","validTagNameFollower","lowerCaseName","voidElementNames","elementStack","create","canContain","closingTagName","PARTIAL_READERS","sanitizeElements","disallowed","disallowedContents","readText","barrier","readPartialDefinitionComment","startPattern","namePattern$1","finishPattern","endPattern","INLINE_PARTIAL","readPartialDefinitionSection","delimiters","partialDefinitionSectionPattern","readTemplate","TEMPLATE_VERSION","insertExpressions","isExpression","addTo","hasChildren","StandardParser","throwNoParse","method","instructions","TEMPLATE_INSTRUCTIONS","createFunctionFromString","COMPUTATION_INSTRUCTIONS","resetValue","initial","_config","getDynamicTemplate","fromId","isParsed","getParseOptions","parseTemplate","parseAsString","validate$1","parseFor","extendPartials","existingPartials","newPartials","overwrite","wrap","superMethod","getSuperMethod","_parent","hasSuper","oldSuper","_super","_method","getMessage","deprecated","correct","isError","deprecateOption","deprecatedOption","deprecate","adaptors","configure","Parent","isStandardKey","registries","registry","adaptConfigurator","templateConfigurator","cssConfigurator","extendOtherMethods","prototype","isBlacklisted","makeObj","Ractive$reset","dataConfigurator","reset","rerender","config","shouldRerender","unrenderHook","resetTemplate","renderHook$1","completeHook$1","resetHook","collect","refName","COMPONENT","attributes","forceResetTemplate","resetPartial","collection","createResolver","resolver","resolvers","models","resolve$2","ExpressionProxy","ReferenceExpressionProxy","resolveAliases","findElement","orComponent","containerFragment","readStyle","escape","remove","rule","rules","readClass","space","getUpdateDelegate","updateId","getAttribute","updateMultipleSelectValue","updateSelectValue","updateStringValue","updateContentEditableValue","updateRadioValue","textTypes","updateValue","isTwoway","updateRadioName","updateCheckboxName","updateStyleAttribute","updateInlineStyle","namespaceURI","updateClassName","updateInlineClass","isBoolean","type$1","updateBoolean","namespace","updateNamespacedAttribute","updateAttribute","getValue","nodes","removeAttribute","selected","optionValue","locked","wasSelected","disabled","selectedIndex","wasChecked","group","setAttribute","valueAttribute","isChecked","props","prev","safe","setProperty","className","inlineClass","useProperty","propertyName","getString","removeAttributeNS","setAttributeNS","lookupNamespace","qualified","hasAttribute","namespaces","set$2","flag","recreateTwowayBinding","inAttributes","doInAttributes","parseAttributes","isSvg","tagName","div$1","notIn","needle","processWrapper","__model","createOrWrapDescriptor","originalDescriptor","__magic","dependants","setting","descriptor","enumerable","revert","dependant","prettify","fnBody","lines","tabs","minIndent","line","Infinity","truncateStack","Computation","truncated","getComputationSignature","signature","getter","setter","getterString","getterUseStack","setterString","construct","welcome","initialiseProperties","defineProperty","deprecateRactiveData","constructHook","registryNames$1","RootModel","getAdaptors","computed","compute","combine$2","arrays","res","protoAdapt","lookup","adaptor","builtins","srcs","magic","modifyArrays","magicSupported","magicArrayAdaptor","magicAdaptor$1","arrayAdaptor","_guid","uid","getChildQueue","hookQueue","childQueue","hook","initialise","userOptions","computations","computation","configHook","initHook","begin","Fragment","DEBUG_PROMISES","catch","updateLiveQueries","removeFromLiveComponentQueries","makeDirty","updateLiveQueries$1","warnAboutAmbiguity","description","handleDomEvent","getBindingGroup","hash","BindingGroup","all","bindings","handleBlur","handleDelay","delay","timeout","clearTimeout","getSelectedOptions","select","selectedOptions","getSiblings","siblings","getValue$1","isBindable","selectBinding","attributeByName","contenteditable","ContentEditableBinding","bindName","bindChecked","CheckboxBinding","RadioNameBinding","CheckboxNameBinding","RadioBinding","FileBinding","NumericBinding","GenericBinding","MultipleSelectBinding","SingleSelectBinding","makeDirty$1","inputIsCheckedRadio","typeAttribute","nameAttribute","stringifyAttribute","removeFromLiveQueries","getNamespace","xmlns","svg$1","handleReset","formBindings","updateModel$1","createMapping","childData","boundFragment","valueOf","getPartialTemplate","getPartialFromRegistry","noThrow","findParentPartial","isOwner","noRegistryFunctionReturn","findOwner","_fn","findConstructor","_Parent","parsePartial","isEmpty","getType","hasIndexRef","SECTION_EACH","SECTION_IF_WITH","valueContains","selectValue","camelCase","hyphenatedStr","toUpperCase","onChange","visible","hidden","onHide","onShow","unprefix","unprefixPattern","hyphenate","vendorPattern","resetStyle","insertHtml","selectedOption","ieBug","ieBlacklist","createElement","textContent","firstChild","appendChild","elementCache","getComponentConstructor","Component","components","createItem","Text","ComponentConstructor","ElementConstructor","specialElements","Element","Item","Mapping","Attribute","constructors","processItems","guid","counter","TEXT","placeholderId","newModel","wrapperValue","unrenderAndDestroy$1","Ractive$resetTemplate","shouldDestroy","findParentNode","findNextNode","Ractive$set","Ractive$subtract","Ractive$teardown","Promise$1","teardownHook$1","Ractive$toggle","badArguments","Ractive$toCSS","uniqueCssIds","ids","Ractive$toHTML","toText","Ractive$transition","params","HTMLElement","transition","Transition","registerTransition","unlink$1","lastLink","Ractive$unrender","unrenderHook$1","Ractive$updateModel","wrap$1","force","needsSuper","unwrap","Child","addRegistries","addOtherOptions","addRegistry","useDefaults","extend","extendOne","proto","defaults","writable","configurable","joinKeys","splitKeypath","tripleDelimiters","staticDelimiters","staticTripleDelimiters","csp","sanitize","contextLines","twoway","lazy","noCssTransform","easeIn","pow","easeOut","easeInOut","legacy","window","isClient","hasConsole","navigator","appName","console","matches","div","methodNames","unprefixed","makeFunction","svg","implementation","hasFeature","vendors","mathml","xlink","xml","ns","createElementNS","cloneNode","querySelectorAll","desc","F","welcomeIntro","welcomeMessage","WELCOME_MESSAGE","hasGroup","groupCollapsed","groupEnd","delta","intermediate","properties","deprecations","replacement","Hook","arg","PENDING","FULFILLED","REJECTED","dispatchHandlers","makeResolver","fulfilledHandlers","rejectedHandlers","state","newState","onFulfilled","onRejected","promise2","processResolutionHandler","forward","p1result","promises","pending","processPromise","reason","TransitionManager","addChild","isIntro","returnPromise","fulfilPromise","previousBatch","addFragment","addFragmentToRoot","addInstance","addObserver","defer","_manager","detachWhenReady","task","postRender","_batch","isComponentQuery","dirty","_root","nodeOrComponent","KeyModel","isReadonly","deps","links","shouldCapture","rebinding","registerLink","unregister","unregisterLink","KeypathModel","getChild","rebindChildren","dep","hasProp","early","ModelBase","keyModels","unresolved","unresolvedByKey","patternObservers","addUnresolved","addShuffleTask","addShuffleRegister","specificKey","hasKey","attemptResolution","resolved","existingMatches","getValueChildren","skip","getVirtual","virtual","child$1","notify","relinking","keypathModel","registerPatternObserver","registerTwowayBinding","removeUnresolved","shuffled","rewrap","unregisterPatternObserver","unregisterTwowayBinding","oneway","LinkModel","isLink","applyValue","relinked","upstream","lnk","ln","requestAnimationFrame","lastTime","currTime","timeToCall","Date","performance","Ticker","elapsed","eased","stop","abort","Model","newWrapperValue","shouldTeardown","createBranch","branch","retrieve","old","oldArray","newArray","oldLength","usedIndices","firstUnusedIndex","GlobalModel","ReferenceResolver","contexts","forceResolution","oldValue","newValue","once","strict","cancelled","baseKeypath","oldValues","newValues","changed","newKeys","wildcards","suffix","i$1","ok","sliced","inserted","deleted","hadIndex","newIndex","oldIndex","pop$1","push$1","getElementsByTagName","Parser","ParseError","leadingWhitespace","lineStart","lineEnds","lineEnd","leftover","postProcess","converters","lineNum","columnNum","contextUp","contextDown","numTabs","annotation","char","msg","character","shortMessage","Parser$1","BINDING_FLAG","booleanAttributes","quot","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","fromCodePoint","fromCharCode","readTypeOf","makePrefixSequenceMatcher","symbol","fallthrough","matcher","prefixOperators","readLogicalOr","makeInfixSequenceMatcher","readTypeof","left","right","infixOperators","specials$1","true","false","null","specialsPattern","numberPattern$1","placeholderPattern","placeholderAtStartPattern","onlyWhitespace","placeholder","special","stringLiteral","intro-outro","intro","outro","decorator","each","if","with","unless","li","dt","dd","rt","rp","optgroup","thead","tbody","tfoot","tr","td","th","STANDARD_READERS","TRIPLE_READERS","STATIC_READERS","computedStrings","isTriple","script","textarea","elements","eventAttributes","parseOptions","registryNames","Registry","custom","defaultKeys","order","destroyed","ComputationChild","actuallyChanged","registered","ReferenceExpressionChild","baseResolver","intermediary","isUnresolved","Alias","firstNode","skipParent","propertyNames","accept-charset","accesskey","bgcolor","class","codebase","colspan","datetime","dirname","for","http-equiv","ismap","maxlength","novalidate","pubdate","readonly","rowspan","tabindex","usemap","updateDelegate","twowayBinding","lastVal","BindingFlag","ConditionalAttribute","attrs","mutatorMethods","patchedArrayProto","wrappers","patchArrayMethods","unpatchArrayMethods","__proto__","unpatch","patch","errorMessage$1","ArrayWrapper","instances","magicAdaptor","MagicWrapper","originalDescriptors","getOwnPropertyDescriptor","childKeypath","MagicArrayWrapper","magicWrapper","arrayWrapper","computationContext","setDependencies","dependent","RactiveModel","hasProp$1","applyChanges","_changeHash","flush","targetPath","ractiveModel","unescapedKey","localKey","origin","local","HookQueue","inProcess","DOMEvent","listen","addEventListener","unlisten","removeEventListener","CustomEvent","eventPlugin","RactiveEvent","specialPattern","dollarArgsPattern","EventDirective","events","action","specialMatch","dollarMatch","passedArgs","oldEvent","getArgsList","teardownHook","_partials","yielders","_inlinePartials","leftovers","eventHandlers","setupEvents","checkYielders","toHTML","missingDecorator","Decorator","dynamicName","dynamicArgs","nameFragment","argsFragment","decorators","argsFn","nameChanged","args$1","Doctype","Binding","wasUndefined","getInitialValue","parentForm","lastValue","setFromNode","attachEvent","push$2","checkboxName","noInitialValue","existingValue","bindingValue","valueSoFar","files","forceUpdate","selectedValues","previousValue","setValue","initialValue","nameAttributeBinding","optionWasSelected","endsWithSemi","isVoid","deferContent","createTwowayBinding","shouldBind","existing","nodeName","foundNode","_introTransition","isSelected","cls","unbinding","_outroTransition","Form","Mustache","static","Interpolator","nodeValue","createTextNode","Input","defaultValue","Option","selectedAttribute","Partial","templateObj","named","setTemplate","partialTemplate","RepeatedFragment","pendingNewIndices","previousIterations","createIteration","found","iteration","updatePostShuffle","updating","toRemove","oldKeys","wasArray","fragment$1","newLength","indices","oldLen","removed","contiguous","Section","sectionType","templateSectionType","subordinate","sibling","nextSibling","isTruthy","siblingFalsey","lastType","newFragment","fragmentShouldExist","Select","sync","defaultSelected","selectNode","isMultiple","shouldSelect","Textarea","prefixCache","testStyle","capped","vendor","prefix$1","prefix$2","createTransitions","TRANSITION$1","TRANSITIONEND","CSS_TRANSITIONS_ENABLED","TRANSITION_DURATION","TRANSITION_PROPERTY","TRANSITION_TIMING_FUNCTION","testStyle$1","linear$1","canUseCssTransitions","cannotUseCssTransitions","webkitTransition","changedProperties","transitionDone","cssTimeout","checkComplete","jsTransitionsComplete","cssTransitionsComplete","unregisterCompleteHandler","transitionEndHandler","cssTransitionsDone","property","timing","hashPrefix","registerCompleteHandler","originalValue","propertiesToTransitionInJs","getStyle","createTransitions$1","getComputedStyle","names","t0","t1","t2","onComplete","animateStyle","setStyle","computedStyle","value$1","processParams","completed","originalStyle","noReset","TABLE","THEAD","TBODY","TR","SELECT","Triple","queryResult","queryAllResult","numNodes","Yielder","doctype","form","dirtyArgs","dirtyValue","createItems","argsList","wasBound","wasRendered","toHtml","reverse$1","shift$1","sort$1","splice$1","unshift$1","insert","toCSS","toCss","FUNCTION","VERSION","transitions","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","insertStyleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","replaceText","cssNode","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","userAgent","newList","mayRemove","textStore","Boolean","locals","_interopRequireDefault","__esModule","default","_jquery","_jquery2","_ractive2","_main","_main2","_main3","_main4","_sortableDragList","_sortableDragList2","_sortableDragItem","_sortableDragItem2","Main","SortableDragList","SortableDragItem","list1","list2","currentDrag","currentDrop","currentHolder","currentPos","currentInsertPoint","oninit","handleSortableDragStart","handleSortableDragEnd","handleSortableDragEnter","handleSortableDragOver","handleSortableDragLeave","handleSortableDragDrop","ev","_this","pageX","pageY","destComp","getDropBeforeComp","_this2","srcComp","srcKey","srcData","srcObj","destData","destKey","destInd","dropPos","aggr","comp","offset","top","outerHeight","_sortableDragItem3","_sortableDragItem4","isDragging","handleDragStart","handleDragEnd","onDragOver","inst","dataTransfer","dropEffect","_sortableDragList3","_sortableDragList4","isDropping","handleDragEnter","handleDragOver","handleDragLeave","run","twoWay","includes","readyState","version","mappings","file","sourcesContent","sourceRoot","main","insertAfter","sortableDragItem","sortableDragList","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","w","noGlobal","DOMEval","isArrayLike","jQuery","isWindow","winnow","qualifier","isFunction","grep","elem","risSimple","cur","dir","createOptions","rnothtmlwhite","_","Identity","Thrower","ex","adoptValue","fail","Data","expando","getData","rbrace","rmultiDash","dataUser","adjustCSS","valueParts","tween","adjusted","scale","maxIterations","currentValue","cssNumber","initialInUnit","rcssNum","getDefaultDisplay","temp","ownerDocument","display","defaultDisplayMap","showHide","show","dataPriv","isHiddenWithinTree","getAll","ret","setGlobalEval","elems","refElements","buildFragment","scripts","selection","ignored","tmp","rhtml","rtagName","wrapMap","_default","htmlPrefilter","lastChild","inArray","rscriptType","returnTrue","returnFalse","safeActiveElement","activeElement","types","one","origFn","manipulationTarget","disableScript","restoreScript","rscriptTypeMasked","cloneCopyEvent","src","pdataOld","pdataCur","udataOld","udataCur","hasData","access","handle","fixInput","rcheckableType","domManip","first","hasScripts","iNoClone","support","checkClone","rchecked","self","eq","clone","_evalUrl","rcleanScript","keepData","cleanData","curCSS","width","minWidth","maxWidth","getStyles","getPropertyValue","pixelMarginRight","rnumnonpx","rmargin","addGetHookIf","conditionFn","hookFn","vendorPropName","emptyStyle","capName","cssPrefixes","setPositiveNumber","augmentWidthOrHeight","isBorderBox","cssExpand","getWidthOrHeight","valueIsBorderBox","getClientRects","getBoundingClientRect","boxSizingReliable","Tween","raf","timerId","fx","createFxNow","fxNow","genFx","includeWidth","height","opacity","createTween","animation","Animation","tweeners","defaultPrefilter","hooks","oldfire","propTween","restoreDisplay","isBox","anim","orig","dataShow","_queueHooks","unqueued","always","rfxtypes","isEmptyObject","overflow","overflowX","overflowY","propFilter","specialEasing","cssHooks","expand","stopped","prefilters","deferred","Deferred","currentTime","startTime","percent","tweens","notifyWith","resolveWith","originalProperties","originalOptions","gotoEnd","rejectWith","timer","progress","stripAndCollapse","getClass","buildParams","traditional","rbracket","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","dataTypes","inspectPrefiltersOrTransports","jqXHR","inspect","inspected","prefilterOrFactory","dataTypeOrTransport","seekingTransport","transports","ajaxExtend","deep","flatOptions","ajaxSettings","ajaxHandleResponses","responses","ct","finalDataType","firstDataType","contents","mimeType","getResponseHeader","ajaxConvert","response","isSuccess","conv2","conv","responseFields","dataFilter","throws","getWindow","defaultView","arr","getProto","getPrototypeOf","class2type","fnToString","ObjectFunctionString","rtrim","rmsPrefix","rdashAlpha","fcamelCase","letter","jquery","pushStack","prevObject","last","copyIsArray","isPlainObject","isReady","Ctor","globalEval","makeArray","results","second","invert","callbackInverse","callbackExpect","Symbol","iterator","Sizzle","seed","nid","groups","newSelector","newContext","preferredDoc","setDocument","documentIsHTML","rquickExpr","getElementsByClassName","qsa","compilerCache","rbuggyQSA","rcssescape","fcssescape","tokenize","toSelector","rsibling","testContext","qsaError","createCache","cache","Expr","cacheLength","markFunction","assert","addHandle","attrHandle","siblingCheck","diff","sourceIndex","createInputPseudo","createButtonPseudo","createDisabledPseudo","isDisabled","disabledAncestor","createPositionalPseudo","argument","matchIndexes","setFilters","addCombinator","combinator","checkNonElements","doneName","oldCache","uniqueCache","outerCache","newCache","dirruns","uniqueID","elementMatcher","matchers","multipleContexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","preMap","postMap","preexisting","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","outermostContext","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","TAG","dirrunsUnique","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","classCache","tokenCache","sortOrder","push_native","booleans","whitespace","pseudos","rwhitespace","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","ID","CLASS","ATTR","PSEUDO","CHILD","bool","needsContext","rinputs","rheader","rnative","runescape","funescape","escaped","escapedWhitespace","high","ch","asCodePoint","unloadHandler","els","documentElement","hasCompare","subWindow","createComment","getById","getElementsByName","attrId","getAttributeNode","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","adown","bup","sortDetached","aup","ap","bp","specified","sel","duplicates","detectDuplicates","sortStable","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","operator","what","simple","ofType","nodeIndex","useCache","pseudo","matched","innerText","elemLang","location","focus","hasFocus","tabIndex","enabled","header","button","even","odd","nth","radio","checkbox","password","submit","filters","parseOnly","soFar","preFilters","cached","compiled","unique","isXMLDoc","escapeSelector","until","truncate","is","rneedsContext","rsingleTag","rootjQuery","parseHTML","rparentsprev","guaranteedUnique","targets","closest","prevAll","addBack","parents","parentsUntil","nextAll","nextUntil","prevUntil","contentDocument","Callbacks","firing","memory","fired","firingIndex","stopOnFalse","disable","lock","fireWith","tuples","pipe","fns","newDefer","tuple","returned","onProgress","depth","that","mightThrow","maxDepth","process","exceptionHook","stackTrace","getStackHook","stateString","when","singleValue","resolveContexts","resolveValues","master","updateFunc","rerrorNames","readyException","readyList","readyWait","holdReady","hold","doScroll","chainable","emptyGet","raw","bulk","acceptData","removeData","_data","_removeData","startLength","clearQueue","pnum","swap","hide","col","colgroup","caption","noCloneChecked","rkeyEvent","rmouseEvent","rtypenamespace","handleObjIn","eventHandle","handleObj","origType","elemData","triggered","delegateType","bindType","delegateCount","setup","mappedTypes","origCount","removeEvent","nativeEvent","handlerQueue","fix","delegateTarget","preDispatch","isPropagationStopped","currentTarget","isImmediatePropagationStopped","rnamespace","postDispatch","matchedHandlers","matchedSelectors","addProp","Event","load","noBubble","trigger","blur","click","beforeunload","returnValue","isDefaultPrevented","defaultPrevented","relatedTarget","timeStamp","isSimulated","stopImmediatePropagation","altKey","bubbles","cancelable","changedTouches","ctrlKey","detail","eventPhase","metaKey","shiftKey","view","charCode","keyCode","buttons","clientX","clientY","offsetX","offsetY","pointerId","pointerType","screenX","screenY","targetTouches","toElement","touches","mouseenter","mouseleave","pointerenter","pointerleave","related","rxhtmlTag","rnoInnerhtml","dataAndEvents","deepDataAndEvents","srcElements","destElements","inPage","prepend","before","after","replaceWith","replaceChild","appendTo","prependTo","replaceAll","opener","computeStyleTests","divStyle","pixelPositionVal","reliableMarginLeftVal","marginLeft","boxSizingReliableVal","marginRight","pixelMarginRightVal","backgroundClip","clearCloneStyle","pixelPosition","reliableMarginLeft","rdisplayswap","cssShow","position","visibility","cssNormalTransform","letterSpacing","fontWeight","animationIterationCount","columnCount","fillOpacity","flexGrow","flexShrink","lineHeight","orphans","widows","zIndex","zoom","cssProps","float","origName","margin","padding","border","expanded","propHooks","scrollTop","scrollLeft","swing","cos","PI","rrun","*","tweener","prefilter","speed","opt","speeds","fadeTo","optall","doAnimation","finish","stopQueue","timers","cssFn","slideDown","slideUp","slideToggle","fadeIn","fadeOut","fadeToggle","interval","setInterval","cancelAnimationFrame","clearInterval","slow","fast","time","checkOn","optSelected","radioValue","boolHook","removeAttr","nType","attrHooks","attrNames","lowercaseName","rfocusable","rclickable","removeProp","propFix","addClass","classes","curValue","clazz","finalValue","removeClass","toggleClass","stateVal","classNames","hasClass","rreturn","valHooks","optionSet","rfocusMorph","onlyHandlers","bubbleType","ontype","eventPath","isTrigger","parentWindow","simulate","triggerHandler","hover","fnOver","fnOut","focusin","attaches","nonce","rquery","parseXML","DOMParser","parseFromString","rCRLF","rsubmitterTypes","rsubmittable","param","valueOrFunction","serialize","serializeArray","r20","rhash","rantiCache","rheaders","rlocalProtocol","rnoContent","rprotocol","allTypes","originAnchor","active","lastModified","etag","url","isLocal","protocol","processData","async","contentType","accepts","json","* text","text html","text json","text xml","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","status","nativeStatusText","headers","success","modified","statusText","timeoutTimer","transport","responseHeadersString","ifModified","cacheURL","callbackContext","statusCode","fireGlobals","globalEventContext","completeDeferred","responseHeaders","urlAnchor","uncached","requestHeaders","requestHeadersNames","strAbort","getAllResponseHeaders","setRequestHeader","overrideMimeType","finalText","crossDomain","host","hasContent","beforeSend","send","getJSON","getScript","wrapAll","firstElementChild","wrapInner","offsetWidth","offsetHeight","xhr","XMLHttpRequest","xhrSuccessStatus","0","1223","xhrSupported","cors","errorCallback","username","xhrFields","onload","onerror","onabort","onreadystatechange","responseType","responseText","text script","charset","scriptCharset","evt","oldCallbacks","rjsonp","jsonp","jsonpCallback","originalSettings","callbackName","overwritten","responseContainer","jsonProp","createHTMLDocument","keepScripts","animated","setOffset","curPosition","curLeft","curCSSTop","curTop","curOffset","curCSSLeft","calculatePosition","curElem","using","rect","pageYOffset","clientTop","pageXOffset","clientLeft","offsetParent","parentOffset","scrollTo","Height","Width","","defaultExtra","funcName","delegate","undelegate","_jQuery","_$","$","noConflict"],"mappings":"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A,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,QAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,QAAA,IAAAC,GAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,IAAA,IAAAC,QAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAA/S,MAAA,IAAAgT,QAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OA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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(4);\n\tmodule.exports = __webpack_require__(8);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*\n\t\tRactive.js v0.8.9\n\t\tWed Jan 04 2017 06:42:26 GMT+0000 (UTC) - commit ede92044770a136fd1179bd766fec4d47063faed\n\t\n\t\thttp://ractivejs.org\n\t\thttp://twitter.com/RactiveJS\n\t\n\t\tReleased under the MIT License.\n\t*/\n\t\n\t\n\t(function (global, factory) {\n\t\t true ? module.exports = factory() :\n\t\ttypeof define === 'function' && define.amd ? define(factory) :\n\t\t((function() { var current = global.Ractive; var next = factory(); next.noConflict = function() { global.Ractive = current; return next; }; return global.Ractive = next; })());\n\t}(this, function () { 'use strict';\n\t\n\t\tvar defaults = {\n\t\t\t// render placement:\n\t\t\tel:                     void 0,\n\t\t\tappend:\t\t\t\t    false,\n\t\n\t\t\t// template:\n\t\t\ttemplate:               null,\n\t\n\t\t\t// parse:\n\t\t\tdelimiters:             [ '{{', '}}' ],\n\t\t\ttripleDelimiters:       [ '{{{', '}}}' ],\n\t\t\tstaticDelimiters:       [ '[[', ']]' ],\n\t\t\tstaticTripleDelimiters: [ '[[[', ']]]' ],\n\t\t\tcsp: \t\t\t\t\ttrue,\n\t\t\tinterpolate:            false,\n\t\t\tpreserveWhitespace:     false,\n\t\t\tsanitize:               false,\n\t\t\tstripComments:          true,\n\t\t\tcontextLines:           0,\n\t\n\t\t\t// data & binding:\n\t\t\tdata:                   {},\n\t\t\tcomputed:               {},\n\t\t\tmagic:                  false,\n\t\t\tmodifyArrays:           false,\n\t\t\tadapt:                  [],\n\t\t\tisolated:               false,\n\t\t\ttwoway:                 true,\n\t\t\tlazy:                   false,\n\t\n\t\t\t// transitions:\n\t\t\tnoIntro:                false,\n\t\t\ttransitionsEnabled:     true,\n\t\t\tcomplete:               void 0,\n\t\n\t\t\t// css:\n\t\t\tcss:                    null,\n\t\t\tnoCssTransform:         false\n\t\t};\n\t\n\t\t// These are a subset of the easing equations found at\n\t\t// https://raw.github.com/danro/easing-js - license info\n\t\t// follows:\n\t\n\t\t// --------------------------------------------------\n\t\t// easing.js v0.5.4\n\t\t// Generic set of easing functions with AMD support\n\t\t// https://github.com/danro/easing-js\n\t\t// This code may be freely distributed under the MIT license\n\t\t// http://danro.mit-license.org/\n\t\t// --------------------------------------------------\n\t\t// All functions adapted from Thomas Fuchs & Jeremy Kahn\n\t\t// Easing Equations (c) 2003 Robert Penner, BSD license\n\t\t// https://raw.github.com/danro/easing-js/master/LICENSE\n\t\t// --------------------------------------------------\n\t\n\t\t// In that library, the functions named easeIn, easeOut, and\n\t\t// easeInOut below are named easeInCubic, easeOutCubic, and\n\t\t// (you guessed it) easeInOutCubic.\n\t\t//\n\t\t// You can add additional easing functions to this list, and they\n\t\t// will be globally available.\n\t\n\t\n\t\tvar easing = {\n\t\t\tlinear: function ( pos ) { return pos; },\n\t\t\teaseIn: function ( pos ) { return Math.pow( pos, 3 ); },\n\t\t\teaseOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },\n\t\t\teaseInOut: function ( pos ) {\n\t\t\t\tif ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }\n\t\t\t\treturn ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );\n\t\t\t}\n\t\t};\n\t\n\t\tvar legacy = null;\n\t\n\t\t/*global console, navigator */\n\t\n\t\tvar win = typeof window !== 'undefined' ? window : null;\n\t\tvar doc = win ? document : null;\n\t\n\t\tvar isClient = !!doc;\n\t\tvar isJsdom = ( typeof navigator !== 'undefined' && /jsDom/.test( navigator.appName ) );\n\t\tvar hasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );\n\t\n\t\tvar magicSupported;\n\t\ttry {\n\t\t\tObject.defineProperty({}, 'test', { value: 0 });\n\t\t\tmagicSupported = true;\n\t\t} catch ( e ) {\n\t\t\tmagicSupported = false;\n\t\t}\n\t\n\t\tvar svg = doc ?\n\t\t\tdoc.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' ) :\n\t\t\tfalse;\n\t\n\t\tvar vendors = [ 'o', 'ms', 'moz', 'webkit' ];\n\t\n\t\tvar html   = 'http://www.w3.org/1999/xhtml';\n\t\tvar mathml = 'http://www.w3.org/1998/Math/MathML';\n\t\tvar svg$1    = 'http://www.w3.org/2000/svg';\n\t\tvar xlink  = 'http://www.w3.org/1999/xlink';\n\t\tvar xml    = 'http://www.w3.org/XML/1998/namespace';\n\t\tvar xmlns  = 'http://www.w3.org/2000/xmlns';\n\t\n\t\tvar namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };\n\t\n\t\tvar createElement;\n\t\tvar matches;\n\t\tvar div;\n\t\tvar methodNames;\n\t\tvar unprefixed;\n\t\tvar prefixed;\n\t\tvar i;\n\t\tvar j;\n\t\tvar makeFunction;\n\t\t// Test for SVG support\n\t\tif ( !svg ) {\n\t\t\tcreateElement = function ( type, ns, extend ) {\n\t\t\t\tif ( ns && ns !== html ) {\n\t\t\t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n\t\t\t\t}\n\t\n\t\t\t\treturn extend ?\n\t\t\t\t\tdoc.createElement( type, extend ) :\n\t\t\t\t\tdoc.createElement( type );\n\t\t\t};\n\t\t} else {\n\t\t\tcreateElement = function ( type, ns, extend ) {\n\t\t\t\tif ( !ns || ns === html ) {\n\t\t\t\t\treturn extend ?\n\t\t\t\t\t\tdoc.createElement( type, extend ) :\n\t\t\t\t\t\tdoc.createElement( type );\n\t\t\t\t}\n\t\n\t\t\t\treturn extend ?\n\t\t\t\t\tdoc.createElementNS( ns, type, extend ) :\n\t\t\t\t\tdoc.createElementNS( ns, type );\n\t\t\t};\n\t\t}\n\t\n\t\tfunction createDocumentFragment () {\n\t\t\treturn doc.createDocumentFragment();\n\t\t}\n\t\n\t\tfunction getElement ( input ) {\n\t\t\tvar output;\n\t\n\t\t\tif ( !input || typeof input === 'boolean' ) { return; }\n\t\n\t\t\tif ( !win || !doc || !input ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// We already have a DOM node - no work to do. (Duck typing alert!)\n\t\t\tif ( input.nodeType ) {\n\t\t\t\treturn input;\n\t\t\t}\n\t\n\t\t\t// Get node from string\n\t\t\tif ( typeof input === 'string' ) {\n\t\t\t\t// try ID first\n\t\t\t\toutput = doc.getElementById( input );\n\t\n\t\t\t\t// then as selector, if possible\n\t\t\t\tif ( !output && doc.querySelector ) {\n\t\t\t\t\toutput = doc.querySelector( input );\n\t\t\t\t}\n\t\n\t\t\t\t// did it work?\n\t\t\t\tif ( output && output.nodeType ) {\n\t\t\t\t\treturn output;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n\t\t\tif ( input[0] && input[0].nodeType ) {\n\t\t\t\treturn input[0];\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tif ( !isClient ) {\n\t\t\tmatches = null;\n\t\t} else {\n\t\t\tdiv = createElement( 'div' );\n\t\t\tmethodNames = [ 'matches', 'matchesSelector' ];\n\t\n\t\t\tmakeFunction = function ( methodName ) {\n\t\t\t\treturn function ( node, selector ) {\n\t\t\t\t\treturn node[ methodName ]( selector );\n\t\t\t\t};\n\t\t\t};\n\t\n\t\t\ti = methodNames.length;\n\t\n\t\t\twhile ( i-- && !matches ) {\n\t\t\t\tunprefixed = methodNames[i];\n\t\n\t\t\t\tif ( div[ unprefixed ] ) {\n\t\t\t\t\tmatches = makeFunction( unprefixed );\n\t\t\t\t} else {\n\t\t\t\t\tj = vendors.length;\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\tprefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\t\n\t\t\t\t\t\tif ( div[ prefixed ] ) {\n\t\t\t\t\t\t\tmatches = makeFunction( prefixed );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// IE8...\n\t\t\tif ( !matches ) {\n\t\t\t\tmatches = function ( node, selector ) {\n\t\t\t\t\tvar nodes, parentNode, i;\n\t\n\t\t\t\t\tparentNode = node.parentNode;\n\t\n\t\t\t\t\tif ( !parentNode ) {\n\t\t\t\t\t\t// empty dummy <div>\n\t\t\t\t\t\tdiv.innerHTML = '';\n\t\n\t\t\t\t\t\tparentNode = div;\n\t\t\t\t\t\tnode = node.cloneNode();\n\t\n\t\t\t\t\t\tdiv.appendChild( node );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnodes = parentNode.querySelectorAll( selector );\n\t\n\t\t\t\t\ti = nodes.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( nodes[i] === node ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\n\t\tfunction detachNode ( node ) {\n\t\t\tif ( node && typeof node.parentNode !== 'unknown' && node.parentNode ) {\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\n\t\t\treturn node;\n\t\t}\n\t\n\t\tfunction safeToStringValue ( value ) {\n\t\t\treturn ( value == null || !value.toString ) ? '' : '' + value;\n\t\t}\n\t\n\t\tfunction safeAttributeString ( string ) {\n\t\t\treturn safeToStringValue( string )\n\t\t\t\t.replace( /&/g, '&amp;' )\n\t\t\t\t.replace( /\"/g, '&quot;' )\n\t\t\t\t.replace( /'/g, '&#39;' );\n\t\t}\n\t\n\t\tvar decamel = /[A-Z]/g;\n\t\tfunction decamelize ( string ) {\n\t\t\treturn string.replace( decamel, function ( s ) { return (\"-\" + (s.toLowerCase())); } );\n\t\t}\n\t\n\t\tvar create;\n\t\tvar defineProperty;\n\t\tvar defineProperties;\n\t\ttry {\n\t\t\tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\t\n\t\t\tif ( doc ) {\n\t\t\t\tObject.defineProperty( createElement( 'div' ), 'test', { value: 0 });\n\t\t\t}\n\t\n\t\t\tdefineProperty = Object.defineProperty;\n\t\t} catch ( err ) {\n\t\t\t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n\t\t\t// only use it with DOM objects (what were you smoking, MSFT?)\n\t\t\tdefineProperty = function ( obj, prop, desc ) {\n\t\t\t\tif ( desc.get ) obj[ prop ] = desc.get();\n\t\t\t\telse obj[ prop ] = desc.value;\n\t\t\t};\n\t\t}\n\t\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tObject.defineProperties({}, { test: { value: 0 } });\n\t\t\t} catch ( err ) {\n\t\t\t\t// TODO how do we account for this? noMagic = true;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\n\t\t\tif ( doc ) {\n\t\t\t\tObject.defineProperties( createElement( 'div' ), { test: { value: 0 } });\n\t\t\t}\n\t\n\t\t\tdefineProperties = Object.defineProperties;\n\t\t} catch ( err ) {\n\t\t\tdefineProperties = function ( obj, props ) {\n\t\t\t\tvar prop;\n\t\n\t\t\t\tfor ( prop in props ) {\n\t\t\t\t\tif ( props.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\ttry {\n\t\t\tObject.create( null );\n\t\n\t\t\tcreate = Object.create;\n\t\t} catch ( err ) {\n\t\t\t// sigh\n\t\t\tcreate = (function () {\n\t\t\t\tvar F = function () {};\n\t\n\t\t\t\treturn function ( proto, props ) {\n\t\t\t\t\tvar obj;\n\t\n\t\t\t\t\tif ( proto === null ) {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\n\t\t\t\t\tF.prototype = proto;\n\t\t\t\t\tobj = new F();\n\t\n\t\t\t\t\tif ( props ) {\n\t\t\t\t\t\tObject.defineProperties( obj, props );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn obj;\n\t\t\t\t};\n\t\t\t}());\n\t\t}\n\t\n\t\tfunction extendObj ( target ) {\n\t\t\tvar sources = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t\t\tvar prop;\n\t\n\t\t\tsources.forEach( function ( source ) {\n\t\t\t\tfor ( prop in source ) {\n\t\t\t\t\tif ( hasOwn.call( source, prop ) ) {\n\t\t\t\t\t\ttarget[ prop ] = source[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn target;\n\t\t}\n\t\n\t\tfunction fillGaps ( target ) {\n\t\t\tvar sources = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t\t\tsources.forEach( function ( s ) {\n\t\t\t\tfor ( var key in s ) {\n\t\t\t\t\tif ( hasOwn.call( s, key ) && !( key in target ) ) {\n\t\t\t\t\t\ttarget[ key ] = s[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn target;\n\t\t}\n\t\n\t\tvar hasOwn = Object.prototype.hasOwnProperty;\n\t\n\t\tvar toString = Object.prototype.toString;\n\t\t// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n\t\tfunction isArray ( thing ) {\n\t\t\treturn toString.call( thing ) === '[object Array]';\n\t\t}\n\t\n\t\tfunction isEqual ( a, b ) {\n\t\t\tif ( a === null && b === null ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\tif ( typeof a === 'object' || typeof b === 'object' ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\treturn a === b;\n\t\t}\n\t\n\t\t// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n\t\tfunction isNumeric ( thing ) {\n\t\t\treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n\t\t}\n\t\n\t\tfunction isObject ( thing ) {\n\t\t\treturn ( thing && toString.call( thing ) === '[object Object]' );\n\t\t}\n\t\n\t\tfunction noop () {}\n\t\n\t\tvar alreadyWarned = {};\n\t\tvar log;\n\t\tvar printWarning;\n\t\tvar welcome;\n\t\tif ( hasConsole ) {\n\t\t\tvar welcomeIntro = [\n\t\t\t\t(\"%cRactive.js %c0.8.9 %cin debug mode, %cmore...\"),\n\t\t\t\t'color: rgb(114, 157, 52); font-weight: normal;',\n\t\t\t\t'color: rgb(85, 85, 85); font-weight: normal;',\n\t\t\t\t'color: rgb(85, 85, 85); font-weight: normal;',\n\t\t\t\t'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n\t\t\t];\n\t\t\tvar welcomeMessage = \"You're running Ractive 0.8.9 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\t\n\t\t\twelcome = function () {\n\t\t\t\tif ( Ractive.WELCOME_MESSAGE === false ) {\n\t\t\t\t\twelcome = noop;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n\t\t\t\tvar hasGroup = !!console.groupCollapsed;\n\t\t\t\tif ( hasGroup ) console.groupCollapsed.apply( console, welcomeIntro );\n\t\t\t\tconsole.log( message );\n\t\t\t\tif ( hasGroup ) {\n\t\t\t\t\tconsole.groupEnd( welcomeIntro );\n\t\t\t\t}\n\t\n\t\t\t\twelcome = noop;\n\t\t\t};\n\t\n\t\t\tprintWarning = function ( message, args ) {\n\t\t\t\twelcome();\n\t\n\t\t\t\t// extract information about the instance this message pertains to, if applicable\n\t\t\t\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\t\t\t\tvar options = args.pop();\n\t\t\t\t\tvar ractive = options ? options.ractive : null;\n\t\n\t\t\t\t\tif ( ractive ) {\n\t\t\t\t\t\t// if this is an instance of a component that we know the name of, add\n\t\t\t\t\t\t// it to the message\n\t\t\t\t\t\tvar name;\n\t\t\t\t\t\tif ( ractive.component && ( name = ractive.component.name ) ) {\n\t\t\t\t\t\t\tmessage = \"<\" + name + \"> \" + message;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar node;\n\t\t\t\t\t\tif ( node = ( options.node || ( ractive.fragment && ractive.fragment.rendered && ractive.find( '*' ) ) ) ) {\n\t\t\t\t\t\t\targs.push( node );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tconsole.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );\n\t\t\t};\n\t\n\t\t\tlog = function () {\n\t\t\t\tconsole.log.apply( console, arguments );\n\t\t\t};\n\t\t} else {\n\t\t\tprintWarning = log = welcome = noop;\n\t\t}\n\t\n\t\tfunction format ( message, args ) {\n\t\t\treturn message.replace( /%s/g, function () { return args.shift(); } );\n\t\t}\n\t\n\t\tfunction fatal ( message ) {\n\t\t\tvar args = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t\t\tmessage = format( message, args );\n\t\t\tthrow new Error( message );\n\t\t}\n\t\n\t\tfunction logIfDebug () {\n\t\t\tif ( Ractive.DEBUG ) {\n\t\t\t\tlog.apply( null, arguments );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction warn ( message ) {\n\t\t\tvar args = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t\t\tmessage = format( message, args );\n\t\t\tprintWarning( message, args );\n\t\t}\n\t\n\t\tfunction warnOnce ( message ) {\n\t\t\tvar args = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t\t\tmessage = format( message, args );\n\t\n\t\t\tif ( alreadyWarned[ message ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\talreadyWarned[ message ] = true;\n\t\t\tprintWarning( message, args );\n\t\t}\n\t\n\t\tfunction warnIfDebug () {\n\t\t\tif ( Ractive.DEBUG ) {\n\t\t\t\twarn.apply( null, arguments );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction warnOnceIfDebug () {\n\t\t\tif ( Ractive.DEBUG ) {\n\t\t\t\twarnOnce.apply( null, arguments );\n\t\t\t}\n\t\t}\n\t\n\t\t// Error messages that are used (or could be) in multiple places\n\t\tvar badArguments = 'Bad arguments';\n\t\tvar noRegistryFunctionReturn = 'A function was specified for \"%s\" %s, but no %s was returned';\n\t\tvar missingPlugin = function ( name, type ) { return (\"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\" + type + \"s\"); };\n\t\n\t\tfunction findInViewHierarchy ( registryName, ractive, name ) {\n\t\t\tvar instance = findInstance( registryName, ractive, name );\n\t\t\treturn instance ? instance[ registryName ][ name ] : null;\n\t\t}\n\t\n\t\tfunction findInstance ( registryName, ractive, name ) {\n\t\t\twhile ( ractive ) {\n\t\t\t\tif ( name in ractive[ registryName ] ) {\n\t\t\t\t\treturn ractive;\n\t\t\t\t}\n\t\n\t\t\t\tif ( ractive.isolated ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tractive = ractive.parent;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction interpolate ( from, to, ractive, type ) {\n\t\t\tif ( from === to ) return null;\n\t\n\t\t\tif ( type ) {\n\t\t\t\tvar interpol = findInViewHierarchy( 'interpolators', ractive, type );\n\t\t\t\tif ( interpol ) return interpol( from, to ) || null;\n\t\n\t\t\t\tfatal( missingPlugin( type, 'interpolator' ) );\n\t\t\t}\n\t\n\t\t\treturn interpolators.number( from, to ) ||\n\t\t\t       interpolators.array( from, to ) ||\n\t\t\t       interpolators.object( from, to ) ||\n\t\t\t       null;\n\t\t}\n\t\n\t\tfunction snap ( to ) {\n\t\t\treturn function () { return to; };\n\t\t}\n\t\n\t\tvar interpolators = {\n\t\t\tnumber: function ( from, to ) {\n\t\t\t\tvar delta;\n\t\n\t\t\t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tfrom = +from;\n\t\t\t\tto = +to;\n\t\n\t\t\t\tdelta = to - from;\n\t\n\t\t\t\tif ( !delta ) {\n\t\t\t\t\treturn function () { return from; };\n\t\t\t\t}\n\t\n\t\t\t\treturn function ( t ) {\n\t\t\t\t\treturn from + ( t * delta );\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\tarray: function ( from, to ) {\n\t\t\t\tvar intermediate, interpolators, len, i;\n\t\n\t\t\t\tif ( !isArray( from ) || !isArray( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tintermediate = [];\n\t\t\t\tinterpolators = [];\n\t\n\t\t\t\ti = len = Math.min( from.length, to.length );\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tinterpolators[i] = interpolate( from[i], to[i] );\n\t\t\t\t}\n\t\n\t\t\t\t// surplus values - don't interpolate, but don't exclude them either\n\t\t\t\tfor ( i=len; i<from.length; i+=1 ) {\n\t\t\t\t\tintermediate[i] = from[i];\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i=len; i<to.length; i+=1 ) {\n\t\t\t\t\tintermediate[i] = to[i];\n\t\t\t\t}\n\t\n\t\t\t\treturn function ( t ) {\n\t\t\t\t\tvar i = len;\n\t\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tintermediate[i] = interpolators[i]( t );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn intermediate;\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\tobject: function ( from, to ) {\n\t\t\t\tvar properties, len, interpolators, intermediate, prop;\n\t\n\t\t\t\tif ( !isObject( from ) || !isObject( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tproperties = [];\n\t\t\t\tintermediate = {};\n\t\t\t\tinterpolators = {};\n\t\n\t\t\t\tfor ( prop in from ) {\n\t\t\t\t\tif ( hasOwn.call( from, prop ) ) {\n\t\t\t\t\t\tif ( hasOwn.call( to, prop ) ) {\n\t\t\t\t\t\t\tproperties.push( prop );\n\t\t\t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tintermediate[ prop ] = from[ prop ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( prop in to ) {\n\t\t\t\t\tif ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {\n\t\t\t\t\t\tintermediate[ prop ] = to[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tlen = properties.length;\n\t\n\t\t\t\treturn function ( t ) {\n\t\t\t\t\tvar i = len, prop;\n\t\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprop = properties[i];\n\t\n\t\t\t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn intermediate;\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\n\t\t// TODO: deprecate in future release\n\t\tvar deprecations = {\n\t\t\tconstruct: {\n\t\t\t\tdeprecated: 'beforeInit',\n\t\t\t\treplacement: 'onconstruct'\n\t\t\t},\n\t\t\trender: {\n\t\t\t\tdeprecated: 'init',\n\t\t\t\tmessage: 'The \"init\" method has been deprecated ' +\n\t\t\t\t\t'and will likely be removed in a future release. ' +\n\t\t\t\t\t'You can either use the \"oninit\" method which will fire ' +\n\t\t\t\t\t'only once prior to, and regardless of, any eventual ractive ' +\n\t\t\t\t\t'instance being rendered, or if you need to access the ' +\n\t\t\t\t\t'rendered DOM, use \"onrender\" instead. ' +\n\t\t\t\t\t'See http://docs.ractivejs.org/latest/migrating for more information.'\n\t\t\t},\n\t\t\tcomplete: {\n\t\t\t\tdeprecated: 'complete',\n\t\t\t\treplacement: 'oncomplete'\n\t\t\t}\n\t\t};\n\t\n\t\tvar Hook = function Hook ( event ) {\n\t\t\tthis.event = event;\n\t\t\tthis.method = 'on' + event;\n\t\t\tthis.deprecate = deprecations[ event ];\n\t\t};\n\t\n\t\tHook.prototype.call = function call ( method, ractive, arg ) {\n\t\t\tif ( ractive[ method ] ) {\n\t\t\t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\n\t\tHook.prototype.fire = function fire ( ractive, arg ) {\n\t\t\tthis.call( this.method, ractive, arg );\n\t\n\t\t\t// handle deprecations\n\t\t\tif ( !ractive[ this.method ] && this.deprecate && this.call( this.deprecate.deprecated, ractive, arg ) ) {\n\t\t\t\tif ( this.deprecate.message ) {\n\t\t\t\t\twarnIfDebug( this.deprecate.message );\n\t\t\t\t} else {\n\t\t\t\t\twarnIfDebug( 'The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.', this.deprecate.deprecated, this.deprecate.replacement );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// TODO should probably use internal method, in case ractive.fire was overwritten\n\t\t\targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n\t\t};\n\t\n\t\tfunction addToArray ( array, value ) {\n\t\t\tvar index = array.indexOf( value );\n\t\n\t\t\tif ( index === -1 ) {\n\t\t\t\tarray.push( value );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction arrayContains ( array, value ) {\n\t\t\tfor ( var i = 0, c = array.length; i < c; i++ ) {\n\t\t\t\tif ( array[i] == value ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfunction arrayContentsMatch ( a, b ) {\n\t\t\tvar i;\n\t\n\t\t\tif ( !isArray( a ) || !isArray( b ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( a.length !== b.length ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\ti = a.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( a[i] !== b[i] ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\t}\n\t\n\t\tfunction ensureArray ( x ) {\n\t\t\tif ( typeof x === 'string' ) {\n\t\t\t\treturn [ x ];\n\t\t\t}\n\t\n\t\t\tif ( x === undefined ) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\n\t\t\treturn x;\n\t\t}\n\t\n\t\tfunction lastItem ( array ) {\n\t\t\treturn array[ array.length - 1 ];\n\t\t}\n\t\n\t\tfunction removeFromArray ( array, member ) {\n\t\t\tif ( !array ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar index = array.indexOf( member );\n\t\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tarray.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction toArray ( arrayLike ) {\n\t\t\tvar array = [], i = arrayLike.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tarray[i] = arrayLike[i];\n\t\t\t}\n\t\n\t\t\treturn array;\n\t\t}\n\t\n\t\tvar _Promise;\n\t\tvar PENDING = {};\n\t\tvar FULFILLED = {};\n\t\tvar REJECTED = {};\n\t\tif ( typeof Promise === 'function' ) {\n\t\t\t// use native Promise\n\t\t\t_Promise = Promise;\n\t\t} else {\n\t\t\t_Promise = function ( callback ) {\n\t\t\t\tvar fulfilledHandlers = [],\n\t\t\t\t\trejectedHandlers = [],\n\t\t\t\t\tstate = PENDING,\n\t\n\t\t\t\t\tresult,\n\t\t\t\t\tdispatchHandlers,\n\t\t\t\t\tmakeResolver,\n\t\t\t\t\tfulfil,\n\t\t\t\t\treject,\n\t\n\t\t\t\t\tpromise;\n\t\n\t\t\t\tmakeResolver = function ( newState ) {\n\t\t\t\t\treturn function ( value ) {\n\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tresult = value;\n\t\t\t\t\t\tstate = newState;\n\t\n\t\t\t\t\t\tdispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );\n\t\n\t\t\t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t};\n\t\t\t\t};\n\t\n\t\t\t\tfulfil = makeResolver( FULFILLED );\n\t\t\t\treject = makeResolver( REJECTED );\n\t\n\t\t\t\ttry {\n\t\t\t\t\tcallback( fulfil, reject );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t}\n\t\n\t\t\t\tpromise = {\n\t\t\t\t\t// `then()` returns a Promise - 2.2.7\n\t\t\t\t\tthen: function ( onFulfilled, onRejected ) {\n\t\t\t\t\t\tvar promise2 = new _Promise( function ( fulfil, reject ) {\n\t\n\t\t\t\t\t\t\tvar processResolutionHandler = function ( handler, handlers, forward ) {\n\t\n\t\t\t\t\t\t\t\t// 2.2.1.1\n\t\t\t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t\t\t\t\t\t\t\t\thandlers.push( function ( p1result ) {\n\t\t\t\t\t\t\t\t\t\tvar x;\n\t\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t\t\t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t\t\t\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t\t\t\t\t\t\t\t\t// are not given\n\t\t\t\t\t\t\t\t\thandlers.push( forward );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\t// 2.2\n\t\t\t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t\t\t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\t\n\t\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t\t\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\treturn promise2;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tpromise[ 'catch' ] = function ( onRejected ) {\n\t\t\t\t\treturn this.then( null, onRejected );\n\t\t\t\t};\n\t\n\t\t\t\treturn promise;\n\t\t\t};\n\t\n\t\t\t_Promise.all = function ( promises ) {\n\t\t\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\t\t\tvar result = [], pending, i, processPromise;\n\t\n\t\t\t\t\tif ( !promises.length ) {\n\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprocessPromise = function ( promise, i ) {\n\t\t\t\t\t\tif ( promise && typeof promise.then === 'function' ) {\n\t\t\t\t\t\t\tpromise.then( function ( value ) {\n\t\t\t\t\t\t\t\tresult[i] = value;\n\t\t\t\t\t\t\t\t--pending || fulfil( result );\n\t\t\t\t\t\t\t}, reject );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult[i] = promise;\n\t\t\t\t\t\t\t--pending || fulfil( result );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n\t\t\t\t\tpending = i = promises.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprocessPromise( promises[i], i );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\n\t\t\t_Promise.resolve = function ( value ) {\n\t\t\t\treturn new _Promise( function ( fulfil ) {\n\t\t\t\t\tfulfil( value );\n\t\t\t\t});\n\t\t\t};\n\t\n\t\t\t_Promise.reject = function ( reason ) {\n\t\t\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\t\t\treject( reason );\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t\n\t\tvar Promise$1 = _Promise;\n\t\n\t\t// TODO use MutationObservers or something to simulate setImmediate\n\t\tfunction wait ( callback ) {\n\t\t\tsetTimeout( callback, 0 );\n\t\t}\n\t\n\t\tfunction makeDispatcher ( handlers, result ) {\n\t\t\treturn function () {\n\t\t\t\tvar handler;\n\t\n\t\t\t\twhile ( handler = handlers.shift() ) {\n\t\t\t\t\thandler( result );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction resolve ( promise, x, fulfil, reject ) {\n\t\t\t// Promise Resolution Procedure\n\t\t\tvar then;\n\t\n\t\t\t// 2.3.1\n\t\t\tif ( x === promise ) {\n\t\t\t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t\t\t}\n\t\n\t\t\t// 2.3.2\n\t\t\tif ( x instanceof _Promise ) {\n\t\t\t\tx.then( fulfil, reject );\n\t\t\t}\n\t\n\t\t\t// 2.3.3\n\t\t\telse if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t\t\t\ttry {\n\t\t\t\t\tthen = x.then; // 2.3.3.1\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\treject( e ); // 2.3.3.2\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// 2.3.3.3\n\t\t\t\tif ( typeof then === 'function' ) {\n\t\t\t\t\tvar called, resolvePromise, rejectPromise;\n\t\n\t\t\t\t\tresolvePromise = function ( y ) {\n\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\tresolve( promise, y, fulfil, reject );\n\t\t\t\t\t};\n\t\n\t\t\t\t\trejectPromise = function ( r ) {\n\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\treject( r );\n\t\t\t\t\t};\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\tif ( !called ) { // 2.3.3.3.4.1\n\t\t\t\t\t\t\treject( e ); // 2.3.3.3.4.2\n\t\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\tfulfil( x );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\tfulfil( x );\n\t\t\t}\n\t\t}\n\t\n\t\tvar TransitionManager = function TransitionManager ( callback, parent ) {\n\t\t\tthis.callback = callback;\n\t\t\tthis.parent = parent;\n\t\n\t\t\tthis.intros = [];\n\t\t\tthis.outros = [];\n\t\n\t\t\tthis.children = [];\n\t\t\tthis.totalChildren = this.outroChildren = 0;\n\t\n\t\t\tthis.detachQueue = [];\n\t\t\tthis.outrosComplete = false;\n\t\n\t\t\tif ( parent ) {\n\t\t\t\tparent.addChild( this );\n\t\t\t}\n\t\t};\n\t\n\t\tTransitionManager.prototype.add = function add ( transition ) {\n\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\tlist.push( transition );\n\t\t};\n\t\n\t\tTransitionManager.prototype.addChild = function addChild ( child ) {\n\t\t\tthis.children.push( child );\n\t\n\t\t\tthis.totalChildren += 1;\n\t\t\tthis.outroChildren += 1;\n\t\t};\n\t\n\t\tTransitionManager.prototype.decrementOutros = function decrementOutros () {\n\t\t\tthis.outroChildren -= 1;\n\t\t\tcheck( this );\n\t\t};\n\t\n\t\tTransitionManager.prototype.decrementTotal = function decrementTotal () {\n\t\t\tthis.totalChildren -= 1;\n\t\t\tcheck( this );\n\t\t};\n\t\n\t\tTransitionManager.prototype.detachNodes = function detachNodes () {\n\t\t\tthis.detachQueue.forEach( detach );\n\t\t\tthis.children.forEach( _detachNodes );\n\t\t};\n\t\n\t\tTransitionManager.prototype.ready = function ready () {\n\t\t\tdetachImmediate( this );\n\t\t};\n\t\n\t\tTransitionManager.prototype.remove = function remove ( transition ) {\n\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\tremoveFromArray( list, transition );\n\t\t\tcheck( this );\n\t\t};\n\t\n\t\tTransitionManager.prototype.start = function start () {\n\t\t\tthis.children.forEach( function ( c ) { return c.start(); } );\n\t\t\tthis.intros.concat( this.outros ).forEach( function ( t ) { return t.start(); } );\n\t\t\tthis.ready = true;\n\t\t\tcheck( this );\n\t\t};\n\t\n\t\tfunction detach ( element ) {\n\t\t\telement.detach();\n\t\t}\n\t\n\t\tfunction _detachNodes ( tm ) { // _ to avoid transpiler quirk\n\t\t\ttm.detachNodes();\n\t\t}\n\t\n\t\tfunction check ( tm ) {\n\t\t\tif ( !tm.ready || tm.outros.length || tm.outroChildren ) return;\n\t\n\t\t\t// If all outros are complete, and we haven't already done this,\n\t\t\t// we notify the parent if there is one, otherwise\n\t\t\t// start detaching nodes\n\t\t\tif ( !tm.outrosComplete ) {\n\t\t\t\ttm.outrosComplete = true;\n\t\n\t\t\t\tif ( tm.parent && !tm.parent.outrosComplete ) {\n\t\t\t\t\ttm.parent.decrementOutros( tm );\n\t\t\t\t} else {\n\t\t\t\t\ttm.detachNodes();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Once everything is done, we can notify parent transition\n\t\t\t// manager and call the callback\n\t\t\tif ( !tm.intros.length && !tm.totalChildren ) {\n\t\t\t\tif ( typeof tm.callback === 'function' ) {\n\t\t\t\t\ttm.callback();\n\t\t\t\t}\n\t\n\t\t\t\tif ( tm.parent && !tm.notifiedTotal ) {\n\t\t\t\t\ttm.notifiedTotal = true;\n\t\t\t\t\ttm.parent.decrementTotal();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// check through the detach queue to see if a node is up or downstream from a\n\t\t// transition and if not, go ahead and detach it\n\t\tfunction detachImmediate ( manager ) {\n\t\t\tvar queue = manager.detachQueue;\n\t\t\tvar outros = collectAllOutros( manager );\n\t\n\t\t\tvar i = queue.length, j = 0, node, trans;\n\t\t\tstart: while ( i-- ) {\n\t\t\t\tnode = queue[i].node;\n\t\t\t\tj = outros.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttrans = outros[j].element.node;\n\t\t\t\t\t// check to see if the node is, contains, or is contained by the transitioning node\n\t\t\t\t\tif ( trans === node || trans.contains( node ) || node.contains( trans ) ) continue start;\n\t\t\t\t}\n\t\n\t\t\t\t// no match, we can drop it\n\t\t\t\tqueue[i].detach();\n\t\t\t\tqueue.splice( i, 1 );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction collectAllOutros ( manager, list ) {\n\t\t\tif ( !list ) {\n\t\t\t\tlist = [];\n\t\t\t\tvar parent = manager;\n\t\t\t\twhile ( parent.parent ) parent = parent.parent;\n\t\t\t\treturn collectAllOutros( parent, list );\n\t\t\t} else {\n\t\t\t\tvar i = manager.children.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tlist = collectAllOutros( manager.children[i], list );\n\t\t\t\t}\n\t\t\t\tlist = list.concat( manager.outros );\n\t\t\t\treturn list;\n\t\t\t}\n\t\t}\n\t\n\t\tvar changeHook = new Hook( 'change' );\n\t\n\t\tvar batch;\n\t\n\t\tvar runloop = {\n\t\t\tstart: function ( instance, returnPromise ) {\n\t\t\t\tvar promise, fulfilPromise;\n\t\n\t\t\t\tif ( returnPromise ) {\n\t\t\t\t\tpromise = new Promise$1( function ( f ) { return ( fulfilPromise = f ); } );\n\t\t\t\t}\n\t\n\t\t\t\tbatch = {\n\t\t\t\t\tpreviousBatch: batch,\n\t\t\t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t\t\t\t\tfragments: [],\n\t\t\t\t\ttasks: [],\n\t\t\t\t\timmediateObservers: [],\n\t\t\t\t\tdeferredObservers: [],\n\t\t\t\t\tractives: [],\n\t\t\t\t\tinstance: instance\n\t\t\t\t};\n\t\n\t\t\t\treturn promise;\n\t\t\t},\n\t\n\t\t\tend: function () {\n\t\t\t\tflushChanges();\n\t\n\t\t\t\tif ( !batch.previousBatch ) batch.transitionManager.start();\n\t\n\t\t\t\tbatch = batch.previousBatch;\n\t\t\t},\n\t\n\t\t\taddFragment: function ( fragment ) {\n\t\t\t\taddToArray( batch.fragments, fragment );\n\t\t\t},\n\t\n\t\t\t// TODO: come up with a better way to handle fragments that trigger their own update\n\t\t\taddFragmentToRoot: function ( fragment ) {\n\t\t\t\tif ( !batch ) return;\n\t\n\t\t\t\tvar b = batch;\n\t\t\t\twhile ( b.previousBatch ) {\n\t\t\t\t\tb = b.previousBatch;\n\t\t\t\t}\n\t\n\t\t\t\taddToArray( b.fragments, fragment );\n\t\t\t},\n\t\n\t\t\taddInstance: function ( instance ) {\n\t\t\t\tif ( batch ) addToArray( batch.ractives, instance );\n\t\t\t},\n\t\n\t\t\taddObserver: function ( observer, defer ) {\n\t\t\t\taddToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );\n\t\t\t},\n\t\n\t\t\tregisterTransition: function ( transition ) {\n\t\t\t\ttransition._manager = batch.transitionManager;\n\t\t\t\tbatch.transitionManager.add( transition );\n\t\t\t},\n\t\n\t\t\t// synchronise node detachments with transition ends\n\t\t\tdetachWhenReady: function ( thing ) {\n\t\t\t\tbatch.transitionManager.detachQueue.push( thing );\n\t\t\t},\n\t\n\t\t\tscheduleTask: function ( task, postRender ) {\n\t\t\t\tvar _batch;\n\t\n\t\t\t\tif ( !batch ) {\n\t\t\t\t\ttask();\n\t\t\t\t} else {\n\t\t\t\t\t_batch = batch;\n\t\t\t\t\twhile ( postRender && _batch.previousBatch ) {\n\t\t\t\t\t\t// this can't happen until the DOM has been fully updated\n\t\t\t\t\t\t// otherwise in some situations (with components inside elements)\n\t\t\t\t\t\t// transitions and decorators will initialise prematurely\n\t\t\t\t\t\t_batch = _batch.previousBatch;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_batch.tasks.push( task );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tfunction dispatch ( observer ) {\n\t\t\tobserver.dispatch();\n\t\t}\n\t\n\t\tfunction flushChanges () {\n\t\t\tvar which = batch.immediateObservers;\n\t\t\tbatch.immediateObservers = [];\n\t\t\twhich.forEach( dispatch );\n\t\n\t\t\t// Now that changes have been fully propagated, we can update the DOM\n\t\t\t// and complete other tasks\n\t\t\tvar i = batch.fragments.length;\n\t\t\tvar fragment;\n\t\n\t\t\twhich = batch.fragments;\n\t\t\tbatch.fragments = [];\n\t\t\tvar ractives = batch.ractives;\n\t\t\tbatch.ractives = [];\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\tfragment = which[i];\n\t\n\t\t\t\t// TODO deprecate this. It's annoying and serves no useful function\n\t\t\t\tvar ractive = fragment.ractive;\n\t\t\t\tif ( Object.keys( ractive.viewmodel.changes ).length ) {\n\t\t\t\t\tchangeHook.fire( ractive, ractive.viewmodel.changes );\n\t\t\t\t}\n\t\t\t\tractive.viewmodel.changes = {};\n\t\t\t\tremoveFromArray( ractives, ractive );\n\t\n\t\t\t\tfragment.update();\n\t\t\t}\n\t\n\t\t\ti = ractives.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar ractive$1 = ractives[i];\n\t\t\t\tchangeHook.fire( ractive$1, ractive$1.viewmodel.changes );\n\t\t\t\tractive$1.viewmodel.changes = {};\n\t\t\t}\n\t\n\t\t\tbatch.transitionManager.ready();\n\t\n\t\t\twhich = batch.deferredObservers;\n\t\t\tbatch.deferredObservers = [];\n\t\t\twhich.forEach( dispatch );\n\t\n\t\t\tvar tasks = batch.tasks;\n\t\t\tbatch.tasks = [];\n\t\n\t\t\tfor ( i = 0; i < tasks.length; i += 1 ) {\n\t\t\t\ttasks[i]();\n\t\t\t}\n\t\n\t\t\t// If updating the view caused some model blowback - e.g. a triple\n\t\t\t// containing <option> elements caused the binding on the <select>\n\t\t\t// to update - then we start over\n\t\t\tif ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.ractives.length || batch.tasks.length ) return flushChanges();\n\t\t}\n\t\n\t\tvar refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n\t\tvar splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\n\t\tvar escapeKeyPattern = /\\\\|\\./g;\n\t\tvar unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\t\n\t\tfunction escapeKey ( key ) {\n\t\t\tif ( typeof key === 'string' ) {\n\t\t\t\treturn key.replace( escapeKeyPattern, '\\\\$&' );\n\t\t\t}\n\t\n\t\t\treturn key;\n\t\t}\n\t\n\t\tfunction normalise ( ref ) {\n\t\t\treturn ref ? ref.replace( refPattern, '.$1' ) : '';\n\t\t}\n\t\n\t\tfunction splitKeypathI ( keypath ) {\n\t\t\tvar result = [],\n\t\t\t\tmatch;\n\t\n\t\t\tkeypath = normalise( keypath );\n\t\n\t\t\twhile ( match = splitPattern.exec( keypath ) ) {\n\t\t\t\tvar index = match.index + match[1].length;\n\t\t\t\tresult.push( keypath.substr( 0, index ) );\n\t\t\t\tkeypath = keypath.substr( index + 1 );\n\t\t\t}\n\t\n\t\t\tresult.push(keypath);\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\tfunction unescapeKey ( key ) {\n\t\t\tif ( typeof key === 'string' ) {\n\t\t\t\treturn key.replace( unescapeKeyPattern, '$1$2' );\n\t\t\t}\n\t\n\t\t\treturn key;\n\t\t}\n\t\n\t\tfunction bind ( fn, context ) {\n\t\t\tif ( !/this/.test( fn.toString() ) ) return fn;\n\t\n\t\t\tvar bound = fn.bind( context );\n\t\t\tfor ( var prop in fn ) bound[ prop ] = fn[ prop ];\n\t\n\t\t\treturn bound;\n\t\t}\n\t\n\t\tfunction set ( ractive, pairs ) {\n\t\t\tvar promise = runloop.start( ractive, true );\n\t\n\t\t\tvar i = pairs.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar ref = pairs[i], model = ref[0], value = ref[1];\n\t\t\t\tif ( typeof value === 'function' ) value = bind( value, ractive );\n\t\t\t\tmodel.set( value );\n\t\t\t}\n\t\n\t\t\trunloop.end();\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tvar star = /\\*/;\n\t\tfunction gather ( ractive, keypath, base ) {\n\t\t\tif ( base === void 0 ) base = ractive.viewmodel;\n\t\n\t\t\tif ( star.test( keypath ) ) {\n\t\t\t\treturn base.findMatches( splitKeypathI( keypath ) );\n\t\t\t} else {\n\t\t\t\treturn [ base.joinAll( splitKeypathI( keypath ) ) ];\n\t\t\t}\n\t\t}\n\t\n\t\tfunction build ( ractive, keypath, value ) {\n\t\t\tvar sets = [];\n\t\n\t\t\t// set multiple keypaths in one go\n\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\tvar loop = function ( k ) {\n\t\t\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\t\t\tsets.push.apply( sets, gather( ractive, k ).map( function ( m ) { return [ m, keypath[k] ]; } ) );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tfor ( var k in keypath ) loop( k );\n\t\n\t\t\t}\n\t\t\t// set a single keypath\n\t\t\telse {\n\t\t\t\tsets.push.apply( sets, gather( ractive, keypath ).map( function ( m ) { return [ m, value ]; } ) );\n\t\t\t}\n\t\n\t\t\treturn sets;\n\t\t}\n\t\n\t\tvar errorMessage = 'Cannot add to a non-numeric value';\n\t\n\t\tfunction add ( ractive, keypath, d ) {\n\t\t\tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n\t\t\t\tthrow new Error( 'Bad arguments' );\n\t\t\t}\n\t\n\t\t\tvar sets = build( ractive, keypath, d );\n\t\n\t\t\treturn set( ractive, sets.map( function ( pair ) {\n\t\t\t\tvar model = pair[0], add = pair[1], value = model.get();\n\t\t\t\tif ( !isNumeric( add ) || !isNumeric( value ) ) throw new Error( errorMessage );\n\t\t\t\treturn [ model, value + add ];\n\t\t\t}));\n\t\t}\n\t\n\t\tfunction Ractive$add ( keypath, d ) {\n\t\t\treturn add( this, keypath, ( d === undefined ? 1 : +d ) );\n\t\t}\n\t\n\t\tvar noAnimation = Promise$1.resolve();\n\t\tdefineProperty( noAnimation, 'stop', { value: noop });\n\t\n\t\tvar linear = easing.linear;\n\t\n\t\tfunction getOptions ( options, instance ) {\n\t\t\toptions = options || {};\n\t\n\t\t\tvar easing;\n\t\t\tif ( options.easing ) {\n\t\t\t\teasing = typeof options.easing === 'function' ?\n\t\t\t\t\toptions.easing :\n\t\t\t\t\tinstance.easing[ options.easing ];\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\teasing: easing || linear,\n\t\t\t\tduration: 'duration' in options ? options.duration : 400,\n\t\t\t\tcomplete: options.complete || noop,\n\t\t\t\tstep: options.step || noop\n\t\t\t};\n\t\t}\n\t\n\t\tfunction protoAnimate ( ractive, model, to, options ) {\n\t\t\toptions = getOptions( options, ractive );\n\t\t\tvar from = model.get();\n\t\n\t\t\t// don't bother animating values that stay the same\n\t\t\tif ( isEqual( from, to ) ) {\n\t\t\t\toptions.complete( options.to );\n\t\t\t\treturn noAnimation; // TODO should this have .then and .catch methods?\n\t\t\t}\n\t\n\t\t\tvar interpolator = interpolate( from, to, ractive, options.interpolator );\n\t\n\t\t\t// if we can't interpolate the value, set it immediately\n\t\t\tif ( !interpolator ) {\n\t\t\t\trunloop.start();\n\t\t\t\tmodel.set( to );\n\t\t\t\trunloop.end();\n\t\n\t\t\t\treturn noAnimation;\n\t\t\t}\n\t\n\t\t\treturn model.animate( from, to, options, interpolator );\n\t\t}\n\t\n\t\tfunction Ractive$animate ( keypath, to, options ) {\n\t\t\tif ( typeof keypath === 'object' ) {\n\t\t\t\tvar keys = Object.keys( keypath );\n\t\n\t\t\t\tthrow new Error( (\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \" + (keys.map( function ( key ) { return (\"'\" + key + \"': \" + (keypath[ key ])); } ).join( '\\n  ' )) + \"\\n}, {...}), do\\n\\n\" + (keys.map( function ( key ) { return (\"ractive.animate('\" + key + \"', \" + (keypath[ key ]) + \", {...});\"); } ).join( '\\n' )) + \"\\n\") );\n\t\t\t}\n\t\n\t\n\t\t\treturn protoAnimate( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), to, options );\n\t\t}\n\t\n\t\tvar detachHook = new Hook( 'detach' );\n\t\n\t\tfunction Ractive$detach () {\n\t\t\tif ( this.isDetached ) {\n\t\t\t\treturn this.el;\n\t\t\t}\n\t\n\t\t\tif ( this.el ) {\n\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t}\n\t\n\t\t\tthis.el = this.fragment.detach();\n\t\t\tthis.isDetached = true;\n\t\n\t\t\tdetachHook.fire( this );\n\t\t\treturn this.el;\n\t\t}\n\t\n\t\tfunction Ractive$find ( selector ) {\n\t\t\tif ( !this.el ) throw new Error( (\"Cannot call ractive.find('\" + selector + \"') unless instance is rendered to the DOM\") );\n\t\n\t\t\treturn this.fragment.find( selector );\n\t\t}\n\t\n\t\tfunction sortByDocumentPosition ( node, otherNode ) {\n\t\t\tif ( node.compareDocumentPosition ) {\n\t\t\t\tvar bitmask = node.compareDocumentPosition( otherNode );\n\t\t\t\treturn ( bitmask & 2 ) ? 1 : -1;\n\t\t\t}\n\t\n\t\t\t// In old IE, we can piggy back on the mechanism for\n\t\t\t// comparing component positions\n\t\t\treturn sortByItemPosition( node, otherNode );\n\t\t}\n\t\n\t\tfunction sortByItemPosition ( a, b ) {\n\t\t\tvar ancestryA = getAncestry( a.component || a._ractive.proxy );\n\t\t\tvar ancestryB = getAncestry( b.component || b._ractive.proxy );\n\t\n\t\t\tvar oldestA = lastItem( ancestryA );\n\t\t\tvar oldestB = lastItem( ancestryB );\n\t\t\tvar mutualAncestor;\n\t\n\t\t\t// remove items from the end of both ancestries as long as they are identical\n\t\t\t// - the final one removed is the closest mutual ancestor\n\t\t\twhile ( oldestA && ( oldestA === oldestB ) ) {\n\t\t\t\tancestryA.pop();\n\t\t\t\tancestryB.pop();\n\t\n\t\t\t\tmutualAncestor = oldestA;\n\t\n\t\t\t\toldestA = lastItem( ancestryA );\n\t\t\t\toldestB = lastItem( ancestryB );\n\t\t\t}\n\t\n\t\t\t// now that we have the mutual ancestor, we can find which is earliest\n\t\t\toldestA = oldestA.component || oldestA;\n\t\t\toldestB = oldestB.component || oldestB;\n\t\n\t\t\tvar fragmentA = oldestA.parentFragment;\n\t\t\tvar fragmentB = oldestB.parentFragment;\n\t\n\t\t\t// if both items share a parent fragment, our job is easy\n\t\t\tif ( fragmentA === fragmentB ) {\n\t\t\t\tvar indexA = fragmentA.items.indexOf( oldestA );\n\t\t\t\tvar indexB = fragmentB.items.indexOf( oldestB );\n\t\n\t\t\t\t// if it's the same index, it means one contains the other,\n\t\t\t\t// so we see which has the longest ancestry\n\t\t\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t\t\t}\n\t\n\t\t\t// if mutual ancestor is a section, we first test to see which section\n\t\t\t// fragment comes first\n\t\t\tvar fragments = mutualAncestor.iterations;\n\t\t\tif ( fragments ) {\n\t\t\t\tvar indexA$1 = fragments.indexOf( fragmentA );\n\t\t\t\tvar indexB$1 = fragments.indexOf( fragmentB );\n\t\n\t\t\t\treturn ( indexA$1 - indexB$1 ) || ancestryA.length - ancestryB.length;\n\t\t\t}\n\t\n\t\t\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t}\n\t\n\t\tfunction getParent ( item ) {\n\t\t\tvar parentFragment = item.parentFragment;\n\t\n\t\t\tif ( parentFragment ) return parentFragment.owner;\n\t\n\t\t\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\t\t\treturn parentFragment.owner;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getAncestry ( item ) {\n\t\t\tvar ancestry = [ item ];\n\t\t\tvar ancestor = getParent( item );\n\t\n\t\t\twhile ( ancestor ) {\n\t\t\t\tancestry.push( ancestor );\n\t\t\t\tancestor = getParent( ancestor );\n\t\t\t}\n\t\n\t\t\treturn ancestry;\n\t\t}\n\t\n\t\n\t\tvar Query = function Query ( ractive, selector, live, isComponentQuery ) {\n\t\t\tthis.ractive = ractive;\n\t\t\tthis.selector = selector;\n\t\t\tthis.live = live;\n\t\t\tthis.isComponentQuery = isComponentQuery;\n\t\n\t\t\tthis.result = [];\n\t\n\t\t\tthis.dirty = true;\n\t\t};\n\t\n\t\tQuery.prototype.add = function add ( item ) {\n\t\t\tthis.result.push( item );\n\t\t\tthis.makeDirty();\n\t\t};\n\t\n\t\tQuery.prototype.cancel = function cancel () {\n\t\t\tvar liveQueries = this._root[ this.isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\t\t\tvar selector = this.selector;\n\t\n\t\t\tvar index = liveQueries.indexOf( selector );\n\t\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tliveQueries.splice( index, 1 );\n\t\t\t\tliveQueries[ selector ] = null;\n\t\t\t}\n\t\t};\n\t\n\t\tQuery.prototype.init = function init () {\n\t\t\tthis.dirty = false;\n\t\t};\n\t\n\t\tQuery.prototype.makeDirty = function makeDirty () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\t// Once the DOM has been updated, ensure the query\n\t\t\t\t// is correctly ordered\n\t\t\t\trunloop.scheduleTask( function () { return this$1.update(); } );\n\t\t\t}\n\t\t};\n\t\n\t\tQuery.prototype.remove = function remove ( nodeOrComponent ) {\n\t\t\tvar index = this.result.indexOf( this.isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\t\t\tif ( index !== -1 ) this.result.splice( index, 1 );\n\t\t};\n\t\n\t\tQuery.prototype.update = function update () {\n\t\t\tthis.result.sort( this.isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\t\t\tthis.dirty = false;\n\t\t};\n\t\n\t\tQuery.prototype.test = function test ( item ) {\n\t\t\treturn this.isComponentQuery ?\n\t\t\t\t( !this.selector || item.name === this.selector ) :\n\t\t\t\t( item ? matches( item, this.selector ) : null );\n\t\t};\n\t\n\t\tfunction Ractive$findAll ( selector, options ) {\n\t\t\tif ( !this.el ) throw new Error( (\"Cannot call ractive.findAll('\" + selector + \"', ...) unless instance is rendered to the DOM\") );\n\t\n\t\t\toptions = options || {};\n\t\t\tvar liveQueries = this._liveQueries;\n\t\n\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\tvar query = liveQueries[ selector ];\n\t\t\tif ( query ) {\n\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\treturn ( options && options.live ) ? query : query.slice();\n\t\t\t}\n\t\n\t\t\tquery = new Query( this, selector, !!options.live, false );\n\t\n\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t// if applicable\n\t\t\tif ( query.live ) {\n\t\t\t\tliveQueries.push( selector );\n\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t}\n\t\n\t\t\tthis.fragment.findAll( selector, query );\n\t\n\t\t\tquery.init();\n\t\t\treturn query.result;\n\t\t}\n\t\n\t\tfunction Ractive$findAllComponents ( selector, options ) {\n\t\t\toptions = options || {};\n\t\t\tvar liveQueries = this._liveComponentQueries;\n\t\n\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\tvar query = liveQueries[ selector ];\n\t\t\tif ( query ) {\n\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\treturn ( options && options.live ) ? query : query.slice();\n\t\t\t}\n\t\n\t\t\tquery = new Query( this, selector, !!options.live, true );\n\t\n\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t// if applicable\n\t\t\tif ( query.live ) {\n\t\t\t\tliveQueries.push( selector );\n\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t}\n\t\n\t\t\tthis.fragment.findAllComponents( selector, query );\n\t\n\t\t\tquery.init();\n\t\t\treturn query.result;\n\t\t}\n\t\n\t\tfunction Ractive$findComponent ( selector ) {\n\t\t\treturn this.fragment.findComponent( selector );\n\t\t}\n\t\n\t\tfunction Ractive$findContainer ( selector ) {\n\t\t\tif ( this.container ) {\n\t\t\t\tif ( this.container.component && this.container.component.name === selector ) {\n\t\t\t\t\treturn this.container;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.container.findContainer( selector );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction Ractive$findParent ( selector ) {\n\t\n\t\t\tif ( this.parent ) {\n\t\t\t\tif ( this.parent.component && this.parent.component.name === selector ) {\n\t\t\t\t\treturn this.parent;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.parent.findParent ( selector );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction enqueue ( ractive, event ) {\n\t\t\tif ( ractive.event ) {\n\t\t\t\tractive._eventQueue.push( ractive.event );\n\t\t\t}\n\t\n\t\t\tractive.event = event;\n\t\t}\n\t\n\t\tfunction dequeue ( ractive ) {\n\t\t\tif ( ractive._eventQueue.length ) {\n\t\t\t\tractive.event = ractive._eventQueue.pop();\n\t\t\t} else {\n\t\t\t\tractive.event = null;\n\t\t\t}\n\t\t}\n\t\n\t\tvar starMaps = {};\n\t\n\t\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t\t// all the variants of that keypath that include a wildcard in place\n\t\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t\t// to see if any pattern observers are downstream of one or more of\n\t\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t\tfunction getPotentialWildcardMatches ( keypath ) {\n\t\t\tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\t\n\t\t\tkeys = splitKeypathI( keypath );\n\t\t\tif( !( starMap = starMaps[ keys.length ]) ) {\n\t\t\t\tstarMap = getStarMap( keys.length );\n\t\t\t}\n\t\n\t\t\tresult = [];\n\t\n\t\t\tmapper = function ( star, i ) {\n\t\t\t\treturn star ? '*' : keys[i];\n\t\t\t};\n\t\n\t\t\ti = starMap.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\twildcardKeypath = starMap[i].map( mapper ).join( '.' );\n\t\n\t\t\t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n\t\t\t\t\tresult.push( wildcardKeypath );\n\t\t\t\t\tresult[ wildcardKeypath ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\t// This function returns all the possible true/false combinations for\n\t\t// a given number - e.g. for two, the possible combinations are\n\t\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t\t// It does so by getting all the binary values between 0 and e.g. 11\n\t\tfunction getStarMap ( num ) {\n\t\t\tvar ones = '', max, binary, starMap, mapper, i, j, l, map;\n\t\n\t\t\tif ( !starMaps[ num ] ) {\n\t\t\t\tstarMap = [];\n\t\n\t\t\t\twhile ( ones.length < num ) {\n\t\t\t\t\tones += 1;\n\t\t\t\t}\n\t\n\t\t\t\tmax = parseInt( ones, 2 );\n\t\n\t\t\t\tmapper = function ( digit ) {\n\t\t\t\t\treturn digit === '1';\n\t\t\t\t};\n\t\n\t\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\t\twhile ( binary.length < num ) {\n\t\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmap = [];\n\t\t\t\t\tl = binary.length;\n\t\t\t\t\tfor (j = 0; j < l; j++) {\n\t\t\t\t\t\tmap.push( mapper( binary[j] ) );\n\t\t\t\t\t}\n\t\t\t\t\tstarMap[i] = map;\n\t\t\t\t}\n\t\n\t\t\t\tstarMaps[ num ] = starMap;\n\t\t\t}\n\t\n\t\t\treturn starMaps[ num ];\n\t\t}\n\t\n\t\tvar wildcardCache = {};\n\t\n\t\tfunction fireEvent ( ractive, eventName, options ) {\n\t\t\tif ( options === void 0 ) options = {};\n\t\n\t\t\tif ( !eventName ) { return; }\n\t\n\t\t\tif ( !options.event ) {\n\t\t\t\toptions.event = {\n\t\t\t\t\tname: eventName,\n\t\t\t\t\t// until event not included as argument default\n\t\t\t\t\t_noArg: true\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\toptions.event.name = eventName;\n\t\t\t}\n\t\n\t\t\tvar eventNames = getWildcardNames( eventName );\n\t\n\t\t\treturn fireEventAs( ractive, eventNames, options.event, options.args, true );\n\t\t}\n\t\n\t\tfunction getWildcardNames ( eventName ) {\n\t\t\tif ( wildcardCache.hasOwnProperty( eventName ) ) {\n\t\t\t\treturn wildcardCache[ eventName ];\n\t\t\t} else {\n\t\t\t\treturn wildcardCache[ eventName ] = getPotentialWildcardMatches( eventName );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction fireEventAs  ( ractive, eventNames, event, args, initialFire ) {\n\t\n\t\t\tif ( initialFire === void 0 ) initialFire = false;\n\t\n\t\t\tvar subscribers, i, bubble = true;\n\t\n\t\t\tenqueue( ractive, event );\n\t\n\t\t\tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t\t\t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\t\n\t\t\t\tif ( subscribers ) {\n\t\t\t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tdequeue( ractive );\n\t\n\t\t\tif ( ractive.parent && bubble ) {\n\t\n\t\t\t\tif ( initialFire && ractive.component ) {\n\t\t\t\t\tvar fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];\n\t\t\t\t\teventNames = getWildcardNames( fullName );\n\t\n\t\t\t\t\tif( event && !event.component ) {\n\t\t\t\t\t\tevent.component = ractive;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfireEventAs( ractive.parent, eventNames, event, args );\n\t\t\t}\n\t\n\t\t\treturn bubble;\n\t\t}\n\t\n\t\tfunction notifySubscribers ( ractive, subscribers, event, args ) {\n\t\t\tvar originalEvent = null, stopEvent = false;\n\t\n\t\t\tif ( event && !event._noArg ) {\n\t\t\t\targs = [ event ].concat( args );\n\t\t\t}\n\t\n\t\t\t// subscribers can be modified inflight, e.g. \"once\" functionality\n\t\t\t// so we need to copy to make sure everyone gets called\n\t\t\tsubscribers = subscribers.slice();\n\t\n\t\t\tfor ( var i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t\t\t\tif ( !subscribers[ i ].off && subscribers[ i ].apply( ractive, args ) === false ) {\n\t\t\t\t\tstopEvent = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t\t\t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t\t\t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t\t\t}\n\t\n\t\t\treturn !stopEvent;\n\t\t}\n\t\n\t\tfunction Ractive$fire ( eventName ) {\n\t\t\tvar args = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t\t\treturn fireEvent( this, eventName, { args: args });\n\t\t}\n\t\n\t\tfunction badReference ( key ) {\n\t\t\tthrow new Error( (\"An index or key reference (\" + key + \") cannot have child properties\") );\n\t\t}\n\t\n\t\tfunction resolveAmbiguousReference ( fragment, ref ) {\n\t\t\tvar localViewmodel = fragment.findContext().root;\n\t\t\tvar keys = splitKeypathI( ref );\n\t\t\tvar key = keys[0];\n\t\n\t\t\tvar hasContextChain;\n\t\t\tvar crossedComponentBoundary;\n\t\t\tvar aliases;\n\t\n\t\t\twhile ( fragment ) {\n\t\t\t\t// repeated fragments\n\t\t\t\tif ( fragment.isIteration ) {\n\t\t\t\t\tif ( key === fragment.parent.keyRef ) {\n\t\t\t\t\t\tif ( keys.length > 1 ) badReference( key );\n\t\t\t\t\t\treturn fragment.context.getKeyModel( fragment.key );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( key === fragment.parent.indexRef ) {\n\t\t\t\t\t\tif ( keys.length > 1 ) badReference( key );\n\t\t\t\t\t\treturn fragment.context.getKeyModel( fragment.index );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// alias node or iteration\n\t\t\t\tif ( ( ( aliases = fragment.owner.aliases ) || ( aliases = fragment.aliases ) ) && aliases.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar model = aliases[ key ];\n\t\n\t\t\t\t\tif ( keys.length === 1 ) return model;\n\t\t\t\t\telse if ( typeof model.joinAll === 'function' ) {\n\t\t\t\t\t\treturn model.joinAll( keys.slice( 1 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( fragment.context ) {\n\t\t\t\t\t// TODO better encapsulate the component check\n\t\t\t\t\tif ( !fragment.isRoot || fragment.ractive.component ) hasContextChain = true;\n\t\n\t\t\t\t\tif ( fragment.context.has( key ) ) {\n\t\t\t\t\t\tif ( crossedComponentBoundary ) {\n\t\t\t\t\t\t\treturn localViewmodel.createLink( key, fragment.context.joinKey( keys.shift() ), key ).joinAll( keys );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn fragment.context.joinAll( keys );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n\t\t\t\t\t// ascend through component boundary\n\t\t\t\t\tfragment = fragment.componentParent;\n\t\t\t\t\tcrossedComponentBoundary = true;\n\t\t\t\t} else {\n\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !hasContextChain ) {\n\t\t\t\treturn localViewmodel.joinAll( keys );\n\t\t\t}\n\t\t}\n\t\n\t\tvar stack = [];\n\t\tvar captureGroup;\n\t\n\t\tfunction startCapturing () {\n\t\t\tstack.push( captureGroup = [] );\n\t\t}\n\t\n\t\tfunction stopCapturing () {\n\t\t\tvar dependencies = stack.pop();\n\t\t\tcaptureGroup = stack[ stack.length - 1 ];\n\t\t\treturn dependencies;\n\t\t}\n\t\n\t\tfunction capture ( model ) {\n\t\t\tif ( captureGroup ) {\n\t\t\t\tcaptureGroup.push( model );\n\t\t\t}\n\t\t}\n\t\n\t\tvar KeyModel = function KeyModel ( key, parent ) {\n\t\t\tthis.value = key;\n\t\t\tthis.isReadonly = this.isKey = true;\n\t\t\tthis.deps = [];\n\t\t\tthis.links = [];\n\t\t\tthis.parent = parent;\n\t\t};\n\t\n\t\tKeyModel.prototype.get = function get ( shouldCapture ) {\n\t\t\tif ( shouldCapture ) capture( this );\n\t\t\treturn unescapeKey( this.value );\n\t\t};\n\t\n\t\tKeyModel.prototype.getKeypath = function getKeypath () {\n\t\t\treturn unescapeKey( this.value );\n\t\t};\n\t\n\t\tKeyModel.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar i = this.deps.length;\n\t\t\twhile ( i-- ) this$1.deps[i].rebinding( next, previous, false );\n\t\n\t\t\ti = this.links.length;\n\t\t\twhile ( i-- ) this$1.links[i].rebinding( next, previous, false );\n\t\t};\n\t\n\t\tKeyModel.prototype.register = function register ( dependant ) {\n\t\t\tthis.deps.push( dependant );\n\t\t};\n\t\n\t\tKeyModel.prototype.registerLink = function registerLink ( link ) {\n\t\t\taddToArray( this.links, link );\n\t\t};\n\t\n\t\tKeyModel.prototype.unregister = function unregister ( dependant ) {\n\t\t\tremoveFromArray( this.deps, dependant );\n\t\t};\n\t\n\t\tKeyModel.prototype.unregisterLink = function unregisterLink ( link ) {\n\t\t\tremoveFromArray( this.links, link );\n\t\t};\n\t\n\t\tfunction bind$1               ( x ) { x.bind(); }\n\t\tfunction cancel             ( x ) { x.cancel(); }\n\t\tfunction handleChange       ( x ) { x.handleChange(); }\n\t\tfunction mark               ( x ) { x.mark(); }\n\t\tfunction marked             ( x ) { x.marked(); }\n\t\tfunction notifiedUpstream   ( x ) { x.notifiedUpstream(); }\n\t\tfunction render             ( x ) { x.render(); }\n\t\tfunction teardown           ( x ) { x.teardown(); }\n\t\tfunction unbind             ( x ) { x.unbind(); }\n\t\tfunction unrender           ( x ) { x.unrender(); }\n\t\tfunction unrenderAndDestroy ( x ) { x.unrender( true ); }\n\t\tfunction update             ( x ) { x.update(); }\n\t\tfunction toString$1           ( x ) { return x.toString(); }\n\t\tfunction toEscapedString    ( x ) { return x.toString( true ); }\n\t\n\t\tvar KeypathModel = function KeypathModel ( parent, ractive ) {\n\t\t\tthis.parent = parent;\n\t\t\tthis.ractive = ractive;\n\t\t\tthis.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();\n\t\t\tthis.deps = [];\n\t\t\tthis.children = {};\n\t\t\tthis.isReadonly = this.isKeypath = true;\n\t\t};\n\t\n\t\tKeypathModel.prototype.get = function get ( shouldCapture ) {\n\t\t\tif ( shouldCapture ) capture( this );\n\t\t\treturn this.value;\n\t\t};\n\t\n\t\tKeypathModel.prototype.getChild = function getChild ( ractive ) {\n\t\t\tif ( !( ractive._guid in this.children ) ) {\n\t\t\t\tvar model = new KeypathModel( this.parent, ractive );\n\t\t\t\tthis.children[ ractive._guid ] = model;\n\t\t\t\tmodel.owner = this;\n\t\t\t}\n\t\t\treturn this.children[ ractive._guid ];\n\t\t};\n\t\n\t\tKeypathModel.prototype.getKeypath = function getKeypath () {\n\t\t\treturn this.value;\n\t\t};\n\t\n\t\tKeypathModel.prototype.handleChange = function handleChange$1 () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar keys = Object.keys( this.children );\n\t\t\tvar i = keys.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tthis$1.children[ keys[i] ].handleChange();\n\t\t\t}\n\t\n\t\t\tthis.deps.forEach( handleChange );\n\t\t};\n\t\n\t\tKeypathModel.prototype.rebindChildren = function rebindChildren ( next ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar keys = Object.keys( this.children );\n\t\t\tvar i = keys.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar child = this$1.children[keys[i]];\n\t\t\t\tchild.value = next.getKeypath( child.ractive );\n\t\t\t\tchild.handleChange();\n\t\t\t}\n\t\t};\n\t\n\t\tKeypathModel.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar model = next ? next.getKeypathModel( this.ractive ) : undefined;\n\t\n\t\t\tvar keys = Object.keys( this.children );\n\t\t\tvar i = keys.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tthis$1.children[ keys[i] ].rebinding( next, previous, false );\n\t\t\t}\n\t\n\t\t\ti = this.deps.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tthis$1.deps[i].rebinding( model, this$1, false );\n\t\t\t}\n\t\t};\n\t\n\t\tKeypathModel.prototype.register = function register ( dep ) {\n\t\t\tthis.deps.push( dep );\n\t\t};\n\t\n\t\tKeypathModel.prototype.removeChild = function removeChild( model ) {\n\t\t\tif ( model.ractive ) delete this.children[ model.ractive._guid ];\n\t\t};\n\t\n\t\tKeypathModel.prototype.teardown = function teardown () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.owner ) this.owner.removeChild( this );\n\t\n\t\t\tvar keys = Object.keys( this.children );\n\t\t\tvar i = keys.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tthis$1.children[ keys[i] ].teardown();\n\t\t\t}\n\t\t};\n\t\n\t\tKeypathModel.prototype.unregister = function unregister ( dep ) {\n\t\t\tremoveFromArray( this.deps, dep );\n\t\t\tif ( !this.deps.length ) this.teardown();\n\t\t};\n\t\n\t\tvar hasProp = Object.prototype.hasOwnProperty;\n\t\n\t\tvar shuffleTasks = { early: [], mark: [] };\n\t\tvar registerQueue = { early: [], mark: [] };\n\t\n\t\tvar ModelBase = function ModelBase ( parent ) {\n\t\t\tthis.deps = [];\n\t\n\t\t\tthis.children = [];\n\t\t\tthis.childByKey = {};\n\t\t\tthis.links = [];\n\t\n\t\t\tthis.keyModels = {};\n\t\n\t\t\tthis.unresolved = [];\n\t\t\tthis.unresolvedByKey = {};\n\t\n\t\t\tthis.bindings = [];\n\t\t\tthis.patternObservers = [];\n\t\n\t\t\tif ( parent ) {\n\t\t\t\tthis.parent = parent;\n\t\t\t\tthis.root = parent.root;\n\t\t\t}\n\t\t};\n\t\n\t\tModelBase.prototype.addUnresolved = function addUnresolved ( key, resolver ) {\n\t\t\tif ( !this.unresolvedByKey[ key ] ) {\n\t\t\t\tthis.unresolved.push( key );\n\t\t\t\tthis.unresolvedByKey[ key ] = [];\n\t\t\t}\n\t\n\t\t\tthis.unresolvedByKey[ key ].push( resolver );\n\t\t};\n\t\n\t\tModelBase.prototype.addShuffleTask = function addShuffleTask ( task, stage ) { if ( stage === void 0 ) stage = 'early';\n\t\n\t\t\tshuffleTasks[stage].push( task ); };\n\t\tModelBase.prototype.addShuffleRegister = function addShuffleRegister ( item, stage ) { if ( stage === void 0 ) stage = 'early';\n\t\n\t\t\tregisterQueue[stage].push({ model: this, item: item }); };\n\t\n\t\tModelBase.prototype.clearUnresolveds = function clearUnresolveds ( specificKey ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar i = this.unresolved.length;\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar key = this$1.unresolved[i];\n\t\n\t\t\t\tif ( specificKey && key !== specificKey ) continue;\n\t\n\t\t\t\tvar resolvers = this$1.unresolvedByKey[ key ];\n\t\t\t\tvar hasKey = this$1.has( key );\n\t\n\t\t\t\tvar j = resolvers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\tif ( hasKey ) resolvers[j].attemptResolution();\n\t\t\t\t\tif ( resolvers[j].resolved ) resolvers.splice( j, 1 );\n\t\t\t\t}\n\t\n\t\t\t\tif ( !resolvers.length ) {\n\t\t\t\t\tthis$1.unresolved.splice( i, 1 );\n\t\t\t\t\tthis$1.unresolvedByKey[ key ] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tModelBase.prototype.findMatches = function findMatches ( keys ) {\n\t\t\tvar len = keys.length;\n\t\n\t\t\tvar existingMatches = [ this ];\n\t\t\tvar matches;\n\t\t\tvar i;\n\t\n\t\t\tvar loop = function (  ) {\n\t\t\t\tvar key = keys[i];\n\t\n\t\t\t\tif ( key === '*' ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\texistingMatches.forEach( function ( model ) {\n\t\t\t\t\t\tmatches.push.apply( matches, model.getValueChildren( model.get() ) );\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tmatches = existingMatches.map( function ( model ) { return model.joinKey( key ); } );\n\t\t\t\t}\n\t\n\t\t\t\texistingMatches = matches;\n\t\t\t};\n\t\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) loop(  );\n\t\n\t\t\treturn matches;\n\t\t};\n\t\n\t\tModelBase.prototype.getKeyModel = function getKeyModel ( key, skip ) {\n\t\t\tif ( key !== undefined && !skip ) return this.parent.getKeyModel( key, true );\n\t\n\t\t\tif ( !( key in this.keyModels ) ) this.keyModels[ key ] = new KeyModel( escapeKey( key ), this );\n\t\n\t\t\treturn this.keyModels[ key ];\n\t\t};\n\t\n\t\tModelBase.prototype.getKeypath = function getKeypath ( ractive ) {\n\t\t\tif ( ractive !== this.ractive && this._link ) return this._link.target.getKeypath( ractive );\n\t\n\t\t\tif ( !this.keypath ) {\n\t\t\t\tthis.keypath = this.parent.isRoot ? this.key : (\"\" + (this.parent.getKeypath( ractive )) + \".\" + (escapeKey( this.key )));\n\t\t\t}\n\t\n\t\t\treturn this.keypath;\n\t\t};\n\t\n\t\tModelBase.prototype.getValueChildren = function getValueChildren ( value ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar children;\n\t\t\tif ( isArray( value ) ) {\n\t\t\t\tchildren = [];\n\t\t\t\tif ( 'length' in this && this.length !== value.length ) {\n\t\t\t\t\tchildren.push( this.joinKey( 'length' ) );\n\t\t\t\t}\n\t\t\t\tvalue.forEach( function ( m, i ) {\n\t\t\t\t\tchildren.push( this$1.joinKey( i ) );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\telse if ( isObject( value ) || typeof value === 'function' ) {\n\t\t\t\tchildren = Object.keys( value ).map( function ( key ) { return this$1.joinKey( key ); } );\n\t\t\t}\n\t\n\t\t\telse if ( value != null ) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\n\t\t\treturn children;\n\t\t};\n\t\n\t\tModelBase.prototype.getVirtual = function getVirtual ( shouldCapture ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar value = this.get( shouldCapture, { virtual: false } );\n\t\t\tif ( isObject( value ) ) {\n\t\t\t\tvar result = isArray( value ) ? [] : {};\n\t\n\t\t\t\tvar keys = Object.keys( value );\n\t\t\t\tvar i = keys.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar child = this$1.childByKey[ keys[i] ];\n\t\t\t\t\tif ( !child ) result[ keys[i] ] = value[ keys[i] ];\n\t\t\t\t\telse if ( child._link ) result[ keys[i] ] = child._link.getVirtual();\n\t\t\t\t\telse result[ keys[i] ] = child.getVirtual();\n\t\t\t\t}\n\t\n\t\t\t\ti = this.children.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar child$1 = this$1.children[i];\n\t\t\t\t\tif ( !( child$1.key in result ) && child$1._link ) {\n\t\t\t\t\t\tresult[ child$1.key ] = child$1._link.getVirtual();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\t\t} else return value;\n\t\t};\n\t\n\t\tModelBase.prototype.has = function has ( key ) {\n\t\t\tif ( this._link ) return this._link.has( key );\n\t\n\t\t\tvar value = this.get();\n\t\t\tif ( !value ) return false;\n\t\n\t\t\tkey = unescapeKey( key );\n\t\t\tif ( hasProp.call( value, key ) ) return true;\n\t\n\t\t\t// We climb up the constructor chain to find if one of them contains the key\n\t\t\tvar constructor = value.constructor;\n\t\t\twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n\t\t\t\tif ( hasProp.call( constructor.prototype, key ) ) return true;\n\t\t\t\tconstructor = constructor.constructor;\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t};\n\t\n\t\tModelBase.prototype.joinAll = function joinAll ( keys, opts ) {\n\t\t\tvar model = this;\n\t\t\tfor ( var i = 0; i < keys.length; i += 1 ) {\n\t\t\t\tif ( opts && opts.lastLink === false && i + 1 === keys.length && model.childByKey[keys[i]] && model.childByKey[keys[i]]._link ) return model.childByKey[keys[i]];\n\t\t\t\tmodel = model.joinKey( keys[i], opts );\n\t\t\t}\n\t\n\t\t\treturn model;\n\t\t};\n\t\n\t\tModelBase.prototype.notifyUpstream = function notifyUpstream () {\n\t\t\tvar parent = this.parent, path = [ this.key ];\n\t\t\twhile ( parent ) {\n\t\t\t\tif ( parent.patternObservers.length ) parent.patternObservers.forEach( function ( o ) { return o.notify( path.slice() ); } );\n\t\t\t\tpath.unshift( parent.key );\n\t\t\t\tparent.links.forEach( notifiedUpstream );\n\t\t\t\tparent.deps.forEach( handleChange );\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t};\n\t\n\t\tModelBase.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\t// tell the deps to move to the new target\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar i = this.deps.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( this$1.deps[i].rebinding ) this$1.deps[i].rebinding( next, previous, safe );\n\t\t\t}\n\t\n\t\t\ti = this.links.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar link = this$1.links[i];\n\t\t\t\t// only relink the root of the link tree\n\t\t\t\tif ( link.owner._link ) link.relinking( next, true, safe );\n\t\t\t}\n\t\n\t\t\ti = this.children.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar child = this$1.children[i];\n\t\t\t\tchild.rebinding( next ? next.joinKey( child.key ) : undefined, child, safe );\n\t\t\t}\n\t\n\t\t\ti = this.unresolved.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar unresolved = this$1.unresolvedByKey[ this$1.unresolved[i] ];\n\t\t\t\tvar c = unresolved.length;\n\t\t\t\twhile ( c-- ) {\n\t\t\t\t\tunresolved[c].rebinding( next, previous );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( this.keypathModel ) this.keypathModel.rebinding( next, previous, false );\n\t\n\t\t\ti = this.bindings.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tthis$1.bindings[i].rebinding( next, previous, safe );\n\t\t\t}\n\t\t};\n\t\n\t\tModelBase.prototype.register = function register ( dep ) {\n\t\t\tthis.deps.push( dep );\n\t\t};\n\t\n\t\tModelBase.prototype.registerChange = function registerChange ( key, value ) {\n\t\t\tif ( !this.isRoot ) {\n\t\t\t\tthis.root.registerChange( key, value );\n\t\t\t} else {\n\t\t\t\tthis.changes[ key ] = value;\n\t\t\t\trunloop.addInstance( this.root.ractive );\n\t\t\t}\n\t\t};\n\t\n\t\tModelBase.prototype.registerLink = function registerLink ( link ) {\n\t\t\taddToArray( this.links, link );\n\t\t};\n\t\n\t\tModelBase.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {\n\t\t\tthis.patternObservers.push( observer );\n\t\t\tthis.register( observer );\n\t\t};\n\t\n\t\tModelBase.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {\n\t\t\tthis.bindings.push( binding );\n\t\t};\n\t\n\t\tModelBase.prototype.removeUnresolved = function removeUnresolved ( key, resolver ) {\n\t\t\tvar resolvers = this.unresolvedByKey[ key ];\n\t\n\t\t\tif ( resolvers ) {\n\t\t\t\tremoveFromArray( resolvers, resolver );\n\t\t\t}\n\t\t};\n\t\n\t\tModelBase.prototype.shuffled = function shuffled () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar i = this.children.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tthis$1.children[i].shuffled();\n\t\t\t}\n\t\t\tif ( this.wrapper ) {\n\t\t\t\tthis.wrapper.teardown();\n\t\t\t\tthis.wrapper = null;\n\t\t\t\tthis.rewrap = true;\n\t\t\t}\n\t\t};\n\t\n\t\tModelBase.prototype.unregister = function unregister ( dependant ) {\n\t\t\tremoveFromArray( this.deps, dependant );\n\t\t};\n\t\n\t\tModelBase.prototype.unregisterLink = function unregisterLink ( link ) {\n\t\t\tremoveFromArray( this.links, link );\n\t\t};\n\t\n\t\tModelBase.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {\n\t\t\tremoveFromArray( this.patternObservers, observer );\n\t\t\tthis.unregister( observer );\n\t\t};\n\t\n\t\tModelBase.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {\n\t\t\tremoveFromArray( this.bindings, binding );\n\t\t};\n\t\n\t\tModelBase.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar i = this.bindings.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar value = this$1.bindings[i].getValue();\n\t\t\t\tif ( value !== this$1.value ) this$1.set( value );\n\t\t\t}\n\t\n\t\t\t// check for one-way bindings if there are no two-ways\n\t\t\tif ( !this.bindings.length ) {\n\t\t\t\tvar oneway = findBoundValue( this.deps );\n\t\t\t\tif ( oneway && oneway.value !== this.value ) this.set( oneway.value );\n\t\t\t}\n\t\n\t\t\tif ( cascade ) {\n\t\t\t\tthis.children.forEach( updateFromBindings );\n\t\t\t\tthis.links.forEach( updateFromBindings );\n\t\t\t\tif ( this._link ) this._link.updateFromBindings( cascade );\n\t\t\t}\n\t\t};\n\t\n\t\tfunction updateFromBindings ( model ) {\n\t\t\tmodel.updateFromBindings( true );\n\t\t}\n\t\n\t\tfunction findBoundValue( list ) {\n\t\t\tvar i = list.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( list[i].bound ) {\n\t\t\t\t\tvar owner = list[i].owner;\n\t\t\t\t\tif ( owner ) {\n\t\t\t\t\t\tvar value = owner.name === 'checked' ?\n\t\t\t\t\t\t\towner.node.checked :\n\t\t\t\t\t\t\towner.node.value;\n\t\t\t\t\t\treturn { value: value };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction fireShuffleTasks ( stage ) {\n\t\t\tif ( !stage ) {\n\t\t\t\tfireShuffleTasks( 'early' );\n\t\t\t\tfireShuffleTasks( 'mark' );\n\t\t\t} else {\n\t\t\t\tvar tasks = shuffleTasks[stage];\n\t\t\t\tshuffleTasks[stage] = [];\n\t\t\t\tvar i = tasks.length;\n\t\t\t\twhile ( i-- ) tasks[i]();\n\t\n\t\t\t\tvar register = registerQueue[stage];\n\t\t\t\tregisterQueue[stage] = [];\n\t\t\t\ti = register.length;\n\t\t\t\twhile ( i-- ) register[i].model.register( register[i].item );\n\t\t\t}\n\t\t}\n\t\n\t\tKeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n\t\tKeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n\t\tKeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n\t\tKeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n\t\n\t\t// this is the dry method of checking to see if a rebind applies to\n\t\t// a particular keypath because in some cases, a dep may be bound\n\t\t// directly to a particular keypath e.g. foo.bars.0.baz and need\n\t\t// to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\n\t\tfunction rebindMatch ( template, next, previous ) {\n\t\t\tvar keypath = template.r || template;\n\t\n\t\t\t// no valid keypath, go with next\n\t\t\tif ( !keypath || typeof keypath !== 'string' ) return next;\n\t\n\t\t\t// completely contextual ref, go with next\n\t\t\tif ( keypath === '.' || keypath[0] === '@' || (next || previous).isKey || (next || previous).isKeypath ) return next;\n\t\n\t\t\tvar parts = keypath.split( '/' );\n\t\t\tvar keys = splitKeypathI( parts[ parts.length - 1 ] );\n\t\n\t\t\t// check the keypath against the model keypath to see if it matches\n\t\t\tvar model = next || previous;\n\t\t\tvar i = keys.length;\n\t\t\tvar match = true, shuffling = false;\n\t\n\t\t\twhile ( model && i-- ) {\n\t\t\t\tif ( model.shuffling ) shuffling = true;\n\t\t\t\t// non-strict comparison to account for indices in keypaths\n\t\t\t\tif ( keys[i] != model.key ) match = false;\n\t\t\t\tmodel = model.parent;\n\t\t\t}\n\t\n\t\t\t// next is undefined, but keypath is shuffling and previous matches\n\t\t\tif ( !next && match && shuffling ) return previous;\n\t\t\t// next is defined, but doesn't match the keypath\n\t\t\telse if ( next && !match && shuffling ) return previous;\n\t\t\telse return next;\n\t\t}\n\t\n\t\tvar LinkModel = (function (ModelBase) {\n\t\t\tfunction LinkModel ( parent, owner, target, key ) {\n\t\t\t\tModelBase.call( this, parent );\n\t\n\t\t\t\tthis.owner = owner;\n\t\t\t\tthis.target = target;\n\t\t\t\tthis.key = key === undefined ? owner.key : key;\n\t\t\t\tif ( owner.isLink ) this.sourcePath = \"\" + (owner.sourcePath) + \".\" + (this.key);\n\t\n\t\t\t\ttarget.registerLink( this );\n\t\n\t\t\t\tthis.isReadonly = parent.isReadonly;\n\t\n\t\t\t\tthis.isLink = true;\n\t\t\t}\n\t\n\t\t\tLinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n\t\t\tLinkModel.prototype.constructor = LinkModel;\n\t\n\t\t\tLinkModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n\t\t\t\treturn this.target.animate( from, to, options, interpolator );\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.applyValue = function applyValue ( value ) {\n\t\t\t\tthis.target.applyValue( value );\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.get = function get ( shouldCapture, opts ) {\n\t\t\t\tif ( shouldCapture ) {\n\t\t\t\t\tcapture( this );\n\t\n\t\t\t\t\t// may need to tell the target to unwrap\n\t\t\t\t\topts = opts || {};\n\t\t\t\t\topts.unwrap = true;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.target.get( false, opts );\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.getKeypath = function getKeypath ( ractive ) {\n\t\t\t\tif ( ractive && ractive !== this.root.ractive ) return this.target.getKeypath( ractive );\n\t\n\t\t\t\treturn ModelBase.prototype.getKeypath.call( this, ractive );\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n\t\t\t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n\t\t\t\tif ( ractive && ractive !== this.root.ractive ) return this.keypathModel.getChild( ractive );\n\t\t\t\treturn this.keypathModel;\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.handleChange = function handleChange$1 () {\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\tthis.links.forEach( handleChange );\n\t\t\t\tthis.notifyUpstream();\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.joinKey = function joinKey ( key ) {\n\t\t\t\t// TODO: handle nested links\n\t\t\t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar child = new LinkModel( this, this, this.target.joinKey( key ), key );\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.childByKey[ key ];\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.mark = function mark () {\n\t\t\t\tthis.target.mark();\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.marked = function marked$1 () {\n\t\t\t\tthis.links.forEach( marked );\n\t\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\tthis.clearUnresolveds();\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.notifiedUpstream = function notifiedUpstream$1 () {\n\t\t\t\tthis.links.forEach( notifiedUpstream );\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.relinked = function relinked () {\n\t\t\t\tthis.target.registerLink( this );\n\t\t\t\tthis.children.forEach( function ( c ) { return c.relinked(); } );\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.relinking = function relinking ( target, root, safe ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( root && this.sourcePath ) target = rebindMatch( this.sourcePath, target, this.target );\n\t\t\t\tif ( !target || this.target === target ) return;\n\t\n\t\t\t\tthis.target.unregisterLink( this );\n\t\t\t\tif ( this.keypathModel ) this.keypathModel.rebindChildren( target );\n\t\n\t\t\t\tthis.target = target;\n\t\t\t\tthis.children.forEach( function ( c ) {\n\t\t\t\t\tc.relinking( target.joinKey( c.key ), false, safe );\n\t\t\t\t});\n\t\n\t\t\t\tif ( root ) this.addShuffleTask( function () {\n\t\t\t\t\tthis$1.relinked();\n\t\t\t\t\tif ( !safe ) this$1.notifyUpstream();\n\t\t\t\t});\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.set = function set ( value ) {\n\t\t\t\tthis.target.set( value );\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\t\t// watch for extra shuffles caused by a shuffle in a downstream link\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.shuffling ) return;\n\t\n\t\t\t\t// let the real model handle firing off shuffles\n\t\t\t\tif ( !this.target.shuffling ) {\n\t\t\t\t\tthis.target.shuffle( newIndices );\n\t\t\t\t} else {\n\t\t\t\t\tthis.shuffling = true;\n\t\n\t\t\t\t\tvar i = newIndices.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvar idx = newIndices[ i ];\n\t\t\t\t\t\t// nothing is actually changing, so move in the index and roll on\n\t\t\t\t\t\tif ( i === idx ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// rebind the children on i to idx\n\t\t\t\t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\t\n\t\t\t\t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n\t\t\t\t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n\t\t\t\t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar upstream = this.source().length !== this.source().value.length;\n\t\n\t\t\t\t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n\t\n\t\t\t\t\ti = this.deps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.marked();\n\t\n\t\t\t\t\tif ( upstream ) this.notifyUpstream();\n\t\n\t\t\t\t\tthis.shuffling = false;\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.source = function source () {\n\t\t\t\tif ( this.target.source ) return this.target.source();\n\t\t\t\telse return this.target;\n\t\t\t};\n\t\n\t\t\tLinkModel.prototype.teardown = function teardown$1 () {\n\t\t\t\tif ( this._link ) this._link.teardown();\n\t\t\t\tthis.children.forEach( teardown );\n\t\t\t};\n\t\n\t\t\treturn LinkModel;\n\t\t}(ModelBase));\n\t\n\t\tModelBase.prototype.link = function link ( model, keypath ) {\n\t\t\tvar lnk = this._link || new LinkModel( this.parent, this, model, this.key );\n\t\t\tlnk.sourcePath = keypath;\n\t\t\tif ( this._link ) this._link.relinking( model, true, false );\n\t\t\tthis.rebinding( lnk, this, false );\n\t\t\tfireShuffleTasks();\n\t\n\t\t\tvar unresolved = !this._link;\n\t\t\tthis._link = lnk;\n\t\t\tif ( unresolved ) this.parent.clearUnresolveds();\n\t\t\tlnk.marked();\n\t\t\treturn lnk;\n\t\t};\n\t\n\t\tModelBase.prototype.unlink = function unlink () {\n\t\t\tif ( this._link ) {\n\t\t\t\tvar ln = this._link;\n\t\t\t\tthis._link = undefined;\n\t\t\t\tln.rebinding( this, this._link );\n\t\t\t\tfireShuffleTasks();\n\t\t\t\tln.teardown();\n\t\t\t}\n\t\t};\n\t\n\t\tvar requestAnimationFrame;\n\t\n\t\t// If window doesn't exist, we don't need requestAnimationFrame\n\t\tif ( !win ) {\n\t\t\trequestAnimationFrame = null;\n\t\t} else {\n\t\t\t// https://gist.github.com/paulirish/1579671\n\t\t\t(function(vendors, lastTime, win) {\n\t\n\t\t\t\tvar x, setTimeout;\n\t\n\t\t\t\tif ( win.requestAnimationFrame ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tfor ( x = 0; x < vendors.length && !win.requestAnimationFrame; ++x ) {\n\t\t\t\t\twin.requestAnimationFrame = win[vendors[x]+'RequestAnimationFrame'];\n\t\t\t\t}\n\t\n\t\t\t\tif ( !win.requestAnimationFrame ) {\n\t\t\t\t\tsetTimeout = win.setTimeout;\n\t\n\t\t\t\t\twin.requestAnimationFrame = function(callback) {\n\t\t\t\t\t\tvar currTime, timeToCall, id;\n\t\n\t\t\t\t\t\tcurrTime = Date.now();\n\t\t\t\t\t\ttimeToCall = Math.max( 0, 16 - (currTime - lastTime ) );\n\t\t\t\t\t\tid = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );\n\t\n\t\t\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\t\t\treturn id;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t}( vendors, 0, win ));\n\t\n\t\t\trequestAnimationFrame = win.requestAnimationFrame;\n\t\t}\n\t\n\t\tvar rAF = requestAnimationFrame;\n\t\n\t\tvar getTime = ( win && win.performance && typeof win.performance.now === 'function' ) ?\n\t\t\tfunction () { return win.performance.now(); } :\n\t\t\tfunction () { return Date.now(); };\n\t\n\t\t// TODO what happens if a transition is aborted?\n\t\n\t\tvar tickers = [];\n\t\tvar running = false;\n\t\n\t\tfunction tick () {\n\t\t\trunloop.start();\n\t\n\t\t\tvar now = getTime();\n\t\n\t\t\tvar i;\n\t\t\tvar ticker;\n\t\n\t\t\tfor ( i = 0; i < tickers.length; i += 1 ) {\n\t\t\t\tticker = tickers[i];\n\t\n\t\t\t\tif ( !ticker.tick( now ) ) {\n\t\t\t\t\t// ticker is complete, remove it from the stack, and decrement i so we don't miss one\n\t\t\t\t\ttickers.splice( i--, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trunloop.end();\n\t\n\t\t\tif ( tickers.length ) {\n\t\t\t\trAF( tick );\n\t\t\t} else {\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t\n\t\tvar Ticker = function Ticker ( options ) {\n\t\t\tthis.duration = options.duration;\n\t\t\tthis.step = options.step;\n\t\t\tthis.complete = options.complete;\n\t\t\tthis.easing = options.easing;\n\t\n\t\t\tthis.start = getTime();\n\t\t\tthis.end = this.start + this.duration;\n\t\n\t\t\tthis.running = true;\n\t\n\t\t\ttickers.push( this );\n\t\t\tif ( !running ) rAF( tick );\n\t\t};\n\t\n\t\tTicker.prototype.tick = function tick$1 ( now ) {\n\t\t\tif ( !this.running ) return false;\n\t\n\t\t\tif ( now > this.end ) {\n\t\t\t\tif ( this.step ) this.step( 1 );\n\t\t\t\tif ( this.complete ) this.complete( 1 );\n\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tvar elapsed = now - this.start;\n\t\t\tvar eased = this.easing( elapsed / this.duration );\n\t\n\t\t\tif ( this.step ) this.step( eased );\n\t\n\t\t\treturn true;\n\t\t};\n\t\n\t\tTicker.prototype.stop = function stop () {\n\t\t\tif ( this.abort ) this.abort();\n\t\t\tthis.running = false;\n\t\t};\n\t\n\t\tvar prefixers = {};\n\t\n\t\t// TODO this is legacy. sooner we can replace the old adaptor API the better\n\t\tfunction prefixKeypath ( obj, prefix ) {\n\t\t\tvar prefixed = {}, key;\n\t\n\t\t\tif ( !prefix ) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\n\t\t\tprefix += '.';\n\t\n\t\t\tfor ( key in obj ) {\n\t\t\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn prefixed;\n\t\t}\n\t\n\t\tfunction getPrefixer ( rootKeypath ) {\n\t\t\tvar rootDot;\n\t\n\t\t\tif ( !prefixers[ rootKeypath ] ) {\n\t\t\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\t\n\t\t\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\t\t\tvar obj;\n\t\n\t\t\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\t\t\tobj = {};\n\t\t\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn prefixers[ rootKeypath ];\n\t\t}\n\t\n\t\tvar Model = (function (ModelBase) {\n\t\t\tfunction Model ( parent, key ) {\n\t\t\t\tModelBase.call( this, parent );\n\t\n\t\t\t\tthis.ticker = null;\n\t\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tthis.key = unescapeKey( key );\n\t\t\t\t\tthis.isReadonly = parent.isReadonly;\n\t\n\t\t\t\t\tif ( parent.value ) {\n\t\t\t\t\t\tthis.value = parent.value[ this.key ];\n\t\t\t\t\t\tif ( isArray( this.value ) ) this.length = this.value.length;\n\t\t\t\t\t\tthis.adapt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n\t\t\tModel.prototype.constructor = Model;\n\t\n\t\t\tModel.prototype.adapt = function adapt () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar adaptors = this.root.adaptors;\n\t\t\t\tvar len = adaptors.length;\n\t\n\t\t\t\tthis.rewrap = false;\n\t\n\t\t\t\t// Exit early if no adaptors\n\t\t\t\tif ( len === 0 ) return;\n\t\n\t\t\t\tvar value = this.wrapper ? ( 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue ) : this.value;\n\t\n\t\t\t\t// TODO remove this legacy nonsense\n\t\t\t\tvar ractive = this.root.ractive;\n\t\t\t\tvar keypath = this.getKeypath();\n\t\n\t\t\t\t// tear previous adaptor down if present\n\t\t\t\tif ( this.wrapper ) {\n\t\t\t\t\tvar shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset( value ) === false;\n\t\n\t\t\t\t\tif ( shouldTeardown ) {\n\t\t\t\t\t\tthis.wrapper.teardown();\n\t\t\t\t\t\tthis.wrapper = null;\n\t\n\t\t\t\t\t\t// don't branch for undefined values\n\t\t\t\t\t\tif ( this.value !== undefined ) {\n\t\t\t\t\t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n\t\t\t\t\t\t\tif ( parentValue[ this.key ] !== value ) parentValue[ this.key ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.newWrapperValue;\n\t\t\t\t\t\tthis.wrapperValue = value;\n\t\t\t\t\t\tthis.value = this.wrapper.get();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar i;\n\t\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvar adaptor = adaptors[i];\n\t\t\t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\t\tthis$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\t\t\t\tthis$1.wrapperValue = value;\n\t\t\t\t\t\tthis$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor\n\t\n\t\t\t\t\t\tthis$1.value = this$1.wrapper.get();\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.ticker ) this.ticker.stop();\n\t\n\t\t\t\tvar fulfilPromise;\n\t\t\t\tvar promise = new Promise$1( function ( fulfil ) { return fulfilPromise = fulfil; } );\n\t\n\t\t\t\tthis.ticker = new Ticker({\n\t\t\t\t\tduration: options.duration,\n\t\t\t\t\teasing: options.easing,\n\t\t\t\t\tstep: function ( t ) {\n\t\t\t\t\t\tvar value = interpolator( t );\n\t\t\t\t\t\tthis$1.applyValue( value );\n\t\t\t\t\t\tif ( options.step ) options.step( t, value );\n\t\t\t\t\t},\n\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\tthis$1.applyValue( to );\n\t\t\t\t\t\tif ( options.complete ) options.complete( to );\n\t\n\t\t\t\t\t\tthis$1.ticker = null;\n\t\t\t\t\t\tfulfilPromise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tpromise.stop = this.ticker.stop;\n\t\t\t\treturn promise;\n\t\t\t};\n\t\n\t\t\tModel.prototype.applyValue = function applyValue ( value ) {\n\t\t\t\tif ( isEqual( value, this.value ) ) return;\n\t\n\t\t\t\t// TODO deprecate this nonsense\n\t\t\t\tthis.registerChange( this.getKeypath(), value );\n\t\n\t\t\t\tif ( this.parent.wrapper && this.parent.wrapper.set ) {\n\t\t\t\t\tthis.parent.wrapper.set( this.key, value );\n\t\t\t\t\tthis.parent.value = this.parent.wrapper.get();\n\t\n\t\t\t\t\tthis.value = this.parent.value[ this.key ];\n\t\t\t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t} else if ( this.wrapper ) {\n\t\t\t\t\tthis.newWrapperValue = value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t} else {\n\t\t\t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n\t\t\t\t\tparentValue[ this.key ] = value;\n\t\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t}\n\t\n\t\t\t\tthis.parent.clearUnresolveds();\n\t\t\t\tthis.clearUnresolveds();\n\t\n\t\t\t\t// keep track of array stuff\n\t\t\t\tif ( isArray( value ) ) {\n\t\t\t\t\tthis.length = value.length;\n\t\t\t\t\tthis.isArray = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.isArray = false;\n\t\t\t\t}\n\t\n\t\t\t\t// notify dependants\n\t\t\t\tthis.links.forEach( handleChange );\n\t\t\t\tthis.children.forEach( mark );\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\n\t\t\t\tthis.notifyUpstream();\n\t\n\t\t\t\tif ( this.parent.isArray ) {\n\t\t\t\t\tif ( this.key === 'length' ) this.parent.length = value;\n\t\t\t\t\telse this.parent.joinKey( 'length' ).mark();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tModel.prototype.createBranch = function createBranch ( key ) {\n\t\t\t\tvar branch = isNumeric( key ) ? [] : {};\n\t\t\t\tthis.set( branch );\n\t\n\t\t\t\treturn branch;\n\t\t\t};\n\t\n\t\t\tModel.prototype.get = function get ( shouldCapture, opts ) {\n\t\t\t\tif ( this._link ) return this._link.get( shouldCapture, opts );\n\t\t\t\tif ( shouldCapture ) capture( this );\n\t\t\t\t// if capturing, this value needs to be unwrapped because it's for external use\n\t\t\t\tif ( opts && opts.virtual ) return this.getVirtual( false );\n\t\t\t\treturn ( shouldCapture || ( opts && opts.unwrap ) ) && this.wrapper ? this.wrapperValue : this.value;\n\t\t\t};\n\t\n\t\t\tModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n\t\t\t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n\t\t\t\treturn this.keypathModel;\n\t\t\t};\n\t\n\t\t\tModel.prototype.joinKey = function joinKey ( key, opts ) {\n\t\t\t\tif ( this._link ) {\n\t\t\t\t\tif ( opts && !opts.lastLink === false && ( key === undefined || key === '' ) ) return this;\n\t\t\t\t\treturn this._link.joinKey( key );\n\t\t\t\t}\n\t\n\t\t\t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\n\t\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar child = new Model( this, key );\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.childByKey[ key ]._link ) return this.childByKey[ key ]._link;\n\t\t\t\treturn this.childByKey[ key ];\n\t\t\t};\n\t\n\t\t\tModel.prototype.mark = function mark$1 () {\n\t\t\t\tif ( this._link ) return this._link.mark();\n\t\n\t\t\t\tvar value = this.retrieve();\n\t\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\tvar old = this.value;\n\t\t\t\t\tthis.value = value;\n\t\n\t\t\t\t\t// make sure the wrapper stays in sync\n\t\t\t\t\tif ( old !== value || this.rewrap ) {\n\t\t\t\t\t\tif ( this.wrapper ) this.newWrapperValue = value;\n\t\t\t\t\t\tthis.adapt();\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// keep track of array stuff\n\t\t\t\t\tif ( isArray( value ) ) {\n\t\t\t\t\t\tthis.length = value.length;\n\t\t\t\t\t\tthis.isArray = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.isArray = false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.children.forEach( mark );\n\t\t\t\t\tthis.links.forEach( marked );\n\t\n\t\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\t\tthis.clearUnresolveds();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tModel.prototype.merge = function merge ( array, comparator ) {\n\t\t\t\tvar oldArray = this.value, newArray = array;\n\t\t\t\tif ( oldArray === newArray ) oldArray = recreateArray( this );\n\t\t\t\tif ( comparator ) {\n\t\t\t\t\toldArray = oldArray.map( comparator );\n\t\t\t\t\tnewArray = newArray.map( comparator );\n\t\t\t\t}\n\t\n\t\t\t\tvar oldLength = oldArray.length;\n\t\n\t\t\t\tvar usedIndices = {};\n\t\t\t\tvar firstUnusedIndex = 0;\n\t\n\t\t\t\tvar newIndices = oldArray.map( function ( item ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\tvar start = firstUnusedIndex;\n\t\n\t\t\t\t\tdo {\n\t\t\t\t\t\tindex = newArray.indexOf( item, start );\n\t\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstart = index + 1;\n\t\t\t\t\t} while ( ( usedIndices[ index ] === true ) && start < oldLength );\n\t\n\t\t\t\t\t// keep track of the first unused index, so we don't search\n\t\t\t\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\t\t\t\tif ( index === firstUnusedIndex ) {\n\t\t\t\t\t\tfirstUnusedIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\t// allow next instance of next \"equal\" to be found item\n\t\t\t\t\tusedIndices[ index ] = true;\n\t\t\t\t\treturn index;\n\t\t\t\t});\n\t\n\t\t\t\tthis.parent.value[ this.key ] = array;\n\t\t\t\tthis.shuffle( newIndices );\n\t\t\t};\n\t\n\t\t\tModel.prototype.retrieve = function retrieve () {\n\t\t\t\treturn this.parent.value ? this.parent.value[ this.key ] : undefined;\n\t\t\t};\n\t\n\t\t\tModel.prototype.set = function set ( value ) {\n\t\t\t\tif ( this.ticker ) this.ticker.stop();\n\t\t\t\tthis.applyValue( value );\n\t\t\t};\n\t\n\t\t\tModel.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.shuffling = true;\n\t\t\t\tvar i = newIndices.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar idx = newIndices[ i ];\n\t\t\t\t\t// nothing is actually changing, so move in the index and roll on\n\t\t\t\t\tif ( i === idx ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// rebind the children on i to idx\n\t\t\t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\t\n\t\t\t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n\t\t\t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n\t\t\t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar upstream = this.length !== this.value.length;\n\t\n\t\t\t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n\t\t\t\tfireShuffleTasks( 'early' );\n\t\n\t\t\t\ti = this.deps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n\t\t\t\t}\n\t\n\t\t\t\tthis.mark();\n\t\t\t\tfireShuffleTasks( 'mark' );\n\t\n\t\t\t\tif ( upstream ) this.notifyUpstream();\n\t\t\t\tthis.shuffling = false;\n\t\t\t};\n\t\n\t\t\tModel.prototype.teardown = function teardown$1 () {\n\t\t\t\tif ( this._link ) this._link.teardown();\n\t\t\t\tthis.children.forEach( teardown );\n\t\t\t\tif ( this.wrapper ) this.wrapper.teardown();\n\t\t\t\tif ( this.keypathModel ) this.keypathModel.teardown();\n\t\t\t};\n\t\n\t\t\treturn Model;\n\t\t}(ModelBase));\n\t\n\t\tfunction recreateArray( model ) {\n\t\t\tvar array = [];\n\t\n\t\t\tfor ( var i = 0; i < model.length; i++ ) {\n\t\t\t\tarray[ i ] = (model.childByKey[i] || {}).value;\n\t\t\t}\n\t\n\t\t\treturn array;\n\t\t}\n\t\n\t\tvar GlobalModel = (function (Model) {\n\t\t\tfunction GlobalModel ( ) {\n\t\t\t\tModel.call( this, null, '@global' );\n\t\t\t\tthis.value = typeof global !== 'undefined' ? global : window;\n\t\t\t\tthis.isRoot = true;\n\t\t\t\tthis.root = this;\n\t\t\t\tthis.adaptors = [];\n\t\t\t}\n\t\n\t\t\tGlobalModel.prototype = Object.create( Model && Model.prototype );\n\t\t\tGlobalModel.prototype.constructor = GlobalModel;\n\t\n\t\t\tGlobalModel.prototype.getKeypath = function getKeypath() {\n\t\t\t\treturn '@global';\n\t\t\t};\n\t\n\t\t\t// global model doesn't contribute changes events because it has no instance\n\t\t\tGlobalModel.prototype.registerChange = function registerChange () {};\n\t\n\t\t\treturn GlobalModel;\n\t\t}(Model));\n\t\n\t\tvar GlobalModel$1 = new GlobalModel();\n\t\n\t\tvar keypathExpr = /^@[^\\(]+\\(([^\\)]+)\\)/;\n\t\n\t\tfunction resolveReference ( fragment, ref ) {\n\t\t\tvar context = fragment.findContext();\n\t\n\t\t\t// special references\n\t\t\t// TODO does `this` become `.` at parse time?\n\t\t\tif ( ref === '.' || ref === 'this' ) return context;\n\t\t\tif ( ref.indexOf( '@keypath' ) === 0 ) {\n\t\t\t\tvar match = keypathExpr.exec( ref );\n\t\t\t\tif ( match && match[1] ) {\n\t\t\t\t\tvar model = resolveReference( fragment, match[1] );\n\t\t\t\t\tif ( model ) return model.getKeypathModel();\n\t\t\t\t}\n\t\t\t\treturn context.getKeypathModel();\n\t\t\t}\n\t\t\tif ( ref.indexOf( '@rootpath' ) === 0 ) {\n\t\t\t\t// check to see if this is an empty component root\n\t\t\t\twhile ( context.isRoot && context.ractive.component ) {\n\t\t\t\t\tcontext = context.ractive.component.parentFragment.findContext();\n\t\t\t\t}\n\t\n\t\t\t\tvar match$1 = keypathExpr.exec( ref );\n\t\t\t\tif ( match$1 && match$1[1] ) {\n\t\t\t\t\tvar model$1 = resolveReference( fragment, match$1[1] );\n\t\t\t\t\tif ( model$1 ) return model$1.getKeypathModel( fragment.ractive.root );\n\t\t\t\t}\n\t\t\t\treturn context.getKeypathModel( fragment.ractive.root );\n\t\t\t}\n\t\t\tif ( ref === '@index' || ref === '@key' ) {\n\t\t\t\tvar repeater = fragment.findRepeatingFragment();\n\t\t\t\t// make sure the found fragment is actually an iteration\n\t\t\t\tif ( !repeater.isIteration ) return;\n\t\t\t\treturn repeater.context.getKeyModel( repeater[ ref[1] === 'i' ? 'index' : 'key' ] );\n\t\t\t}\n\t\t\tif ( ref === '@this' ) {\n\t\t\t\treturn fragment.ractive.viewmodel.getRactiveModel();\n\t\t\t}\n\t\t\tif ( ref === '@global' ) {\n\t\t\t\treturn GlobalModel$1;\n\t\t\t}\n\t\n\t\t\t// ancestor references\n\t\t\tif ( ref[0] === '~' ) return fragment.ractive.viewmodel.joinAll( splitKeypathI( ref.slice( 2 ) ) );\n\t\t\tif ( ref[0] === '.' ) {\n\t\t\t\tvar parts = ref.split( '/' );\n\t\n\t\t\t\twhile ( parts[0] === '.' || parts[0] === '..' ) {\n\t\t\t\t\tvar part = parts.shift();\n\t\n\t\t\t\t\tif ( part === '..' ) {\n\t\t\t\t\t\tcontext = context.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tref = parts.join( '/' );\n\t\n\t\t\t\t// special case - `{{.foo}}` means the same as `{{./foo}}`\n\t\t\t\tif ( ref[0] === '.' ) ref = ref.slice( 1 );\n\t\t\t\treturn context.joinAll( splitKeypathI( ref ) );\n\t\t\t}\n\t\n\t\t\treturn resolveAmbiguousReference( fragment, ref );\n\t\t}\n\t\n\t\tfunction Ractive$get ( keypath, opts ) {\n\t\t\tif ( typeof keypath !== 'string' ) return this.viewmodel.get( true, keypath );\n\t\n\t\t\tvar keys = splitKeypathI( keypath );\n\t\t\tvar key = keys[0];\n\t\n\t\t\tvar model;\n\t\n\t\t\tif ( !this.viewmodel.has( key ) ) {\n\t\t\t\t// if this is an inline component, we may need to create\n\t\t\t\t// an implicit mapping\n\t\t\t\tif ( this.component && !this.isolated ) {\n\t\t\t\t\tmodel = resolveReference( this.component.parentFragment, key );\n\t\n\t\t\t\t\tif ( model ) {\n\t\t\t\t\t\tthis.viewmodel.map( key, model );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tmodel = this.viewmodel.joinAll( keys );\n\t\t\treturn model.get( true, opts );\n\t\t}\n\t\n\t\tfunction gatherRefs( fragment ) {\n\t\t\tvar key = {}, index = {};\n\t\n\t\t\t// walk up the template gather refs as we go\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( fragment.parent && ( fragment.parent.indexRef || fragment.parent.keyRef ) ) {\n\t\t\t\t\tvar ref = fragment.parent.indexRef;\n\t\t\t\t\tif ( ref && !( ref in index ) ) index[ref] = fragment.index;\n\t\t\t\t\tref = fragment.parent.keyRef;\n\t\t\t\t\tif ( ref && !( ref in key ) ) key[ref] = fragment.key;\n\t\t\t\t}\n\t\n\t\t\t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n\t\t\t\t\tfragment = fragment.componentParent;\n\t\t\t\t} else {\n\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn { key: key, index: index };\n\t\t}\n\t\n\t\t// This function takes an array, the name of a mutator method, and the\n\t\t// arguments to call that mutator method with, and returns an array that\n\t\t// maps the old indices to their new indices.\n\t\n\t\t// So if you had something like this...\n\t\t//\n\t\t//     array = [ 'a', 'b', 'c', 'd' ];\n\t\t//     array.push( 'e' );\n\t\t//\n\t\t// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n\t\t// have changed. If you then did this...\n\t\t//\n\t\t//     array.unshift( 'z' );\n\t\t//\n\t\t// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n\t\t// one higher to make room for the 'z'. If you removed an item, the new index\n\t\t// would be -1...\n\t\t//\n\t\t//     array.splice( 2, 2 );\n\t\t//\n\t\t// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n\t\t//\n\t\t// This information is used to enable fast, non-destructive shuffling of list\n\t\t// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\t\n\t\tfunction getNewIndices ( length, methodName, args ) {\n\t\t\tvar spliceArguments, newIndices = [], removeStart, removeEnd, balance, i;\n\t\n\t\t\tspliceArguments = getSpliceEquivalent( length, methodName, args );\n\t\n\t\t\tif ( !spliceArguments ) {\n\t\t\t\treturn null; // TODO support reverse and sort?\n\t\t\t}\n\t\n\t\t\tbalance = ( spliceArguments.length - 2 ) - spliceArguments[1];\n\t\n\t\t\tremoveStart = Math.min( length, spliceArguments[0] );\n\t\t\tremoveEnd = removeStart + spliceArguments[1];\n\t\t\tnewIndices.startIndex = removeStart;\n\t\n\t\t\tfor ( i = 0; i < removeStart; i += 1 ) {\n\t\t\t\tnewIndices.push( i );\n\t\t\t}\n\t\n\t\t\tfor ( ; i < removeEnd; i += 1 ) {\n\t\t\t\tnewIndices.push( -1 );\n\t\t\t}\n\t\n\t\t\tfor ( ; i < length; i += 1 ) {\n\t\t\t\tnewIndices.push( i + balance );\n\t\t\t}\n\t\n\t\t\t// there is a net shift for the rest of the array starting with index + balance\n\t\t\tif ( balance !== 0 ) {\n\t\t\t\tnewIndices.touchedFrom = spliceArguments[0];\n\t\t\t} else {\n\t\t\t\tnewIndices.touchedFrom = length;\n\t\t\t}\n\t\n\t\t\treturn newIndices;\n\t\t}\n\t\n\t\n\t\t// The pop, push, shift an unshift methods can all be represented\n\t\t// as an equivalent splice\n\t\tfunction getSpliceEquivalent ( length, methodName, args ) {\n\t\t\tswitch ( methodName ) {\n\t\t\t\tcase 'splice':\n\t\t\t\t\tif ( args[0] !== undefined && args[0] < 0 ) {\n\t\t\t\t\t\targs[0] = length + Math.max( args[0], -length );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( args[0] === undefined ) args[0] = 0;\n\t\n\t\t\t\t\twhile ( args.length < 2 ) {\n\t\t\t\t\t\targs.push( length - args[0] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( typeof args[1] !== 'number' ) {\n\t\t\t\t\t\targs[1] = length - args[0];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// ensure we only remove elements that exist\n\t\t\t\t\targs[1] = Math.min( args[1], length - args[0] );\n\t\n\t\t\t\t\treturn args;\n\t\n\t\t\t\tcase 'sort':\n\t\t\t\tcase 'reverse':\n\t\t\t\t\treturn null;\n\t\n\t\t\t\tcase 'pop':\n\t\t\t\t\tif ( length ) {\n\t\t\t\t\t\treturn [ length - 1, 1 ];\n\t\t\t\t\t}\n\t\t\t\t\treturn [ 0, 0 ];\n\t\n\t\t\t\tcase 'push':\n\t\t\t\t\treturn [ length, 0 ].concat( args );\n\t\n\t\t\t\tcase 'shift':\n\t\t\t\t\treturn [ 0, length ? 1 : 0 ];\n\t\n\t\t\t\tcase 'unshift':\n\t\t\t\t\treturn [ 0, 0 ].concat( args );\n\t\t\t}\n\t\t}\n\t\n\t\tvar arrayProto = Array.prototype;\n\t\n\t\tfunction makeArrayMethod ( methodName ) {\n\t\t\tfunction path ( keypath ) {\n\t\t\t\tvar args = [], len = arguments.length - 1;\n\t\t\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t\t\t\treturn model( this.viewmodel.joinAll( splitKeypathI( keypath ) ), args );\n\t\t\t}\n\t\n\t\t\tfunction model ( mdl, args ) {\n\t\t\t\tvar array = mdl.get();\n\t\n\t\t\t\tif ( !isArray( array ) ) {\n\t\t\t\t\tif ( array === undefined ) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tvar result$1 = arrayProto[ methodName ].apply( array, args );\n\t\t\t\t\t\tvar promise$1 = runloop.start( this, true ).then( function () { return result$1; } );\n\t\t\t\t\t\tmdl.set( array );\n\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t\treturn promise$1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error( (\"shuffle array method \" + methodName + \" called on non-array at \" + (mdl.getKeypath())) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar newIndices = getNewIndices( array.length, methodName, args );\n\t\t\t\tvar result = arrayProto[ methodName ].apply( array, args );\n\t\n\t\t\t\tvar promise = runloop.start( this, true ).then( function () { return result; } );\n\t\t\t\tpromise.result = result;\n\t\n\t\t\t\tif ( newIndices ) {\n\t\t\t\t\tmdl.shuffle( newIndices );\n\t\t\t\t} else {\n\t\t\t\t\tmdl.set( result );\n\t\t\t\t}\n\t\n\t\t\t\trunloop.end();\n\t\n\t\t\t\treturn promise;\n\t\t\t}\n\t\n\t\t\treturn { path: path, model: model };\n\t\t}\n\t\n\t\tvar comparators = {};\n\t\n\t\tfunction getComparator ( option ) {\n\t\t\tif ( !option ) return null; // use existing arrays\n\t\t\tif ( option === true ) return JSON.stringify;\n\t\t\tif ( typeof option === 'function' ) return option;\n\t\n\t\t\tif ( typeof option === 'string' ) {\n\t\t\t\treturn comparators[ option ] || ( comparators[ option ] = function ( thing ) { return thing[ option ]; } );\n\t\t\t}\n\t\n\t\t\tthrow new Error( 'If supplied, options.compare must be a string, function, or `true`' ); // TODO link to docs\n\t\t}\n\t\n\t\tfunction merge$1 ( ractive, model, array, options ) {\n\t\t\tvar promise = runloop.start( ractive, true );\n\t\t\tvar value = model.get();\n\t\n\t\t\tif ( !isArray( value ) || !isArray( array ) ) {\n\t\t\t\tthrow new Error( 'You cannot merge an array with a non-array' );\n\t\t\t}\n\t\n\t\t\tvar comparator = getComparator( options && options.compare );\n\t\t\tmodel.merge( array, comparator );\n\t\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tfunction thisRactive$merge ( keypath, array, options ) {\n\t\t\treturn merge$1( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), array, options );\n\t\t}\n\t\n\t\tvar updateHook = new Hook( 'update' );\n\t\n\t\tfunction update$2 ( ractive, model ) {\n\t\t\t// if the parent is wrapped, the adaptor will need to be updated before\n\t\t\t// updating on this keypath\n\t\t\tif ( model.parent && model.parent.wrapper ) {\n\t\t\t\tmodel.parent.adapt();\n\t\t\t}\n\t\n\t\t\tvar promise = runloop.start( ractive, true );\n\t\n\t\t\tmodel.mark();\n\t\t\tmodel.registerChange( model.getKeypath(), model.get() );\n\t\n\t\t\tif ( !model.isRoot ) {\n\t\t\t\t// there may be unresolved refs that are now resolvable up the context tree\n\t\t\t\tvar parent = model.parent, key = model.key;\n\t\t\t\twhile ( parent && !parent.isRoot ) {\n\t\t\t\t\tif ( parent.clearUnresolveds ) parent.clearUnresolveds( key );\n\t\t\t\t\tkey = parent.key;\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// notify upstream of changes\n\t\t\tmodel.notifyUpstream();\n\t\n\t\t\trunloop.end();\n\t\n\t\t\tupdateHook.fire( ractive, model );\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tfunction Ractive$update ( keypath ) {\n\t\t\tif ( keypath ) keypath = splitKeypathI( keypath );\n\t\n\t\t\treturn update$2( this, keypath ? this.viewmodel.joinAll( keypath ) : this.viewmodel );\n\t\t}\n\t\n\t\tvar modelPush = makeArrayMethod( 'push' ).model;\n\t\tvar modelPop = makeArrayMethod( 'pop' ).model;\n\t\tvar modelShift = makeArrayMethod( 'shift' ).model;\n\t\tvar modelUnshift = makeArrayMethod( 'unshift' ).model;\n\t\tvar modelSort = makeArrayMethod( 'sort' ).model;\n\t\tvar modelSplice = makeArrayMethod( 'splice' ).model;\n\t\tvar modelReverse = makeArrayMethod( 'reverse' ).model;\n\t\n\t\t// TODO: at some point perhaps this could support relative * keypaths?\n\t\tfunction build$1 ( el, keypath, value ) {\n\t\t\tvar sets = [];\n\t\n\t\t\t// set multiple keypaths in one go\n\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\tfor ( var k in keypath ) {\n\t\t\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\t\t\tsets.push( [ findModel( el, k ).model, keypath[k] ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t// set a single keypath\n\t\t\telse {\n\t\t\t\tsets.push( [ findModel( el, keypath ).model, value ] );\n\t\t\t}\n\t\n\t\t\treturn sets;\n\t\t}\n\t\n\t\t// get relative keypaths and values\n\t\tfunction get ( keypath ) {\n\t\t\tif ( !keypath ) return this._element.parentFragment.findContext().get( true );\n\t\n\t\t\tvar model = resolveReference( this._element.parentFragment, keypath );\n\t\n\t\t\treturn model ? model.get( true ) : undefined;\n\t\t}\n\t\n\t\tfunction resolve$1 ( path, ractive ) {\n\t\t\tvar ref = findModel( this, path ), model = ref.model, instance = ref.instance;\n\t\t\treturn model ? model.getKeypath( ractive || instance ) : path;\n\t\t}\n\t\n\t\tfunction findModel ( el, path ) {\n\t\t\tvar frag = el._element.parentFragment;\n\t\n\t\t\tif ( typeof path !== 'string' ) {\n\t\t\t\treturn { model: frag.findContext(), instance: path };\n\t\t\t}\n\t\n\t\t\treturn { model: resolveReference( frag, path ), instance: frag.ractive };\n\t\t}\n\t\n\t\t// the usual mutation suspects\n\t\tfunction add$1 ( keypath, value ) {\n\t\t\tif ( value === undefined ) value = 1;\n\t\t\tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n\t\t\treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n\t\t\t\tvar model = pair[0], val = pair[1], value = model.get();\n\t\t\t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n\t\t\t\treturn [ model, value + val ];\n\t\t\t}) );\n\t\t}\n\t\n\t\tfunction animate ( keypath, value, options ) {\n\t\t\tvar model = findModel( this, keypath ).model;\n\t\t\treturn protoAnimate( this.ractive, model, value, options );\n\t\t}\n\t\n\t\tfunction link ( source, dest ) {\n\t\t\tvar there = findModel( this, source ).model, here = findModel( this, dest ).model;\n\t\t\tvar promise = runloop.start( this.ractive, true );\n\t\t\there.link( there, source );\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tfunction merge ( keypath, array, options ) {\n\t\t\treturn merge$1( this.ractive, findModel( this, keypath ).model, array, options );\n\t\t}\n\t\n\t\tfunction pop ( keypath ) {\n\t\t\treturn modelPop( findModel( this, keypath ).model, [] );\n\t\t}\n\t\n\t\tfunction push ( keypath ) {\n\t\t\tvar values = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\t\n\t\t\treturn modelPush( findModel( this, keypath ).model, values );\n\t\t}\n\t\n\t\tfunction reverse ( keypath ) {\n\t\t\treturn modelReverse( findModel( this, keypath ).model, [] );\n\t\t}\n\t\n\t\tfunction set$1 ( keypath, value ) {\n\t\t\treturn set( this.ractive, build$1( this, keypath, value ) );\n\t\t}\n\t\n\t\tfunction shift ( keypath ) {\n\t\t\treturn modelShift( findModel( this, keypath ).model, [] );\n\t\t}\n\t\n\t\tfunction splice ( keypath, index, drop ) {\n\t\t\tvar add = [], len = arguments.length - 3;\n\t\t\twhile ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];\n\t\n\t\t\tadd.unshift( index, drop );\n\t\t\treturn modelSplice( findModel( this, keypath ).model, add );\n\t\t}\n\t\n\t\tfunction sort ( keypath ) {\n\t\t\treturn modelSort( findModel( this, keypath ).model, [] );\n\t\t}\n\t\n\t\tfunction subtract ( keypath, value ) {\n\t\t\tif ( value === undefined ) value = 1;\n\t\t\tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n\t\t\treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n\t\t\t\tvar model = pair[0], val = pair[1], value = model.get();\n\t\t\t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n\t\t\t\treturn [ model, value - val ];\n\t\t\t}) );\n\t\t}\n\t\n\t\tfunction toggle ( keypath ) {\n\t\t\tvar ref = findModel( this, keypath ), model = ref.model;\n\t\t\treturn set( this.ractive, [ [ model, !model.get() ] ] );\n\t\t}\n\t\n\t\tfunction unlink ( dest ) {\n\t\t\tvar here = findModel( this, dest ).model;\n\t\t\tvar promise = runloop.start( this.ractive, true );\n\t\t\tif ( here.owner && here.owner._link ) here.owner.unlink();\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tfunction unshift ( keypath ) {\n\t\t\tvar add = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];\n\t\n\t\t\treturn modelUnshift( findModel( this, keypath ).model, add );\n\t\t}\n\t\n\t\tfunction update$1 ( keypath ) {\n\t\t\treturn update$2( this.ractive, findModel( this, keypath ).model );\n\t\t}\n\t\n\t\tfunction updateModel ( keypath, cascade ) {\n\t\t\tvar ref = findModel( this, keypath ), model = ref.model;\n\t\t\tvar promise = runloop.start( this.ractive, true );\n\t\t\tmodel.updateFromBindings( cascade );\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t}\n\t\n\t\t// two-way binding related helpers\n\t\tfunction isBound () {\n\t\t\tvar ref = getBindingModel( this ), model = ref.model;\n\t\t\treturn !!model;\n\t\t}\n\t\n\t\tfunction getBindingPath ( ractive ) {\n\t\t\tvar ref = getBindingModel( this ), model = ref.model, instance = ref.instance;\n\t\t\tif ( model ) return model.getKeypath( ractive || instance );\n\t\t}\n\t\n\t\tfunction getBinding () {\n\t\t\tvar ref = getBindingModel( this ), model = ref.model;\n\t\t\tif ( model ) return model.get( true );\n\t\t}\n\t\n\t\tfunction getBindingModel ( ctx ) {\n\t\t\tvar el = ctx._element;\n\t\t\treturn { model: el.binding && el.binding.model, instance: el.parentFragment.ractive };\n\t\t}\n\t\n\t\tfunction setBinding ( value ) {\n\t\t\tvar ref = getBindingModel( this ), model = ref.model;\n\t\t\treturn set( this.ractive, [ [ model, value ] ] );\n\t\t}\n\t\n\t\t// deprecated getters\n\t\tfunction keypath () {\n\t\t\twarnOnceIfDebug( (\"Object property keypath is deprecated, please use resolve() instead.\") );\n\t\t\treturn this.resolve();\n\t\t}\n\t\n\t\tfunction rootpath () {\n\t\t\twarnOnceIfDebug( (\"Object property rootpath is deprecated, please use resolve( ractive.root ) instead.\") );\n\t\t\treturn this.resolve( this.ractive.root );\n\t\t}\n\t\n\t\tfunction context () {\n\t\t\twarnOnceIfDebug( (\"Object property context is deprecated, please use get() instead.\") );\n\t\t\treturn this.get();\n\t\t}\n\t\n\t\tfunction index () {\n\t\t\twarnOnceIfDebug( (\"Object property index is deprecated, you can use get( \\\"indexName\\\" ) instead.\") );\n\t\t\treturn gatherRefs( this._element.parentFragment ).index;\n\t\t}\n\t\n\t\tfunction key () {\n\t\t\twarnOnceIfDebug( (\"Object property key is deprecated, you can use get( \\\"keyName\\\" ) instead.\") );\n\t\t\treturn gatherRefs( this._element.parentFragment ).key;\n\t\t}\n\t\n\t\tfunction addHelpers ( obj, element ) {\n\t\t\tdefineProperties( obj, {\n\t\t\t\t_element: { value: element },\n\t\t\t\tractive: { value: element.parentFragment.ractive },\n\t\t\t\tresolve: { value: resolve$1 },\n\t\t\t\tget: { value: get },\n\t\n\t\t\t\tadd: { value: add$1 },\n\t\t\t\tanimate: { value: animate },\n\t\t\t\tlink: { value: link },\n\t\t\t\tmerge: { value: merge },\n\t\t\t\tpop: { value: pop },\n\t\t\t\tpush: { value: push },\n\t\t\t\treverse: { value: reverse },\n\t\t\t\tset: { value: set$1 },\n\t\t\t\tshift: { value: shift },\n\t\t\t\tsort: { value: sort },\n\t\t\t\tsplice: { value: splice },\n\t\t\t\tsubtract: { value: subtract },\n\t\t\t\ttoggle: { value: toggle },\n\t\t\t\tunlink: { value: unlink },\n\t\t\t\tunshift: { value: unshift },\n\t\t\t\tupdate: { value: update$1 },\n\t\t\t\tupdateModel: { value: updateModel },\n\t\n\t\t\t\tisBound: { value: isBound },\n\t\t\t\tgetBindingPath: { value: getBindingPath },\n\t\t\t\tgetBinding: { value: getBinding },\n\t\t\t\tsetBinding: { value: setBinding },\n\t\n\t\t\t\tkeypath: { get: keypath },\n\t\t\t\trootpath: { get: rootpath },\n\t\t\t\tcontext: { get: context },\n\t\t\t\tindex: { get: index },\n\t\t\t\tkey: { get: key }\n\t\t\t});\n\t\n\t\t\treturn obj;\n\t\t}\n\t\n\t\tvar query = doc && doc.querySelector;\n\t\n\t\tfunction staticInfo( node ) {\n\t\t\tif ( typeof node === 'string' && query ) {\n\t\t\t\tnode = query.call( document, node );\n\t\t\t}\n\t\n\t\t\tif ( !node || !node._ractive ) return {};\n\t\n\t\t\tvar storage = node._ractive;\n\t\n\t\t\treturn addHelpers( {}, storage.proxy );\n\t\t}\n\t\n\t\tfunction getNodeInfo( node ) {\n\t\t\tif ( typeof node === 'string' ) {\n\t\t\t\tnode = this.find( node );\n\t\t\t}\n\t\n\t\t\treturn staticInfo( node );\n\t\t}\n\t\n\t\tvar insertHook = new Hook( 'insert' );\n\t\n\t\tfunction Ractive$insert ( target, anchor ) {\n\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\t// TODO create, and link to, documentation explaining this\n\t\t\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t\t\t}\n\t\n\t\t\ttarget = getElement( target );\n\t\t\tanchor = getElement( anchor ) || null;\n\t\n\t\t\tif ( !target ) {\n\t\t\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t\t\t}\n\t\n\t\t\ttarget.insertBefore( this.detach(), anchor );\n\t\t\tthis.el = target;\n\t\n\t\t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\t\t\tthis.isDetached = false;\n\t\n\t\t\tfireInsertHook( this );\n\t\t}\n\t\n\t\tfunction fireInsertHook( ractive ) {\n\t\t\tinsertHook.fire( ractive );\n\t\n\t\t\tractive.findAllComponents('*').forEach( function ( child ) {\n\t\t\t\tfireInsertHook( child.instance );\n\t\t\t});\n\t\t}\n\t\n\t\tfunction link$1( there, here ) {\n\t\t\tif ( here === there || (there + '.').indexOf( here + '.' ) === 0 || (here + '.').indexOf( there + '.' ) === 0 ) {\n\t\t\t\tthrow new Error( 'A keypath cannot be linked to itself.' );\n\t\t\t}\n\t\n\t\t\tvar promise = runloop.start();\n\t\t\tvar model;\n\t\n\t\t\t// may need to allow a mapping to resolve implicitly\n\t\t\tvar sourcePath = splitKeypathI( there );\n\t\t\tif ( !this.viewmodel.has( sourcePath[0] ) && this.component ) {\n\t\t\t\tmodel = resolveReference( this.component.parentFragment, sourcePath[0] );\n\t\t\t\tmodel = model.joinAll( sourcePath.slice( 1 ) );\n\t\t\t}\n\t\n\t\t\tthis.viewmodel.joinAll( splitKeypathI( here ) ).link( model || this.viewmodel.joinAll( sourcePath ), there );\n\t\n\t\t\trunloop.end();\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tvar ReferenceResolver = function ReferenceResolver ( fragment, reference, callback ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.fragment = fragment;\n\t\t\tthis.reference = normalise( reference );\n\t\t\tthis.callback = callback;\n\t\n\t\t\tthis.keys = splitKeypathI( reference );\n\t\t\tthis.resolved = false;\n\t\n\t\t\tthis.contexts = [];\n\t\n\t\t\t// TODO the consumer should take care of addUnresolved\n\t\t\t// we attach to all the contexts between here and the root\n\t\t\t// - whenever their values change, they can quickly\n\t\t\t// check to see if we can resolve\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( fragment.context ) {\n\t\t\t\t\tfragment.context.addUnresolved( this$1.keys[0], this$1 );\n\t\t\t\t\tthis$1.contexts.push( fragment.context );\n\t\t\t\t}\n\t\n\t\t\t\tfragment = fragment.componentParent || fragment.parent;\n\t\t\t}\n\t\t};\n\t\n\t\tReferenceResolver.prototype.attemptResolution = function attemptResolution () {\n\t\t\tif ( this.resolved ) return;\n\t\n\t\t\tvar model = resolveAmbiguousReference( this.fragment, this.reference );\n\t\n\t\t\tif ( model ) {\n\t\t\t\tthis.resolved = true;\n\t\t\t\tthis.callback( model );\n\t\t\t}\n\t\t};\n\t\n\t\tReferenceResolver.prototype.forceResolution = function forceResolution () {\n\t\t\tif ( this.resolved ) return;\n\t\n\t\t\tvar model = this.fragment.findContext().joinAll( this.keys );\n\t\t\tthis.callback( model );\n\t\t\tthis.resolved = true;\n\t\t};\n\t\n\t\tReferenceResolver.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( previous ) previous.removeUnresolved( this.keys[0], this );\n\t\t\tif ( next ) runloop.scheduleTask( function () { return next.addUnresolved( this$1.keys[0], this$1 ); } );\n\t\t};\n\t\n\t\tReferenceResolver.prototype.unbind = function unbind () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.fragment ) removeFromArray( this.fragment.unresolved, this );\n\t\n\t\t\tif ( this.resolved ) return;\n\t\n\t\t\tthis.contexts.forEach( function ( c ) { return c.removeUnresolved( this$1.keys[0], this$1 ); } );\n\t\t};\n\t\n\t\tfunction observe ( keypath, callback, options ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\tvar observers = [];\n\t\t\tvar map;\n\t\n\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\tmap = keypath;\n\t\t\t\toptions = callback || {};\n\t\n\t\t\t\tObject.keys( map ).forEach( function ( keypath ) {\n\t\t\t\t\tvar callback = map[ keypath ];\n\t\n\t\t\t\t\tvar keypaths = keypath.split( ' ' );\n\t\t\t\t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\t\n\t\t\t\t\tkeypaths.forEach( function ( keypath ) {\n\t\t\t\t\t\tobservers.push( createObserver( this$1, keypath, callback, options ) );\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\tvar keypaths;\n\t\n\t\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\t\toptions = callback;\n\t\t\t\t\tcallback = keypath;\n\t\t\t\t\tkeypaths = [ '' ];\n\t\t\t\t} else {\n\t\t\t\t\tkeypaths = keypath.split( ' ' );\n\t\t\t\t}\n\t\n\t\t\t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\t\n\t\t\t\tkeypaths.forEach( function ( keypath ) {\n\t\t\t\t\tobservers.push( createObserver( this$1, keypath, callback, options || {} ) );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// add observers to the Ractive instance, so they can be\n\t\t\t// cancelled on ractive.teardown()\n\t\t\tthis._observers.push.apply( this._observers, observers );\n\t\n\t\t\treturn {\n\t\t\t\tcancel: function () {\n\t\t\t\t\tobservers.forEach( function ( observer ) {\n\t\t\t\t\t\tremoveFromArray ( this$1._observers, observer );\n\t\t\t\t\t\tobserver.cancel();\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction createObserver ( ractive, keypath, callback, options ) {\n\t\t\tvar viewmodel = ractive.viewmodel;\n\t\n\t\t\tvar keys = splitKeypathI( keypath );\n\t\t\tvar wildcardIndex = keys.indexOf( '*' );\n\t\t\toptions.keypath = keypath;\n\t\n\t\t\t// normal keypath - no wildcards\n\t\t\tif ( !~wildcardIndex ) {\n\t\t\t\tvar key = keys[0];\n\t\t\t\tvar model;\n\t\n\t\t\t\t// if not the root model itself, check if viewmodel has key.\n\t\t\t\tif ( key !== '' && !viewmodel.has( key ) ) {\n\t\t\t\t\t// if this is an inline component, we may need to create an implicit mapping\n\t\t\t\t\tif ( ractive.component && !ractive.isolated ) {\n\t\t\t\t\t\tmodel = resolveReference( ractive.component.parentFragment, key );\n\t\t\t\t\t\tif ( model ) {\n\t\t\t\t\t\t\tviewmodel.map( key, model );\n\t\t\t\t\t\t\tmodel = viewmodel.joinAll( keys );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmodel = viewmodel.joinAll( keys );\n\t\t\t\t}\n\t\n\t\t\t\treturn new Observer( ractive, model, callback, options );\n\t\t\t}\n\t\n\t\t\t// pattern observers - more complex case\n\t\t\tvar baseModel = wildcardIndex === 0 ?\n\t\t\t\tviewmodel :\n\t\t\t\tviewmodel.joinAll( keys.slice( 0, wildcardIndex ) );\n\t\n\t\t\treturn new PatternObserver( ractive, baseModel, keys.splice( wildcardIndex ), callback, options );\n\t\t}\n\t\n\t\tvar Observer = function Observer ( ractive, model, callback, options ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.context = options.context || ractive;\n\t\t\tthis.callback = callback;\n\t\t\tthis.ractive = ractive;\n\t\n\t\t\tif ( model ) this.resolved( model );\n\t\t\telse {\n\t\t\t\tthis.keypath = options.keypath;\n\t\t\t\tthis.resolver = new ReferenceResolver( ractive.fragment, options.keypath, function ( model ) {\n\t\t\t\t\tthis$1.resolved( model );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif ( options.init !== false ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.dispatch();\n\t\t\t} else {\n\t\t\t\tthis.oldValue = this.newValue;\n\t\t\t}\n\t\n\t\t\tthis.defer = options.defer;\n\t\t\tthis.once = options.once;\n\t\t\tthis.strict = options.strict;\n\t\n\t\t\tthis.dirty = false;\n\t\t};\n\t\n\t\tObserver.prototype.cancel = function cancel () {\n\t\t\tthis.cancelled = true;\n\t\t\tif ( this.model ) {\n\t\t\t\tthis.model.unregister( this );\n\t\t\t} else {\n\t\t\t\tthis.resolver.unbind();\n\t\t\t}\n\t\t};\n\t\n\t\tObserver.prototype.dispatch = function dispatch () {\n\t\t\tif ( !this.cancelled ) {\n\t\t\t\tthis.callback.call( this.context, this.newValue, this.oldValue, this.keypath );\n\t\t\t\tthis.oldValue = this.model ? this.model.get() : this.newValue;\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\t\t};\n\t\n\t\tObserver.prototype.handleChange = function handleChange () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\tvar newValue = this.model.get();\n\t\t\t\tif ( isEqual( newValue, this.oldValue ) ) return;\n\t\n\t\t\t\tthis.newValue = newValue;\n\t\n\t\t\t\tif ( this.strict && this.newValue === this.oldValue ) return;\n\t\n\t\t\t\trunloop.addObserver( this, this.defer );\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\tif ( this.once ) runloop.scheduleTask( function () { return this$1.cancel(); } );\n\t\t\t}\n\t\t};\n\t\n\t\tObserver.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tnext = rebindMatch( this.keypath, next, previous );\n\t\t\t// TODO: set up a resolver if next is undefined?\n\t\t\tif ( next === this.model ) return false;\n\t\n\t\t\tif ( this.model ) this.model.unregister( this );\n\t\t\tif ( next ) next.addShuffleTask( function () { return this$1.resolved( next ); } );\n\t\t};\n\t\n\t\tObserver.prototype.resolved = function resolved ( model ) {\n\t\t\tthis.model = model;\n\t\t\tthis.keypath = model.getKeypath( this.ractive );\n\t\n\t\t\tthis.oldValue = undefined;\n\t\t\tthis.newValue = model.get();\n\t\n\t\t\tmodel.register( this );\n\t\t};\n\t\n\t\tvar PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.context = options.context || ractive;\n\t\t\tthis.ractive = ractive;\n\t\t\tthis.baseModel = baseModel;\n\t\t\tthis.keys = keys;\n\t\t\tthis.callback = callback;\n\t\n\t\t\tvar pattern = keys.join( '\\\\.' ).replace( /\\*/g, '(.+)' );\n\t\t\tvar baseKeypath = baseModel.getKeypath( ractive );\n\t\t\tthis.pattern = new RegExp( (\"^\" + (baseKeypath ? baseKeypath + '\\\\.' : '') + \"\" + pattern + \"$\") );\n\t\n\t\t\tthis.oldValues = {};\n\t\t\tthis.newValues = {};\n\t\n\t\t\tthis.defer = options.defer;\n\t\t\tthis.once = options.once;\n\t\t\tthis.strict = options.strict;\n\t\n\t\t\tthis.dirty = false;\n\t\t\tthis.changed = [];\n\t\t\tthis.partial = false;\n\t\n\t\t\tvar models = baseModel.findMatches( this.keys );\n\t\n\t\t\tmodels.forEach( function ( model ) {\n\t\t\t\tthis$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();\n\t\t\t});\n\t\n\t\t\tif ( options.init !== false ) {\n\t\t\t\tthis.dispatch();\n\t\t\t} else {\n\t\t\t\tthis.oldValues = this.newValues;\n\t\t\t}\n\t\n\t\t\tbaseModel.registerPatternObserver( this );\n\t\t};\n\t\n\t\tPatternObserver.prototype.cancel = function cancel () {\n\t\t\tthis.baseModel.unregisterPatternObserver( this );\n\t\t};\n\t\n\t\tPatternObserver.prototype.dispatch = function dispatch () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar newValues = this.newValues;\n\t\t\tthis.newValues = {};\n\t\t\tObject.keys( newValues ).forEach( function ( keypath ) {\n\t\t\t\tif ( this$1.newKeys && !this$1.newKeys[ keypath ] ) return;\n\t\n\t\t\t\tvar newValue = newValues[ keypath ];\n\t\t\t\tvar oldValue = this$1.oldValues[ keypath ];\n\t\n\t\t\t\tif ( this$1.strict && newValue === oldValue ) return;\n\t\t\t\tif ( isEqual( newValue, oldValue ) ) return;\n\t\n\t\t\t\tvar args = [ newValue, oldValue, keypath ];\n\t\t\t\tif ( keypath ) {\n\t\t\t\t\tvar wildcards = this$1.pattern.exec( keypath );\n\t\t\t\t\tif ( wildcards ) {\n\t\t\t\t\t\targs = args.concat( wildcards.slice( 1 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis$1.callback.apply( this$1.context, args );\n\t\t\t});\n\t\n\t\t\tif ( this.partial ) {\n\t\t\t\tfor ( var k in newValues ) {\n\t\t\t\t\tthis.oldValues[k] = newValues[k];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.oldValues = newValues;\n\t\t\t}\n\t\n\t\t\tthis.newKeys = null;\n\t\t\tthis.dirty = false;\n\t\t};\n\t\n\t\tPatternObserver.prototype.notify = function notify ( key ) {\n\t\t\tthis.changed.push( key );\n\t\t};\n\t\n\t\tPatternObserver.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !isArray( this.baseModel.value ) ) return;\n\t\n\t\t\tvar base = this.baseModel.getKeypath( this.ractive );\n\t\t\tvar max = this.baseModel.value.length;\n\t\t\tvar suffix = this.keys.length > 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : '';\n\t\n\t\t\tthis.newKeys = {};\n\t\t\tfor ( var i = 0; i < newIndices.length; i++ ) {\n\t\t\t\tif ( newIndices[ i ] === -1 || newIndices[ i ] === i ) continue;\n\t\t\t\tthis$1.newKeys[ (\"\" + base + \".\" + i + \"\" + suffix) ] = true;\n\t\t\t}\n\t\n\t\t\tfor ( var i$1 = newIndices.touchedFrom; i$1 < max; i$1++ ) {\n\t\t\t\tthis$1.newKeys[ (\"\" + base + \".\" + i$1 + \"\" + suffix) ] = true;\n\t\t\t}\n\t\t};\n\t\n\t\tPatternObserver.prototype.handleChange = function handleChange () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.dirty || this.changed.length ) {\n\t\t\t\tif ( !this.dirty ) this.newValues = {};\n\t\n\t\t\t\t// handle case where previously extant keypath no longer exists -\n\t\t\t\t// observer should still fire, with undefined as new value\n\t\t\t\t// TODO huh. according to the test suite that's not the case...\n\t\t\t\t// NOTE: I don't think this will work with partial updates\n\t\t\t\t// Object.keys( this.oldValues ).forEach( keypath => {\n\t\t\t\t// this.newValues[ keypath ] = undefined;\n\t\t\t\t// });\n\t\n\t\t\t\tif ( !this.changed.length ) {\n\t\t\t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n\t\t\t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n\t\t\t\t\t\tthis$1.newValues[ keypath ] = model.get();\n\t\t\t\t\t});\n\t\t\t\t\tthis.partial = false;\n\t\t\t\t} else {\n\t\t\t\t\tvar count = 0;\n\t\t\t\t\tvar ok = this.baseModel.isRoot ?\n\t\t\t\t\t\tthis.changed.map( function ( keys ) { return keys.map( escapeKey ).join( '.' ); } ) :\n\t\t\t\t\t\tthis.changed.map( function ( keys ) { return this$1.baseModel.getKeypath( this$1.ractive ) + '.' + keys.map( escapeKey ).join( '.' ); } );\n\t\n\t\t\t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n\t\t\t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n\t\t\t\t\t\tvar check = function ( k ) {\n\t\t\t\t\t\t\treturn ( k.indexOf( keypath ) === 0 && ( k.length === keypath.length || k[ keypath.length ] === '.' ) ) ||\n\t\t\t\t\t\t\t\t\t   ( keypath.indexOf( k ) === 0 && ( k.length === keypath.length || keypath[ k.length ] === '.' ) );\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t// is this model on a changed keypath?\n\t\t\t\t\t\tif ( ok.filter( check ).length ) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tthis$1.newValues[ keypath ] = model.get();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\t// no valid change triggered, so bail to avoid breakage\n\t\t\t\t\tif ( !count ) return;\n\t\n\t\t\t\t\tthis.partial = true;\n\t\t\t\t}\n\t\n\t\t\t\trunloop.addObserver( this, this.defer );\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.changed.length = 0;\n\t\n\t\t\t\tif ( this.once ) this.cancel();\n\t\t\t}\n\t\t};\n\t\n\t\tfunction observeList ( keypath, callback, options ) {\n\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\tthrow new Error( 'ractive.observeList() must be passed a string as its first argument' );\n\t\t\t}\n\t\n\t\t\tvar model = this.viewmodel.joinAll( splitKeypathI( keypath ) );\n\t\t\tvar observer = new ListObserver( this, model, callback, options || {} );\n\t\n\t\t\t// add observer to the Ractive instance, so it can be\n\t\t\t// cancelled on ractive.teardown()\n\t\t\tthis._observers.push( observer );\n\t\n\t\t\treturn {\n\t\t\t\tcancel: function () {\n\t\t\t\t\tobserver.cancel();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction negativeOne () {\n\t\t\treturn -1;\n\t\t}\n\t\n\t\tvar ListObserver = function ListObserver ( context, model, callback, options ) {\n\t\t\tthis.context = context;\n\t\t\tthis.model = model;\n\t\t\tthis.keypath = model.getKeypath();\n\t\t\tthis.callback = callback;\n\t\n\t\t\tthis.pending = null;\n\t\n\t\t\tmodel.register( this );\n\t\n\t\t\tif ( options.init !== false ) {\n\t\t\t\tthis.sliced = [];\n\t\t\t\tthis.shuffle([]);\n\t\t\t\tthis.handleChange();\n\t\t\t} else {\n\t\t\t\tthis.sliced = this.slice();\n\t\t\t}\n\t\t};\n\t\n\t\tListObserver.prototype.handleChange = function handleChange () {\n\t\t\tif ( this.pending ) {\n\t\t\t\t// post-shuffle\n\t\t\t\tthis.callback( this.pending );\n\t\t\t\tthis.pending = null;\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\t// entire array changed\n\t\t\t\tthis.shuffle( this.sliced.map( negativeOne ) );\n\t\t\t\tthis.handleChange();\n\t\t\t}\n\t\t};\n\t\n\t\tListObserver.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar newValue = this.slice();\n\t\n\t\t\tvar inserted = [];\n\t\t\tvar deleted = [];\n\t\t\tvar start;\n\t\n\t\t\tvar hadIndex = {};\n\t\n\t\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\t\thadIndex[ newIndex ] = true;\n\t\n\t\t\t\tif ( newIndex !== oldIndex && start === undefined ) {\n\t\t\t\t\tstart = oldIndex;\n\t\t\t\t}\n\t\n\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\tdeleted.push( this$1.sliced[ oldIndex ] );\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tif ( start === undefined ) start = newIndices.length;\n\t\n\t\t\tvar len = newValue.length;\n\t\t\tfor ( var i = 0; i < len; i += 1 ) {\n\t\t\t\tif ( !hadIndex[i] ) inserted.push( newValue[i] );\n\t\t\t}\n\t\n\t\t\tthis.pending = { inserted: inserted, deleted: deleted, start: start };\n\t\t\tthis.sliced = newValue;\n\t\t};\n\t\n\t\tListObserver.prototype.slice = function slice () {\n\t\t\tvar value = this.model.get();\n\t\t\treturn isArray( value ) ? value.slice() : [];\n\t\t};\n\t\n\t\tvar onceOptions = { init: false, once: true };\n\t\n\t\tfunction observeOnce ( keypath, callback, options ) {\n\t\t\tif ( isObject( keypath ) || typeof keypath === 'function' ) {\n\t\t\t\toptions = extendObj( callback || {}, onceOptions );\n\t\t\t\treturn this.observe( keypath, options );\n\t\t\t}\n\t\n\t\t\toptions = extendObj( options || {}, onceOptions );\n\t\t\treturn this.observe( keypath, callback, options );\n\t\t}\n\t\n\t\tfunction trim ( str ) { return str.trim(); };\n\t\n\t\tfunction notEmptyString ( str ) { return str !== ''; };\n\t\n\t\tfunction Ractive$off ( eventName, callback ) {\n\t\t\t// if no arguments specified, remove all callbacks\n\t\t\tvar this$1 = this;\n\t\n\t\t\tif ( !eventName ) {\n\t\t\t\t// TODO use this code instead, once the following issue has been resolved\n\t\t\t\t// in PhantomJS (tests are unpassable otherwise!)\n\t\t\t\t// https://github.com/ariya/phantomjs/issues/11856\n\t\t\t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t\t\t\tfor ( eventName in this._subs ) {\n\t\t\t\t\tdelete this._subs[ eventName ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\t// Handle multiple space-separated event names\n\t\t\t\tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\n\t\t\t\teventNames.forEach( function ( eventName ) {\n\t\t\t\t\tvar subscribers = this$1._subs[ eventName ];\n\t\n\t\t\t\t\t// If we have subscribers for this event...\n\t\t\t\t\tif ( subscribers ) {\n\t\t\t\t\t\t// ...if a callback was specified, only remove that\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t// flag this callback as off so that any in-flight firings don't call\n\t\t\t\t\t\t\t// a cancelled handler - this is _slightly_ hacky\n\t\t\t\t\t\t\tcallback.off = true;\n\t\t\t\t\t\t\tvar index = subscribers.indexOf( callback );\n\t\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// ...otherwise remove all callbacks\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis$1._subs[ eventName ] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\tfunction Ractive$on ( eventName, callback ) {\n\t\t\t// allow multiple listeners to be bound in one go\n\t\t\tvar this$1 = this;\n\t\n\t\t\tif ( typeof eventName === 'object' ) {\n\t\t\t\tvar listeners = [];\n\t\t\t\tvar n;\n\t\n\t\t\t\tfor ( n in eventName ) {\n\t\t\t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t\t\t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function () {\n\t\t\t\t\t\tvar listener;\n\t\t\t\t\t\twhile ( listener = listeners.pop() ) listener.cancel();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Handle multiple space-separated event names\n\t\t\tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\n\t\t\teventNames.forEach( function ( eventName ) {\n\t\t\t\t( this$1._subs[ eventName ] || ( this$1._subs[ eventName ] = [] ) ).push( callback );\n\t\t\t});\n\t\n\t\t\treturn {\n\t\t\t\tcancel: function () { return this$1.off( eventName, callback ); }\n\t\t\t};\n\t\t}\n\t\n\t\tfunction Ractive$once ( eventName, handler ) {\n\t\t\tvar listener = this.on( eventName, function () {\n\t\t\t\thandler.apply( this, arguments );\n\t\t\t\tlistener.cancel();\n\t\t\t});\n\t\n\t\t\t// so we can still do listener.cancel() manually\n\t\t\treturn listener;\n\t\t}\n\t\n\t\tvar pop$1 = makeArrayMethod( 'pop' ).path;\n\t\n\t\tvar push$1 = makeArrayMethod( 'push' ).path;\n\t\n\t\tvar PREFIX = '/* Ractive.js component styles */';\n\t\n\t\t// Holds current definitions of styles.\n\t\tvar styleDefinitions = [];\n\t\n\t\t// Flag to tell if we need to update the CSS\n\t\tvar isDirty = false;\n\t\n\t\t// These only make sense on the browser. See additional setup below.\n\t\tvar styleElement = null;\n\t\tvar useCssText = null;\n\t\n\t\tfunction addCSS( styleDefinition ) {\n\t\t\tstyleDefinitions.push( styleDefinition );\n\t\t\tisDirty = true;\n\t\t}\n\t\n\t\tfunction applyCSS() {\n\t\n\t\t\t// Apply only seems to make sense when we're in the DOM. Server-side renders\n\t\t\t// can call toCSS to get the updated CSS.\n\t\t\tif ( !doc || !isDirty ) return;\n\t\n\t\t\tif ( useCssText ) {\n\t\t\t\tstyleElement.styleSheet.cssText = getCSS( null );\n\t\t\t} else {\n\t\t\t\tstyleElement.innerHTML = getCSS( null );\n\t\t\t}\n\t\n\t\t\tisDirty = false;\n\t\t}\n\t\n\t\tfunction getCSS( cssIds ) {\n\t\n\t\t\tvar filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function ( style ) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;\n\t\n\t\t\treturn filteredStyleDefinitions.reduce( function ( styles, style ) { return (\"\" + styles + \"\\n\\n/* {\" + (style.id) + \"} */\\n\" + (style.styles)); }, PREFIX );\n\t\n\t\t}\n\t\n\t\t// If we're on the browser, additional setup needed.\n\t\tif ( doc && ( !styleElement || !styleElement.parentNode ) ) {\n\t\n\t\t\tstyleElement = doc.createElement( 'style' );\n\t\t\tstyleElement.type = 'text/css';\n\t\n\t\t\tdoc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );\n\t\n\t\t\tuseCssText = !!styleElement.styleSheet;\n\t\t}\n\t\n\t\tvar renderHook = new Hook( 'render' );\n\t\tvar completeHook = new Hook( 'complete' );\n\t\n\t\tfunction render$1 ( ractive, target, anchor, occupants ) {\n\t\t\t// if `noIntro` is `true`, temporarily disable transitions\n\t\t\tvar transitionsEnabled = ractive.transitionsEnabled;\n\t\t\tif ( ractive.noIntro ) ractive.transitionsEnabled = false;\n\t\n\t\t\tvar promise = runloop.start( ractive, true );\n\t\t\trunloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );\n\t\n\t\t\tif ( ractive.fragment.rendered ) {\n\t\t\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t\t\t}\n\t\n\t\t\tanchor = getElement( anchor ) || ractive.anchor;\n\t\n\t\t\tractive.el = target;\n\t\t\tractive.anchor = anchor;\n\t\n\t\t\t// ensure encapsulated CSS is up-to-date\n\t\t\tif ( ractive.cssId ) applyCSS();\n\t\n\t\t\tif ( target ) {\n\t\t\t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );\n\t\n\t\t\t\tif ( anchor ) {\n\t\t\t\t\tvar docFrag = doc.createDocumentFragment();\n\t\t\t\t\tractive.fragment.render( docFrag );\n\t\t\t\t\ttarget.insertBefore( docFrag, anchor );\n\t\t\t\t} else {\n\t\t\t\t\tractive.fragment.render( target, occupants );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trunloop.end();\n\t\t\tractive.transitionsEnabled = transitionsEnabled;\n\t\n\t\t\treturn promise.then( function () { return completeHook.fire( ractive ); } );\n\t\t}\n\t\n\t\tfunction Ractive$render ( target, anchor ) {\n\t\t\tif ( this.torndown ) {\n\t\t\t\twarnIfDebug( 'ractive.render() was called on a Ractive instance that was already torn down' );\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\n\t\t\ttarget = getElement( target ) || this.el;\n\t\n\t\t\tif ( !this.append && target ) {\n\t\t\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t\t\t// avoids certain weird bugs\n\t\t\t\tvar others = target.__ractive_instances__;\n\t\t\t\tif ( others ) others.forEach( teardown );\n\t\n\t\t\t\t// make sure we are the only occupants\n\t\t\t\tif ( !this.enhance ) {\n\t\t\t\t\ttarget.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar occupants = this.enhance ? toArray( target.childNodes ) : null;\n\t\t\tvar promise = render$1( this, target, anchor, occupants );\n\t\n\t\t\tif ( occupants ) {\n\t\t\t\twhile ( occupants.length ) target.removeChild( occupants.pop() );\n\t\t\t}\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tvar adaptConfigurator = {\n\t\t\textend: function ( Parent, proto, options ) {\n\t\t\t\tproto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );\n\t\t\t},\n\t\n\t\t\tinit: function () {}\n\t\t};\n\t\n\t\tfunction combine ( a, b ) {\n\t\t\tvar c = a.slice();\n\t\t\tvar i = b.length;\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\t\t\tc.push( b[i] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn c;\n\t\t}\n\t\n\t\tvar selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g;\n\t\tvar commentsPattern = /\\/\\*[\\s\\S]*?\\*\\//g;\n\t\tvar selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\n\t\tvar excludePattern = /^(?:@|\\d+%)/;\n\t\tvar dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\t\n\t\tfunction trim$1 ( str ) {\n\t\t\treturn str.trim();\n\t\t}\n\t\n\t\tfunction extractString ( unit ) {\n\t\t\treturn unit.str;\n\t\t}\n\t\n\t\tfunction transformSelector ( selector, parent ) {\n\t\t\tvar selectorUnits = [];\n\t\t\tvar match;\n\t\n\t\t\twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t\t\t\tselectorUnits.push({\n\t\t\t\t\tstr: match[0],\n\t\t\t\t\tbase: match[1],\n\t\t\t\t\tmodifiers: match[2]\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// For each simple selector within the selector, we need to create a version\n\t\t\t// that a) combines with the id, and b) is inside the id\n\t\t\tvar base = selectorUnits.map( extractString );\n\t\n\t\t\tvar transformed = [];\n\t\t\tvar i = selectorUnits.length;\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar appended = base.slice();\n\t\n\t\t\t\t// Pseudo-selectors should go after the attribute selector\n\t\t\t\tvar unit = selectorUnits[i];\n\t\t\t\tappended[i] = unit.base + parent + unit.modifiers || '';\n\t\n\t\t\t\tvar prepended = base.slice();\n\t\t\t\tprepended[i] = parent + ' ' + prepended[i];\n\t\n\t\t\t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t\t\t}\n\t\n\t\t\treturn transformed.join( ', ' );\n\t\t}\n\t\n\t\tfunction transformCss ( css, id ) {\n\t\t\tvar dataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\t\n\t\t\tvar transformed;\n\t\n\t\t\tif ( dataRvcGuidPattern.test( css ) ) {\n\t\t\t\ttransformed = css.replace( dataRvcGuidPattern, dataAttr );\n\t\t\t} else {\n\t\t\t\ttransformed = css\n\t\t\t\t.replace( commentsPattern, '' )\n\t\t\t\t.replace( selectorsPattern, function ( match, $1 ) {\n\t\t\t\t\t// don't transform at-rules and keyframe declarations\n\t\t\t\t\tif ( excludePattern.test( $1 ) ) return match;\n\t\n\t\t\t\t\tvar selectors = $1.split( ',' ).map( trim$1 );\n\t\t\t\t\tvar transformed = selectors\n\t\t\t\t\t\t.map( function ( selector ) { return transformSelector( selector, dataAttr ); } )\n\t\t\t\t\t\t.join( ', ' ) + ' ';\n\t\n\t\t\t\t\treturn match.replace( $1, transformed );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\treturn transformed;\n\t\t}\n\t\n\t\tfunction s4() {\n\t\t\treturn Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t\t}\n\t\n\t\tfunction uuid() {\n\t\t\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t\t}\n\t\n\t\tvar cssConfigurator = {\n\t\t\tname: 'css',\n\t\n\t\t\t// Called when creating a new component definition\n\t\t\textend: function ( Parent, proto, options ) {\n\t\t\t\tif ( !options.css ) return;\n\t\n\t\t\t\tvar id = uuid();\n\t\t\t\tvar styles = options.noCssTransform ? options.css : transformCss( options.css, id );\n\t\n\t\t\t\tproto.cssId = id;\n\t\n\t\t\t\taddCSS( { id: id, styles: styles } );\n\t\n\t\t\t},\n\t\n\t\t\t// Called when creating a new component instance\n\t\t\tinit: function ( Parent, target, options ) {\n\t\t\t\tif ( !options.css ) return;\n\t\n\t\t\t\twarnIfDebug( (\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\") );\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tfunction validate ( data ) {\n\t\t\t// Warn if userOptions.data is a non-POJO\n\t\t\tif ( data && data.constructor !== Object ) {\n\t\t\t\tif ( typeof data === 'function' ) {\n\t\t\t\t\t// TODO do we need to support this in the new Ractive() case?\n\t\t\t\t} else if ( typeof data !== 'object' ) {\n\t\t\t\t\tfatal( (\"data option must be an object or a function, `\" + data + \"` is not valid\") );\n\t\t\t\t} else {\n\t\t\t\t\twarnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar dataConfigurator = {\n\t\t\tname: 'data',\n\t\n\t\t\textend: function ( Parent, proto, options ) {\n\t\t\t\tvar key;\n\t\t\t\tvar value;\n\t\n\t\t\t\t// check for non-primitives, which could cause mutation-related bugs\n\t\t\t\tif ( options.data && isObject( options.data ) ) {\n\t\t\t\t\tfor ( key in options.data ) {\n\t\t\t\t\t\tvalue = options.data[ key ];\n\t\n\t\t\t\t\t\tif ( value && typeof value === 'object' ) {\n\t\t\t\t\t\t\tif ( isObject( value ) || isArray( value ) ) {\n\t\t\t\t\t\t\t\twarnIfDebug( (\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\") );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tproto.data = combine$1( proto.data, options.data );\n\t\t\t},\n\t\n\t\t\tinit: function ( Parent, ractive, options ) {\n\t\t\t\tvar result = combine$1( Parent.prototype.data, options.data );\n\t\n\t\t\t\tif ( typeof result === 'function' ) result = result.call( ractive );\n\t\n\t\t\t\t// bind functions to the ractive instance at the top level,\n\t\t\t\t// unless it's a non-POJO (in which case alarm bells should ring)\n\t\t\t\tif ( result && result.constructor === Object ) {\n\t\t\t\t\tfor ( var prop in result ) {\n\t\t\t\t\t\tif ( typeof result[ prop ] === 'function' ) result[ prop ] = bind( result[ prop ], ractive );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn result || {};\n\t\t\t},\n\t\n\t\t\treset: function ( ractive ) {\n\t\t\t\tvar result = this.init( ractive.constructor, ractive, ractive.viewmodel );\n\t\t\t\tractive.viewmodel.root.set( result );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\n\t\tfunction combine$1 ( parentValue, childValue ) {\n\t\t\tvalidate( childValue );\n\t\n\t\t\tvar parentIsFn = typeof parentValue === 'function';\n\t\t\tvar childIsFn = typeof childValue === 'function';\n\t\n\t\t\t// Very important, otherwise child instance can become\n\t\t\t// the default data object on Ractive or a component.\n\t\t\t// then ractive.set() ends up setting on the prototype!\n\t\t\tif ( !childValue && !parentIsFn ) {\n\t\t\t\tchildValue = {};\n\t\t\t}\n\t\n\t\t\t// Fast path, where we just need to copy properties from\n\t\t\t// parent to child\n\t\t\tif ( !parentIsFn && !childIsFn ) {\n\t\t\t\treturn fromProperties( childValue, parentValue );\n\t\t\t}\n\t\n\t\t\treturn function () {\n\t\t\t\tvar child = childIsFn ? callDataFunction( childValue, this ) : childValue;\n\t\t\t\tvar parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;\n\t\n\t\t\t\treturn fromProperties( child, parent );\n\t\t\t};\n\t\t}\n\t\n\t\tfunction callDataFunction ( fn, context ) {\n\t\t\tvar data = fn.call( context );\n\t\n\t\t\tif ( !data ) return;\n\t\n\t\t\tif ( typeof data !== 'object' ) {\n\t\t\t\tfatal( 'Data function must return an object' );\n\t\t\t}\n\t\n\t\t\tif ( data.constructor !== Object ) {\n\t\t\t\twarnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\t}\n\t\n\t\tfunction fromProperties ( primary, secondary ) {\n\t\t\tif ( primary && secondary ) {\n\t\t\t\tfor ( var key in secondary ) {\n\t\t\t\t\tif ( !( key in primary ) ) {\n\t\t\t\t\t\tprimary[ key ] = secondary[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn primary;\n\t\t\t}\n\t\n\t\t\treturn primary || secondary;\n\t\t}\n\t\n\t\tvar TEMPLATE_VERSION = 4;\n\t\n\t\tvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\t\n\t\tfunction fromExpression ( body, length ) {\n\t\t\tif ( length === void 0 ) length = 0;\n\t\n\t\t\tvar args = new Array( length );\n\t\n\t\t\twhile ( length-- ) {\n\t\t\t\targs[length] = \"_\" + length;\n\t\t\t}\n\t\n\t\t\t// Functions created directly with new Function() look like this:\n\t\t\t//     function anonymous (_0 /**/) { return _0*2 }\n\t\t\t//\n\t\t\t// With this workaround, we get a little more compact:\n\t\t\t//     function (_0){return _0*2}\n\t\t\treturn new Function( [], (\"return function (\" + (args.join(',')) + \"){return(\" + body + \");};\") )();\n\t\t}\n\t\n\t\tfunction fromComputationString ( str, bindTo ) {\n\t\t\tvar hasThis;\n\t\n\t\t\tvar functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {\n\t\t\t\thasThis = true;\n\t\t\t\treturn (\"__ractive.get(\\\"\" + keypath + \"\\\")\");\n\t\t\t}) + ');';\n\t\n\t\t\tif ( hasThis ) functionBody = \"var __ractive = this; \" + functionBody;\n\t\t\tvar fn = new Function( functionBody );\n\t\t\treturn hasThis ? fn.bind( bindTo ) : fn;\n\t\t}\n\t\n\t\tvar functions = create( null );\n\t\n\t\tfunction getFunction ( str, i ) {\n\t\t\tif ( functions[ str ] ) return functions[ str ];\n\t\t\treturn functions[ str ] = createFunction( str, i );\n\t\t}\n\t\n\t\tfunction addFunctions( template ) {\n\t\t\tif ( !template ) return;\n\t\n\t\t\tvar exp = template.e;\n\t\n\t\t\tif ( !exp ) return;\n\t\n\t\t\tObject.keys( exp ).forEach( function ( str ) {\n\t\t\t\tif ( functions[ str ] ) return;\n\t\t\t\tfunctions[ str ] = exp[ str ];\n\t\t\t});\n\t\t}\n\t\n\t\tvar Parser;\n\t\tvar ParseError;\n\t\tvar leadingWhitespace = /^\\s+/;\n\t\tParseError = function ( message ) {\n\t\t\tthis.name = 'ParseError';\n\t\t\tthis.message = message;\n\t\t\ttry {\n\t\t\t\tthrow new Error(message);\n\t\t\t} catch (e) {\n\t\t\t\tthis.stack = e.stack;\n\t\t\t}\n\t\t};\n\t\n\t\tParseError.prototype = Error.prototype;\n\t\n\t\tParser = function ( str, options ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\tvar items, item, lineStart = 0;\n\t\n\t\t\tthis.str = str;\n\t\t\tthis.options = options || {};\n\t\t\tthis.pos = 0;\n\t\n\t\t\tthis.lines = this.str.split( '\\n' );\n\t\t\tthis.lineEnds = this.lines.map( function ( line ) {\n\t\t\t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\t\n\t\t\t\tlineStart = lineEnd;\n\t\t\t\treturn lineEnd;\n\t\t\t}, 0 );\n\t\n\t\t\t// Custom init logic\n\t\t\tif ( this.init ) this.init( str, options );\n\t\n\t\t\titems = [];\n\t\n\t\t\twhile ( ( this$1.pos < this$1.str.length ) && ( item = this$1.read() ) ) {\n\t\t\t\titems.push( item );\n\t\t\t}\n\t\n\t\t\tthis.leftover = this.remaining();\n\t\t\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n\t\t};\n\t\n\t\tParser.prototype = {\n\t\t\tread: function ( converters ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar pos, i, len, item;\n\t\n\t\t\t\tif ( !converters ) converters = this.converters;\n\t\n\t\t\t\tpos = this.pos;\n\t\n\t\t\t\tlen = converters.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tthis$1.pos = pos; // reset for each attempt\n\t\n\t\t\t\t\tif ( item = converters[i]( this$1 ) ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\t\t},\n\t\n\t\t\tgetContextMessage: function ( pos, message ) {\n\t\t\t\tvar ref = this.getLinePos( pos ), lineNum = ref[0], columnNum = ref[1];\n\t\t\t\tif ( this.options.contextLines === -1 ) {\n\t\t\t\t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum) ];\n\t\t\t\t}\n\t\n\t\t\t\tvar line = this.lines[ lineNum - 1 ];\n\t\n\t\t\t\tvar contextUp = '';\n\t\t\t\tvar contextDown = '';\n\t\t\t\tif ( this.options.contextLines ) {\n\t\t\t\t\tvar start = lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n\t\t\t\t\tcontextUp = this.lines.slice( start, lineNum - 1 - start ).join( '\\n' ).replace( /\\t/g, '  ' );\n\t\t\t\t\tcontextDown = this.lines.slice( lineNum, lineNum + this.options.contextLines ).join( '\\n' ).replace( /\\t/g, '  ' );\n\t\t\t\t\tif ( contextUp ) {\n\t\t\t\t\t\tcontextUp += '\\n';\n\t\t\t\t\t}\n\t\t\t\t\tif ( contextDown ) {\n\t\t\t\t\t\tcontextDown = '\\n' + contextDown;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar numTabs = 0;\n\t\t\t\tvar annotation = contextUp + line.replace( /\\t/g, function ( match, char ) {\n\t\t\t\t\tif ( char < columnNum ) {\n\t\t\t\t\t\tnumTabs += 1;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn '  ';\n\t\t\t\t}) + '\\n' + new Array( columnNum + numTabs ).join( ' ' ) + '^----' + contextDown;\n\t\n\t\t\t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation) ];\n\t\t\t},\n\t\n\t\t\tgetLinePos: function ( char ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar lineNum = 0, lineStart = 0, columnNum;\n\t\n\t\t\t\twhile ( char >= this$1.lineEnds[ lineNum ] ) {\n\t\t\t\t\tlineStart = this$1.lineEnds[ lineNum ];\n\t\t\t\t\tlineNum += 1;\n\t\t\t\t}\n\t\n\t\t\t\tcolumnNum = char - lineStart;\n\t\t\t\treturn [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!\n\t\t\t},\n\t\n\t\t\terror: function ( message ) {\n\t\t\t\tvar ref = this.getContextMessage( this.pos, message ), lineNum = ref[0], columnNum = ref[1], msg = ref[2];\n\t\n\t\t\t\tvar error = new ParseError( msg );\n\t\n\t\t\t\terror.line = lineNum;\n\t\t\t\terror.character = columnNum;\n\t\t\t\terror.shortMessage = message;\n\t\n\t\t\t\tthrow error;\n\t\t\t},\n\t\n\t\t\tmatchString: function ( string ) {\n\t\t\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\t\t\tthis.pos += string.length;\n\t\t\t\t\treturn string;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tmatchPattern: function ( pattern ) {\n\t\t\t\tvar match;\n\t\n\t\t\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\t\t\tthis.pos += match[0].length;\n\t\t\t\t\treturn match[1] || match[0];\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tallowWhitespace: function () {\n\t\t\t\tthis.matchPattern( leadingWhitespace );\n\t\t\t},\n\t\n\t\t\tremaining: function () {\n\t\t\t\treturn this.str.substring( this.pos );\n\t\t\t},\n\t\n\t\t\tnextChar: function () {\n\t\t\t\treturn this.str.charAt( this.pos );\n\t\t\t}\n\t\t};\n\t\n\t\tParser.extend = function ( proto ) {\n\t\t\tvar Parent = this, Child, key;\n\t\n\t\t\tChild = function ( str, options ) {\n\t\t\t\tParser.call( this, str, options );\n\t\t\t};\n\t\n\t\t\tChild.prototype = create( Parent.prototype );\n\t\n\t\t\tfor ( key in proto ) {\n\t\t\t\tif ( hasOwn.call( proto, key ) ) {\n\t\t\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tChild.extend = Parser.extend;\n\t\t\treturn Child;\n\t\t};\n\t\n\t\tvar Parser$1 = Parser;\n\t\n\t\tvar TEXT              = 1;\n\t\tvar INTERPOLATOR      = 2;\n\t\tvar TRIPLE            = 3;\n\t\tvar SECTION           = 4;\n\t\tvar INVERTED          = 5;\n\t\tvar CLOSING           = 6;\n\t\tvar ELEMENT           = 7;\n\t\tvar PARTIAL           = 8;\n\t\tvar COMMENT           = 9;\n\t\tvar DELIMCHANGE       = 10;\n\t\tvar ATTRIBUTE         = 13;\n\t\tvar CLOSING_TAG       = 14;\n\t\tvar COMPONENT         = 15;\n\t\tvar YIELDER           = 16;\n\t\tvar INLINE_PARTIAL    = 17;\n\t\tvar DOCTYPE           = 18;\n\t\tvar ALIAS             = 19;\n\t\n\t\tvar NUMBER_LITERAL    = 20;\n\t\tvar STRING_LITERAL    = 21;\n\t\tvar ARRAY_LITERAL     = 22;\n\t\tvar OBJECT_LITERAL    = 23;\n\t\tvar BOOLEAN_LITERAL   = 24;\n\t\tvar REGEXP_LITERAL    = 25;\n\t\n\t\tvar GLOBAL            = 26;\n\t\tvar KEY_VALUE_PAIR    = 27;\n\t\n\t\n\t\tvar REFERENCE         = 30;\n\t\tvar REFINEMENT        = 31;\n\t\tvar MEMBER            = 32;\n\t\tvar PREFIX_OPERATOR   = 33;\n\t\tvar BRACKETED         = 34;\n\t\tvar CONDITIONAL       = 35;\n\t\tvar INFIX_OPERATOR    = 36;\n\t\n\t\tvar INVOCATION        = 40;\n\t\n\t\tvar SECTION_IF        = 50;\n\t\tvar SECTION_UNLESS    = 51;\n\t\tvar SECTION_EACH      = 52;\n\t\tvar SECTION_WITH      = 53;\n\t\tvar SECTION_IF_WITH   = 54;\n\t\n\t\tvar ELSE              = 60;\n\t\tvar ELSEIF            = 61;\n\t\n\t\tvar EVENT             = 70;\n\t\tvar DECORATOR         = 71;\n\t\tvar TRANSITION        = 72;\n\t\tvar BINDING_FLAG      = 73;\n\t\n\t\tvar delimiterChangePattern = /^[^\\s=]+/;\n\t\tvar whitespacePattern = /^\\s+/;\n\t\tfunction readDelimiterChange ( parser ) {\n\t\t\tvar start, opening, closing;\n\t\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\t// allow whitespace before new opening delimiter\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\topening = parser.matchPattern( delimiterChangePattern );\n\t\t\tif ( !opening ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// allow whitespace (in fact, it's necessary...)\n\t\t\tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tclosing = parser.matchPattern( delimiterChangePattern );\n\t\t\tif ( !closing ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// allow whitespace before closing '='\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\treturn [ opening, closing ];\n\t\t}\n\t\n\t\tvar regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\t\n\t\tfunction readNumberLiteral ( parser ) {\n\t\t\tvar result;\n\t\n\t\t\tif ( result = parser.matchPattern( regexpPattern ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: REGEXP_LITERAL,\n\t\t\t\t\tv: result\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tvar pattern$1 = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\t\n\t\tfunction escapeRegExp ( str ) {\n\t\t\treturn str.replace( pattern$1, '\\\\$&' );\n\t\t}\n\t\n\t\tvar regExpCache = {};\n\t\n\t\tfunction getLowestIndex ( haystack, needles ) {\n\t\t\treturn haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) );\n\t\t}\n\t\n\t\t// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n\t\tvar booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n\t\tvar voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\t\n\t\tvar htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830\t};\n\t\tvar controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];\n\t\tvar entityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\t\tvar codePointSupport = typeof String.fromCodePoint === 'function';\n\t\tvar codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\t\n\t\tfunction decodeCharacterReferences ( html ) {\n\t\t\treturn html.replace( entityPattern, function ( match, entity ) {\n\t\t\t\tvar code;\n\t\n\t\t\t\t// Handle named entities\n\t\t\t\tif ( entity[0] !== '#' ) {\n\t\t\t\t\tcode = htmlEntities[ entity ];\n\t\t\t\t} else if ( entity[1] === 'x' ) {\n\t\t\t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t\t\t\t} else {\n\t\t\t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t\t\t\t}\n\t\n\t\t\t\tif ( !code ) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\n\t\t\t\treturn codeToChar( validateCode( code ) );\n\t\t\t});\n\t\t}\n\t\n\t\tvar lessThan = /</g;\n\t\tvar greaterThan = />/g;\n\t\tvar amp = /&/g;\n\t\tvar invalid = 65533;\n\t\n\t\tfunction escapeHtml ( str ) {\n\t\t\treturn str\n\t\t\t\t.replace( amp, '&amp;' )\n\t\t\t\t.replace( lessThan, '&lt;' )\n\t\t\t\t.replace( greaterThan, '&gt;' );\n\t\t}\n\t\n\t\t// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n\t\t// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n\t\t// to replace them ourselves\n\t\t//\n\t\t// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\t\tfunction validateCode ( code ) {\n\t\t\tif ( !code ) {\n\t\t\t\treturn invalid;\n\t\t\t}\n\t\n\t\t\t// line feed becomes generic whitespace\n\t\t\tif ( code === 10 ) {\n\t\t\t\treturn 32;\n\t\t\t}\n\t\n\t\t\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\t\t\tif ( code < 128 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\n\t\t\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t\t\t// to correct the mistake or we'll end up with missing  signs and so on\n\t\t\tif ( code <= 159 ) {\n\t\t\t\treturn controlCharacters[ code - 128 ];\n\t\t\t}\n\t\n\t\t\t// basic multilingual plane\n\t\t\tif ( code < 55296 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\n\t\t\t// UTF-16 surrogate halves\n\t\t\tif ( code <= 57343 ) {\n\t\t\t\treturn invalid;\n\t\t\t}\n\t\n\t\t\t// rest of the basic multilingual plane\n\t\t\tif ( code <= 65535 ) {\n\t\t\t\treturn code;\n\t\t\t} else if ( !codePointSupport ) {\n\t\t\t\treturn invalid;\n\t\t\t}\n\t\n\t\t\t// supplementary multilingual plane 0x10000 - 0x1ffff\n\t\t\tif ( code >= 65536 && code <= 131071 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\n\t\t\t// supplementary ideographic plane 0x20000 - 0x2ffff\n\t\t\tif ( code >= 131072 && code <= 196607 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\n\t\t\treturn invalid;\n\t\t}\n\t\n\t\tvar expectedExpression = 'Expected a JavaScript expression';\n\t\tvar expectedParen = 'Expected closing paren';\n\t\n\t\t// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\n\t\tvar numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\n\t\tfunction readNumberLiteral$1 ( parser ) {\n\t\t\tvar result;\n\t\n\t\t\tif ( result = parser.matchPattern( numberPattern ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: NUMBER_LITERAL,\n\t\t\t\t\tv: result\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction readBooleanLiteral ( parser ) {\n\t\t\tvar remaining = parser.remaining();\n\t\n\t\t\tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t\t\t\tparser.pos += 4;\n\t\t\t\treturn {\n\t\t\t\t\tt: BOOLEAN_LITERAL,\n\t\t\t\t\tv: 'true'\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t\t\t\tparser.pos += 5;\n\t\t\t\treturn {\n\t\t\t\t\tt: BOOLEAN_LITERAL,\n\t\t\t\t\tv: 'false'\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tvar stringMiddlePattern;\n\t\tvar escapeSequencePattern;\n\t\tvar lineContinuationPattern;\n\t\t// Match one or more characters until: \", ', \\, or EOL/EOF.\n\t\t// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n\t\tstringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\t\n\t\t// Match one escape sequence, including the backslash.\n\t\tescapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\t\n\t\t// Match one ES5 line continuation (backslash + line terminator).\n\t\tlineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\t\n\t\t// Helper for defining getDoubleQuotedString and getSingleQuotedString.\n\t\tfunction makeQuotedStringMatcher ( okQuote ) {\n\t\t\treturn function ( parser ) {\n\t\t\t\tvar literal = '\"';\n\t\t\t\tvar done = false;\n\t\t\t\tvar next;\n\t\n\t\t\t\twhile ( !done ) {\n\t\t\t\t\tnext = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||\n\t\t\t\t\t\tparser.matchString( okQuote ) );\n\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\tif ( next === (\"\\\"\") ) {\n\t\t\t\t\t\t\tliteral += \"\\\\\\\"\";\n\t\t\t\t\t\t} else if ( next === (\"\\\\'\") ) {\n\t\t\t\t\t\t\tliteral += \"'\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tliteral += next;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t\t\t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tliteral += '\"';\n\t\n\t\t\t\t// use JSON.parse to interpret escapes\n\t\t\t\treturn JSON.parse( literal );\n\t\t\t};\n\t\t}\n\t\n\t\tvar getSingleQuotedString = makeQuotedStringMatcher( (\"\\\"\") );\n\t\tvar getDoubleQuotedString = makeQuotedStringMatcher( (\"'\") );\n\t\n\t\tfunction readStringLiteral ( parser ) {\n\t\t\tvar start, string;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tif ( parser.matchString( '\"' ) ) {\n\t\t\t\tstring = getDoubleQuotedString( parser );\n\t\n\t\t\t\tif ( !parser.matchString( '\"' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\tt: STRING_LITERAL,\n\t\t\t\t\tv: string\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tif ( parser.matchString( (\"'\") ) ) {\n\t\t\t\tstring = getSingleQuotedString( parser );\n\t\n\t\t\t\tif ( !parser.matchString( (\"'\") ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\tt: STRING_LITERAL,\n\t\t\t\t\tv: string\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tvar namePattern = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\t\n\t\tvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\t\n\t\t// http://mathiasbynens.be/notes/javascript-properties\n\t\t// can be any name, string literal, or number literal\n\t\tfunction readKey ( parser ) {\n\t\t\tvar token;\n\t\n\t\t\tif ( token = readStringLiteral( parser ) ) {\n\t\t\t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t\t\t}\n\t\n\t\t\tif ( token = readNumberLiteral$1( parser ) ) {\n\t\t\t\treturn token.v;\n\t\t\t}\n\t\n\t\t\tif ( token = parser.matchPattern( namePattern ) ) {\n\t\t\t\treturn token;\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction readKeyValuePair ( parser ) {\n\t\t\tvar start, key, value;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\t// allow whitespace between '{' and key\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tvar refKey = parser.nextChar() !== '\\'' && parser.nextChar() !== '\"';\n\t\n\t\t\tkey = readKey( parser );\n\t\t\tif ( key === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// allow whitespace between key and ':'\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\t// es2015 shorthand property\n\t\t\tif ( refKey && ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {\n\t\t\t\tif ( !namePattern.test( key ) ) {\n\t\t\t\t\tparser.error( (\"Expected a valid reference, but found '\" + key + \"' instead.\") );\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\tt: KEY_VALUE_PAIR,\n\t\t\t\t\tk: key,\n\t\t\t\t\tv: {\n\t\t\t\t\t\tt: REFERENCE,\n\t\t\t\t\t\tn: key\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// next character must be ':'\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// allow whitespace between ':' and value\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\t// next expression must be a, well... expression\n\t\t\tvalue = readExpression( parser );\n\t\t\tif ( value === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tt: KEY_VALUE_PAIR,\n\t\t\t\tk: key,\n\t\t\t\tv: value\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readKeyValuePairs ( parser ) {\n\t\t\tvar start, pairs, pair, keyValuePairs;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tpair = readKeyValuePair( parser );\n\t\t\tif ( pair === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tpairs = [ pair ];\n\t\n\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\tkeyValuePairs = readKeyValuePairs( parser );\n\t\n\t\t\t\tif ( !keyValuePairs ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\treturn pairs.concat( keyValuePairs );\n\t\t\t}\n\t\n\t\t\treturn pairs;\n\t\t}\n\t\n\t\tfunction readObjectLiteral ( parser ) {\n\t\t\tvar start, keyValuePairs;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\t// allow whitespace\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tkeyValuePairs = readKeyValuePairs( parser );\n\t\n\t\t\t// allow whitespace between final value and '}'\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( '}' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tt: OBJECT_LITERAL,\n\t\t\t\tm: keyValuePairs\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readExpressionList ( parser ) {\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tvar expr = readExpression( parser );\n\t\n\t\t\tif ( expr === null ) return null;\n\t\n\t\t\tvar expressions = [ expr ];\n\t\n\t\t\t// allow whitespace between expression and ','\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\tvar next = readExpressionList( parser );\n\t\t\t\tif ( next === null ) parser.error( expectedExpression );\n\t\n\t\t\t\texpressions.push.apply( expressions, next );\n\t\t\t}\n\t\n\t\t\treturn expressions;\n\t\t}\n\t\n\t\tfunction readArrayLiteral ( parser ) {\n\t\t\tvar start, expressionList;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\t// allow whitespace before '['\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\texpressionList = readExpressionList( parser );\n\t\n\t\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tt: ARRAY_LITERAL,\n\t\t\t\tm: expressionList\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readLiteral ( parser ) {\n\t\t\treturn readNumberLiteral$1( parser )  ||\n\t\t\t       readBooleanLiteral( parser ) ||\n\t\t\t       readStringLiteral( parser )  ||\n\t\t\t       readObjectLiteral( parser )  ||\n\t\t\t       readArrayLiteral( parser )   ||\n\t\t\t       readNumberLiteral( parser );\n\t\t}\n\t\n\t\tvar prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\n\t\tvar globals;\n\t\tvar keywords;\n\t\t// if a reference is a browser global, we don't deference it later, so it needs special treatment\n\t\tglobals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/;\n\t\n\t\t// keywords are not valid references, with the exception of `this`\n\t\tkeywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\t\n\t\tvar legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n\t\tvar relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*/;\n\t\tvar specials = /^@(?:keypath|rootpath|index|key|this|global)/;\n\t\tvar specialCall = /^\\s*\\(/;\n\t\tvar spreadPattern = /^\\s*\\.{3}/;\n\t\n\t\tfunction readReference ( parser ) {\n\t\t\tvar startPos, prefix, name, global, reference, fullLength, lastDotIndex, spread;\n\t\n\t\t\tstartPos = parser.pos;\n\t\n\t\t\tname = parser.matchPattern( specials );\n\t\n\t\t\tif ( name === '@keypath' || name === '@rootpath' ) {\n\t\t\t\tif ( parser.matchPattern( specialCall ) ) {\n\t\t\t\t\tvar ref = readReference( parser );\n\t\t\t\t\tif ( !ref ) parser.error( (\"Expected a valid reference for a keypath expression\") );\n\t\n\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\tif ( !parser.matchString( ')' ) ) parser.error( (\"Unclosed keypath expression\") );\n\t\t\t\t\tname += \"(\" + (ref.n) + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tspread = !name && parser.spreadArgs && parser.matchPattern( spreadPattern );\n\t\n\t\t\tif ( !name ) {\n\t\t\t\tprefix = parser.matchPattern( prefixPattern ) || '';\n\t\t\t\tname = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||\n\t\t\t\t       parser.matchPattern( legalReference );\n\t\n\t\t\t\tif ( !name && prefix === '.' ) {\n\t\t\t\t\tprefix = '';\n\t\t\t\t\tname = '.';\n\t\t\t\t} else if ( !name && prefix ) {\n\t\t\t\t\tname = prefix;\n\t\t\t\t\tprefix = '';\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !name ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n\t\t\tif ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {\n\t\t\t\tparser.pos = startPos;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// if this is a browser global, stop here\n\t\t\tif ( !prefix && globals.test( name ) ) {\n\t\t\t\tglobal = globals.exec( name )[0];\n\t\t\t\tparser.pos = startPos + global.length;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tt: GLOBAL,\n\t\t\t\t\tv: ( spread ? '...' : '' ) + global\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tfullLength = ( spread ? 3 : 0 ) + ( prefix || '' ).length + name.length;\n\t\t\treference = ( prefix || '' ) + normalise( name );\n\t\n\t\t\tif ( parser.matchString( '(' ) ) {\n\t\t\t\t// if this is a method invocation (as opposed to a function) we need\n\t\t\t\t// to strip the method name from the reference combo, else the context\n\t\t\t\t// will be wrong\n\t\t\t\t// but only if the reference was actually a member and not a refinement\n\t\t\t\tlastDotIndex = reference.lastIndexOf( '.' );\n\t\t\t\tif ( lastDotIndex !== -1 && name[ name.length - 1 ] !== ']' ) {\n\t\t\t\t\tvar refLength = reference.length;\n\t\t\t\t\treference = reference.substr( 0, lastDotIndex );\n\t\t\t\t\tparser.pos = startPos + (fullLength - ( refLength - lastDotIndex ) );\n\t\t\t\t} else {\n\t\t\t\t\tparser.pos -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tt: REFERENCE,\n\t\t\t\tn: ( spread ? '...' : '' ) + reference.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readBracketedExpression ( parser ) {\n\t\t\tif ( !parser.matchString( '(' ) ) return null;\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tvar expr = readExpression( parser );\n\t\n\t\t\tif ( !expr ) parser.error( expectedExpression );\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( ')' ) ) parser.error( expectedParen );\n\t\n\t\t\treturn {\n\t\t\t\tt: BRACKETED,\n\t\t\t\tx: expr\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readPrimary ( parser ) {\n\t\t\treturn readLiteral( parser )\n\t\t\t\t|| readReference( parser )\n\t\t\t\t|| readBracketedExpression( parser );\n\t\t}\n\t\n\t\tfunction readRefinement ( parser ) {\n\t\t\t// some things call for strict refinement (partial names), meaning no space between reference and refinement\n\t\t\tif ( !parser.strictRefinement ) {\n\t\t\t\tparser.allowWhitespace();\n\t\t\t}\n\t\n\t\t\t// \".\" name\n\t\t\tif ( parser.matchString( '.' ) ) {\n\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\tvar name = parser.matchPattern( namePattern );\n\t\t\t\tif ( name ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: REFINEMENT,\n\t\t\t\t\t\tn: name\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\tparser.error( 'Expected a property name' );\n\t\t\t}\n\t\n\t\t\t// \"[\" expression \"]\"\n\t\t\tif ( parser.matchString( '[' ) ) {\n\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\tvar expr = readExpression( parser );\n\t\t\t\tif ( !expr ) parser.error( expectedExpression );\n\t\n\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\tif ( !parser.matchString( ']' ) ) parser.error( (\"Expected ']'\") );\n\t\n\t\t\t\treturn {\n\t\t\t\t\tt: REFINEMENT,\n\t\t\t\t\tx: expr\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction readMemberOrInvocation ( parser ) {\n\t\t\tvar expression = readPrimary( parser );\n\t\n\t\t\tif ( !expression ) return null;\n\t\n\t\t\twhile ( expression ) {\n\t\t\t\tvar refinement = readRefinement( parser );\n\t\t\t\tif ( refinement ) {\n\t\t\t\t\texpression = {\n\t\t\t\t\t\tt: MEMBER,\n\t\t\t\t\t\tx: expression,\n\t\t\t\t\t\tr: refinement\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\telse if ( parser.matchString( '(' ) ) {\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tvar start = parser.spreadArgs;\n\t\t\t\t\tparser.spreadArgs = true;\n\t\t\t\t\tvar expressionList = readExpressionList( parser );\n\t\t\t\t\tparser.spreadArgs = start;\n\t\n\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\t\t\tparser.error( expectedParen );\n\t\t\t\t\t}\n\t\n\t\t\t\t\texpression = {\n\t\t\t\t\t\tt: INVOCATION,\n\t\t\t\t\t\tx: expression\n\t\t\t\t\t};\n\t\n\t\t\t\t\tif ( expressionList ) expression.o = expressionList;\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn expression;\n\t\t}\n\t\n\t\tvar readTypeOf;\n\t\tvar makePrefixSequenceMatcher;\n\t\tmakePrefixSequenceMatcher = function ( symbol, fallthrough ) {\n\t\t\treturn function ( parser ) {\n\t\t\t\tvar expression;\n\t\n\t\t\t\tif ( expression = fallthrough( parser ) ) {\n\t\t\t\t\treturn expression;\n\t\t\t\t}\n\t\n\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\texpression = readExpression( parser );\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\tparser.error( expectedExpression );\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\ts: symbol,\n\t\t\t\t\to: expression,\n\t\t\t\t\tt: PREFIX_OPERATOR\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\n\t\t// create all prefix sequence matchers, return readTypeOf\n\t\t(function() {\n\t\t\tvar i, len, matcher, prefixOperators, fallthrough;\n\t\n\t\t\tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\t\n\t\t\tfallthrough = readMemberOrInvocation;\n\t\t\tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t\t\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );\n\t\t\t\tfallthrough = matcher;\n\t\t\t}\n\t\n\t\t\t// typeof operator is higher precedence than multiplication, so provides the\n\t\t\t// fallthrough for the multiplication sequence matcher we're about to create\n\t\t\t// (we're skipping void and delete)\n\t\t\treadTypeOf = fallthrough;\n\t\t}());\n\t\n\t\tvar readTypeof = readTypeOf;\n\t\n\t\tvar readLogicalOr;\n\t\tvar makeInfixSequenceMatcher;\n\t\tmakeInfixSequenceMatcher = function ( symbol, fallthrough ) {\n\t\t\treturn function ( parser ) {\n\t\t\t\tvar start, left, right;\n\t\n\t\t\t\tleft = fallthrough( parser );\n\t\t\t\tif ( !left ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t\t\t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t\t\t\t// to parse `left` because that would be infinite regress.\n\t\t\t\twhile ( true ) {\n\t\t\t\t\tstart = parser.pos;\n\t\n\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t\t\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\t// right operand must also consist of only higher-precedence operators\n\t\t\t\t\tright = fallthrough( parser );\n\t\t\t\t\tif ( !right ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tleft = {\n\t\t\t\t\t\tt: INFIX_OPERATOR,\n\t\t\t\t\t\ts: symbol,\n\t\t\t\t\t\to: [ left, right ]\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n\t\t\t\t\t// we'll return left.\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\n\t\t// create all infix sequence matchers, and return readLogicalOr\n\t\t(function() {\n\t\t\tvar i, len, matcher, infixOperators, fallthrough;\n\t\n\t\t\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t\t\t// Each sequence matcher will initially fall through to its higher precedence\n\t\t\t// neighbour, and only attempt to match if one of the higher precedence operators\n\t\t\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\t\t\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\t\n\t\t\t// A typeof operator is higher precedence than multiplication\n\t\t\tfallthrough = readTypeof;\n\t\t\tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t\t\t\tmatcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );\n\t\t\t\tfallthrough = matcher;\n\t\t\t}\n\t\n\t\t\t// Logical OR is the fallthrough for the conditional matcher\n\t\t\treadLogicalOr = fallthrough;\n\t\t}());\n\t\n\t\tvar readLogicalOr$1 = readLogicalOr;\n\t\n\t\t// The conditional operator is the lowest precedence operator, so we start here\n\t\tfunction getConditional ( parser ) {\n\t\t\tvar start, expression, ifTrue, ifFalse;\n\t\n\t\t\texpression = readLogicalOr$1( parser );\n\t\t\tif ( !expression ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( '?' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn expression;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tifTrue = readExpression( parser );\n\t\t\tif ( !ifTrue ) {\n\t\t\t\tparser.error( expectedExpression );\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\tparser.error( 'Expected \":\"' );\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tifFalse = readExpression( parser );\n\t\t\tif ( !ifFalse ) {\n\t\t\t\tparser.error( expectedExpression );\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tt: CONDITIONAL,\n\t\t\t\to: [ expression, ifTrue, ifFalse ]\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readExpression ( parser ) {\n\t\t\t// The conditional operator is the lowest precedence operator (except yield,\n\t\t\t// assignment operators, and commas, none of which are supported), so we\n\t\t\t// start there. If it doesn't match, it 'falls through' to progressively\n\t\t\t// higher precedence operators, until it eventually matches (or fails to\n\t\t\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t\t\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\t\t\treturn getConditional( parser );\n\t\t}\n\t\n\t\tfunction flattenExpression ( expression ) {\n\t\t\tvar refs, count = 0, stringified;\n\t\n\t\t\textractRefs( expression, refs = [] );\n\t\t\tstringified = stringify( expression );\n\t\n\t\t\trefs = refs.map( function ( r ) { return r.indexOf( '...' ) === 0 ? r.substr( 3 ) : r; } );\n\t\n\t\t\treturn {\n\t\t\t\tr: refs,\n\t\t\t\ts: getVars(stringified)\n\t\t\t};\n\t\n\t\t\tfunction getVars(expr) {\n\t\t\t\tvar vars = [];\n\t\t\t\tfor ( var i = count - 1; i >= 0; i-- ) {\n\t\t\t\t\tvars.push( (\"spread$\" + i) );\n\t\t\t\t}\n\t\t\t\treturn vars.length ? (\"(function(){var \" + (vars.join(',')) + \";return(\" + expr + \");})()\") : expr;\n\t\t\t}\n\t\n\t\t\tfunction stringify ( node ) {\n\t\t\t\tswitch ( node.t ) {\n\t\t\t\t\tcase BOOLEAN_LITERAL:\n\t\t\t\t\tcase GLOBAL:\n\t\t\t\t\tcase NUMBER_LITERAL:\n\t\t\t\t\tcase REGEXP_LITERAL:\n\t\t\t\t\t\treturn node.v;\n\t\n\t\t\t\t\tcase STRING_LITERAL:\n\t\t\t\t\t\treturn JSON.stringify( String( node.v ) );\n\t\n\t\t\t\t\tcase ARRAY_LITERAL:\n\t\t\t\t\t\treturn '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';\n\t\n\t\t\t\t\tcase OBJECT_LITERAL:\n\t\t\t\t\t\treturn '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';\n\t\n\t\t\t\t\tcase KEY_VALUE_PAIR:\n\t\t\t\t\t\treturn node.k + ':' + stringify( node.v );\n\t\n\t\t\t\t\tcase PREFIX_OPERATOR:\n\t\t\t\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );\n\t\n\t\t\t\t\tcase INFIX_OPERATOR:\n\t\t\t\t\t\treturn stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );\n\t\n\t\t\t\t\tcase INVOCATION:\n\t\t\t\t\t\tif ( node.spread ) {\n\t\t\t\t\t\t\tvar id = count++;\n\t\t\t\t\t\t\treturn (\"(spread$\" + id + \" = \" + (stringify(node.x)) + \").apply(spread$\" + id + \", [].concat(\" + (node.o ? node.o.map( function ( a ) { return a.n && a.n.indexOf( '...' ) === 0 ? stringify( a ) : '[' + stringify(a) + ']'; } ).join( ',' ) : '') + \") )\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\tcase BRACKETED:\n\t\t\t\t\t\treturn '(' + stringify( node.x ) + ')';\n\t\n\t\t\t\t\tcase MEMBER:\n\t\t\t\t\t\treturn stringify( node.x ) + stringify( node.r );\n\t\n\t\t\t\t\tcase REFINEMENT:\n\t\t\t\t\t\treturn ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );\n\t\n\t\t\t\t\tcase CONDITIONAL:\n\t\t\t\t\t\treturn stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );\n\t\n\t\t\t\t\tcase REFERENCE:\n\t\t\t\t\t\treturn '_' + refs.indexOf( node.n );\n\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'Expected legal JavaScript' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// TODO maybe refactor this?\n\t\tfunction extractRefs ( node, refs ) {\n\t\t\tvar i, list;\n\t\n\t\t\tif ( node.t === REFERENCE ) {\n\t\t\t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t\t\t\t\trefs.unshift( node.n );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tlist = node.o || node.m;\n\t\t\tif ( list ) {\n\t\t\t\tif ( isObject( list ) ) {\n\t\t\t\t\textractRefs( list, refs );\n\t\t\t\t} else {\n\t\t\t\t\ti = list.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( list[i].n && list[i].n.indexOf('...') === 0 ) {\n\t\t\t\t\t\t\tnode.spread = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\textractRefs( list[i], refs );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( node.x ) {\n\t\t\t\textractRefs( node.x, refs );\n\t\t\t}\n\t\n\t\t\tif ( node.r ) {\n\t\t\t\textractRefs( node.r, refs );\n\t\t\t}\n\t\n\t\t\tif ( node.v ) {\n\t\t\t\textractRefs( node.v, refs );\n\t\t\t}\n\t\t}\n\t\n\t\t// simple JSON parser, without the restrictions of JSON parse\n\t\t// (i.e. having to double-quote keys).\n\t\t//\n\t\t// If passed a hash of values as the second argument, ${placeholders}\n\t\t// will be replaced with those values\n\t\n\t\tvar specials$1 = {\n\t\t\t'true': true,\n\t\t\t'false': false,\n\t\t\t'null': null,\n\t\t\tundefined: undefined\n\t\t};\n\t\n\t\tvar specialsPattern = new RegExp( '^(?:' + Object.keys( specials$1 ).join( '|' ) + ')' );\n\t\tvar numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\tvar placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n\t\tvar placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n\t\tvar onlyWhitespace = /^\\s*$/;\n\t\n\t\tvar JsonParser = Parser$1.extend({\n\t\t\tinit: function ( str, options ) {\n\t\t\t\tthis.values = options.values;\n\t\t\t\tthis.allowWhitespace();\n\t\t\t},\n\t\n\t\t\tpostProcess: function ( result ) {\n\t\t\t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\treturn { value: result[0].v };\n\t\t\t},\n\t\n\t\t\tconverters: [\n\t\t\t\tfunction getPlaceholder ( parser ) {\n\t\t\t\t\tif ( !parser.values ) return null;\n\t\n\t\t\t\t\tvar placeholder = parser.matchPattern( placeholderAtStartPattern );\n\t\n\t\t\t\t\tif ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {\n\t\t\t\t\t\treturn { v: parser.values[ placeholder ] };\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tfunction getSpecial ( parser ) {\n\t\t\t\t\tvar special = parser.matchPattern( specialsPattern );\n\t\t\t\t\tif ( special ) return { v: specials$1[ special ] };\n\t\t\t\t},\n\t\n\t\t\t\tfunction getNumber ( parser ) {\n\t\t\t\t\tvar number = parser.matchPattern( numberPattern$1 );\n\t\t\t\t\tif ( number ) return { v: +number };\n\t\t\t\t},\n\t\n\t\t\t\tfunction getString ( parser ) {\n\t\t\t\t\tvar stringLiteral = readStringLiteral( parser );\n\t\t\t\t\tvar values = parser.values;\n\t\n\t\t\t\t\tif ( stringLiteral && values ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn stringLiteral;\n\t\t\t\t},\n\t\n\t\t\t\tfunction getObject ( parser ) {\n\t\t\t\t\tif ( !parser.matchString( '{' ) ) return null;\n\t\n\t\t\t\t\tvar result = {};\n\t\n\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\treturn { v: result };\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar pair;\n\t\t\t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t\t\t\t\t\tresult[ pair.key ] = pair.value;\n\t\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\t\treturn { v: result };\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\n\t\t\t\tfunction getArray ( parser ) {\n\t\t\t\t\tif ( !parser.matchString( '[' ) ) return null;\n\t\n\t\t\t\t\tvar result = [];\n\t\n\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\treturn { v: result };\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar valueToken;\n\t\t\t\t\twhile ( valueToken = parser.read() ) {\n\t\t\t\t\t\tresult.push( valueToken.v );\n\t\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\t\treturn { v: result };\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t]\n\t\t});\n\t\n\t\tfunction getKeyValuePair ( parser ) {\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tvar key = readKey( parser );\n\t\n\t\t\tif ( !key ) return null;\n\t\n\t\t\tvar pair = { key: key };\n\t\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tvar valueToken = parser.read();\n\t\n\t\t\tif ( !valueToken ) return null;\n\t\n\t\t\tpair.value = valueToken.v;\n\t\t\treturn pair;\n\t\t}\n\t\n\t\tfunction parseJSON ( str, values ) {\n\t\t\tvar parser = new JsonParser( str, { values: values });\n\t\t\treturn parser.result;\n\t\t}\n\t\n\t\tvar methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*\\)\\s*$/;\n\t\tvar ExpressionParser;\n\t\tExpressionParser = Parser$1.extend({\n\t\t\tconverters: [ readExpression ],\n\t\t\tspreadArgs: true\n\t\t});\n\t\n\t\t// TODO clean this up, it's shocking\n\t\tfunction processDirective ( tokens, parentParser, type ) {\n\t\t\tvar result,\n\t\t\t\tmatch,\n\t\t\t\ttoken,\n\t\t\t\tcolonIndex,\n\t\t\t\tdirectiveName,\n\t\t\t\tdirectiveArgs,\n\t\t\t\tparsed;\n\t\n\t\t\tif ( typeof tokens === 'string' ) {\n\t\t\t\tvar pos = parentParser.pos - tokens.length;\n\t\t\t\tif ( type === DECORATOR || type === TRANSITION ) {\n\t\t\t\t\tvar parser = new ExpressionParser( (\"[\" + tokens + \"]\") );\n\t\t\t\t\treturn { a: flattenExpression( parser.result[0] ) };\n\t\t\t\t}\n\t\n\t\t\t\tif ( type === EVENT && ( match = methodCallPattern.exec( tokens ) ) ) {\n\t\t\t\t\twarnIfDebug( parentParser.getContextMessage( pos, (\"Unqualified method events are deprecated. Prefix methods with '@this.' to call methods on the current Ractive instance.\") )[2] );\n\t\t\t\t\ttokens = \"@this.\" + (match[1]) + \"\" + (tokens.substr(match[1].length));\n\t\t\t\t}\n\t\n\t\t\t\tif ( type === EVENT && ~tokens.indexOf( '(' ) ) {\n\t\t\t\t\tvar parser$1 = new ExpressionParser( '[' + tokens + ']' );\n\t\t\t\t\tif ( parser$1.result && parser$1.result[0] ) {\n\t\t\t\t\t\tif ( parser$1.remaining().length ) {\n\t\t\t\t\t\t\tparentParser.pos = pos + tokens.length - parser$1.remaining().length;\n\t\t\t\t\t\t\tparentParser.error( (\"Invalid input after event expression '\" + (parser$1.remaining()) + \"'\") );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { x: flattenExpression( parser$1.result[0] ) };\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( tokens.indexOf( ':' ) > tokens.indexOf( '(' ) || !~tokens.indexOf( ':' ) ) {\n\t\t\t\t\t\tparentParser.pos = pos;\n\t\t\t\t\t\tparentParser.error( (\"Invalid input in event expression '\" + tokens + \"'\") );\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t\t\t\t\treturn tokens.trim();\n\t\t\t\t}\n\t\n\t\t\t\ttokens = [ tokens ];\n\t\t\t}\n\t\n\t\t\tresult = {};\n\t\n\t\t\tdirectiveName = [];\n\t\t\tdirectiveArgs = [];\n\t\n\t\t\tif ( tokens ) {\n\t\t\t\twhile ( tokens.length ) {\n\t\t\t\t\ttoken = tokens.shift();\n\t\n\t\t\t\t\tif ( typeof token === 'string' ) {\n\t\t\t\t\t\tcolonIndex = token.indexOf( ':' );\n\t\n\t\t\t\t\t\tif ( colonIndex === -1 ) {\n\t\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// is the colon the first character?\n\t\t\t\t\t\t\tif ( colonIndex ) {\n\t\t\t\t\t\t\t\t// no\n\t\t\t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// if there is anything after the colon in this token, treat\n\t\t\t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t\t\t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t\t\t\t\t\t\t\tdirectiveArgs[0] = token.substring( colonIndex + 1 );\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t\t\t}\n\t\n\t\t\tif ( !directiveName.length ) {\n\t\t\t\tresult = '';\n\t\t\t} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t\t\t\tresult = {\n\t\t\t\t\t// TODO is this really necessary? just use the array\n\t\t\t\t\tn: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )\n\t\t\t\t};\n\t\n\t\t\t\tif ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {\n\t\t\t\t\tparsed = parseJSON( '[' + directiveArgs[0] + ']' );\n\t\t\t\t\tresult.a = parsed ? parsed.value : [ directiveArgs[0].trim() ];\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\tresult.d = directiveArgs;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = directiveName;\n\t\t\t}\n\t\n\t\t\tif ( directiveArgs.length && type ) {\n\t\t\t\twarnIfDebug( parentParser.getContextMessage( parentParser.pos, (\"Proxy events with arguments are deprecated. You can fire events with arguments using \\\"@this.fire('eventName', arg1, arg2, ...)\\\".\") )[2] );\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\tvar attributeNamePattern = /^[^\\s\"'>\\/=]+/;\n\t\tvar onPattern = /^on/;\n\t\tvar proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/;\n\t\tvar reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/;\n\t\tvar decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\n\t\tvar transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\n\t\tvar directives = {\n\t\t\t\t\t\t   'intro-outro': { t: TRANSITION, v: 't0' },\n\t\t\t\t\t\t   intro: { t: TRANSITION, v: 't1' },\n\t\t\t\t\t\t   outro: { t: TRANSITION, v: 't2' },\n\t\t\t\t\t\t   lazy: { t: BINDING_FLAG, v: 'l' },\n\t\t\t\t\t\t   twoway: { t: BINDING_FLAG, v: 't' },\n\t\t\t\t\t\t   decorator: { t: DECORATOR }\n\t\t\t\t\t\t };\n\t\tvar unquotedAttributeValueTextPattern = /^[^\\s\"'=<>\\/`]+/;\n\t\tfunction readAttribute ( parser ) {\n\t\t\tvar attr, name, value, i, nearest, idx;\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tname = parser.matchPattern( attributeNamePattern );\n\t\t\tif ( !name ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n\t\t\tnearest = name.length;\n\t\t\tfor ( i = 0; i < parser.tags.length; i++ ) {\n\t\t\t\tif ( ~( idx = name.indexOf( parser.tags[ i ].open ) ) ) {\n\t\t\t\t\tif ( idx < nearest ) nearest = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( nearest < name.length ) {\n\t\t\t\tparser.pos -= name.length - nearest;\n\t\t\t\tname = name.substr( 0, nearest );\n\t\t\t\tif ( !name ) return null;\n\t\t\t\telse return { n: name };\n\t\t\t}\n\t\n\t\t\tattr = { n: name };\n\t\n\t\t\tvalue = readAttributeValue( parser );\n\t\t\tif ( value != null ) { // not null/undefined\n\t\t\t\tattr.f = value;\n\t\t\t}\n\t\n\t\t\treturn attr;\n\t\t}\n\t\n\t\tfunction readAttributeValue ( parser ) {\n\t\t\tvar start, valueStart, startDepth, value;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\t// next character must be `=`, `/`, `>` or whitespace\n\t\t\tif ( !/[=\\/>\\s]/.test( parser.nextChar() ) ) {\n\t\t\t\tparser.error( 'Expected `=`, `/`, `>` or whitespace' );\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tvalueStart = parser.pos;\n\t\t\tstartDepth = parser.sectionDepth;\n\t\n\t\t\tvalue = readQuotedAttributeValue( parser, (\"'\") ) ||\n\t\t\t\t\treadQuotedAttributeValue( parser, (\"\\\"\") ) ||\n\t\t\t\t\treadUnquotedAttributeValue( parser );\n\t\n\t\t\tif ( value === null ) {\n\t\t\t\tparser.error( 'Expected valid attribute value' );\n\t\t\t}\n\t\n\t\t\tif ( parser.sectionDepth !== startDepth ) {\n\t\t\t\tparser.pos = valueStart;\n\t\t\t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t\t\t}\n\t\n\t\t\tif ( !value.length ) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\n\t\t\tif ( value.length === 1 && typeof value[0] === 'string' ) {\n\t\t\t\treturn decodeCharacterReferences( value[0] );\n\t\t\t}\n\t\n\t\t\treturn value;\n\t\t}\n\t\n\t\tfunction readUnquotedAttributeValueToken ( parser ) {\n\t\t\tvar start, text, haystack, needles, index;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\t\n\t\t\tif ( !text ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\thaystack = text;\n\t\t\tneedles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n\t\n\t\t\tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t\t\t\ttext = text.substr( 0, index );\n\t\t\t\tparser.pos = start + text.length;\n\t\t\t}\n\t\n\t\t\treturn text;\n\t\t}\n\t\n\t\tfunction readUnquotedAttributeValue ( parser ) {\n\t\t\tvar tokens, token;\n\t\n\t\t\tparser.inAttribute = true;\n\t\n\t\t\ttokens = [];\n\t\n\t\t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t\t\twhile ( token ) {\n\t\t\t\ttokens.push( token );\n\t\t\t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t\t\t}\n\t\n\t\t\tif ( !tokens.length ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.inAttribute = false;\n\t\t\treturn tokens;\n\t\t}\n\t\n\t\tfunction readQuotedAttributeValue ( parser, quoteMark ) {\n\t\t\tvar start, tokens, token;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.inAttribute = quoteMark;\n\t\n\t\t\ttokens = [];\n\t\n\t\t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t\t\twhile ( token !== null ) {\n\t\t\t\ttokens.push( token );\n\t\t\t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.inAttribute = false;\n\t\n\t\t\treturn tokens;\n\t\t}\n\t\n\t\tfunction readQuotedStringToken ( parser, quoteMark ) {\n\t\t\tvar haystack = parser.remaining();\n\t\n\t\t\tvar needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n\t\t\tneedles.push( quoteMark );\n\t\n\t\t\tvar index = getLowestIndex( haystack, needles );\n\t\n\t\t\tif ( index === -1 ) {\n\t\t\t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t\t\t}\n\t\n\t\t\tif ( !index ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.pos += index;\n\t\t\treturn haystack.substr( 0, index );\n\t\t}\n\t\n\t\tfunction readAttributeOrDirective ( parser ) {\n\t\t\t\tvar match,\n\t\t\t\t\tattribute,\n\t\t\t\t    directive;\n\t\n\t\t\t\tattribute = readAttribute( parser );\n\t\n\t\t\t\tif ( !attribute ) return null;\n\t\n\t\t\t\t// intro, outro, decorator\n\t\t\t\tif ( directive = directives[ attribute.n ] ) {\n\t\t\t\t\tattribute.t = directive.t;\n\t\t\t\t\tif ( directive.v ) attribute.v = directive.v;\n\t\t\t\t\tdelete attribute.n; // no name necessary\n\t\n\t\t\t\t\tif ( directive.t === TRANSITION || directive.t === DECORATOR ) attribute.f = processDirective( attribute.f, parser );\n\t\n\t\t\t\t\tif ( directive.t === TRANSITION ) {\n\t\t\t\t\t\twarnOnceIfDebug( (\"\" + (directive.v === 't0' ? 'intro-outro' : directive.v === 't1' ? 'intro' : 'outro') + \" is deprecated. To specify tranisitions, use the transition name suffixed with '-in', '-out', or '-in-out' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n\t\t\t\t\t} else if ( directive.t === DECORATOR ) {\n\t\t\t\t\t\twarnOnceIfDebug( (\"decorator is deprecated. To specify decorators, use the decorator name prefixed with 'as-' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// decorators\n\t\t\t\telse if ( match = decoratorPattern.exec( attribute.n ) ) {\n\t\t\t\t\tdelete attribute.n;\n\t\t\t\t\tattribute.t = DECORATOR;\n\t\t\t\t\tattribute.f = processDirective( attribute.f, parser, DECORATOR );\n\t\t\t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n\t\t\t\t\telse attribute.f = match[1];\n\t\t\t\t}\n\t\n\t\t\t\t// transitions\n\t\t\t\telse if ( match = transitionPattern.exec( attribute.n ) ) {\n\t\t\t\t\tdelete attribute.n;\n\t\t\t\t\tattribute.t = TRANSITION;\n\t\t\t\t\tattribute.f = processDirective( attribute.f, parser, TRANSITION );\n\t\t\t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n\t\t\t\t\telse attribute.f = match[1];\n\t\t\t\t\tattribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n\t\t\t\t}\n\t\n\t\t\t\t// on-click etc\n\t\t\t\telse if ( match = proxyEventPattern.exec( attribute.n ) ) {\n\t\t\t\t\tattribute.n = match[1];\n\t\t\t\t\tattribute.t = EVENT;\n\t\t\t\t\tattribute.f = processDirective( attribute.f, parser, EVENT );\n\t\n\t\t\t\t\tif ( reservedEventNames.test( attribute.f.n || attribute.f ) ) {\n\t\t\t\t\t\tparser.pos -= ( attribute.f.n || attribute.f ).length;\n\t\t\t\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\tif ( parser.sanitizeEventAttributes && onPattern.test( attribute.n ) ) {\n\t\t\t\t\t\treturn { exclude: true };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattribute.f = attribute.f || ( attribute.f === '' ? '' : 0 );\n\t\t\t\t\t\tattribute.t = ATTRIBUTE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn attribute;\n\t\t}\n\t\n\t\tvar delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\t\n\t\tfunction readMustache ( parser ) {\n\t\t\tvar mustache, i;\n\t\n\t\t\t// If we're inside a <script> or <style> tag, and we're not\n\t\t\t// interpolating, bug out\n\t\t\tif ( parser.interpolate[ parser.inside ] === false ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < parser.tags.length; i += 1 ) {\n\t\t\t\tif ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {\n\t\t\t\t\treturn mustache;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( parser.inTag && !parser.inAttribute ) {\n\t\t\t\tmustache = readAttributeOrDirective( parser );\n\t\t\t\tif ( mustache ) {\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\treturn mustache;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction readMustacheOfType ( parser, tag ) {\n\t\t\tvar start, mustache, reader, i;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tif ( parser.matchString( '\\\\' + tag.open ) ) {\n\t\t\t\tif ( start === 0 || parser.str[ start - 1 ] !== '\\\\' ) {\n\t\t\t\t\treturn tag.open;\n\t\t\t\t}\n\t\t\t} else if ( !parser.matchString( tag.open ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// delimiter change?\n\t\t\tif ( mustache = readDelimiterChange( parser ) ) {\n\t\t\t\t// find closing delimiter or abort...\n\t\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\t// ...then make the switch\n\t\t\t\ttag.open = mustache[0];\n\t\t\t\ttag.close = mustache[1];\n\t\t\t\tparser.sortMustacheTags();\n\t\n\t\t\t\treturn delimiterChangeToken;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\t// illegal section closer\n\t\t\tif ( parser.matchString( '/' ) ) {\n\t\t\t\tparser.pos -= 1;\n\t\t\t\tvar rewind = parser.pos;\n\t\t\t\tif ( !readNumberLiteral( parser ) ) {\n\t\t\t\t\tparser.pos = rewind - ( tag.close.length );\n\t\t\t\t\tif ( parser.inAttribute ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparser.pos = rewind;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < tag.readers.length; i += 1 ) {\n\t\t\t\treader = tag.readers[i];\n\t\n\t\t\t\tif ( mustache = reader( parser, tag ) ) {\n\t\t\t\t\tif ( tag.isStatic ) {\n\t\t\t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\t\t\tmustache.p = parser.getLinePos( start );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn mustache;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction refineExpression ( expression, mustache ) {\n\t\t\tvar referenceExpression;\n\t\n\t\t\tif ( expression ) {\n\t\t\t\twhile ( expression.t === BRACKETED && expression.x ) {\n\t\t\t\t\texpression = expression.x;\n\t\t\t\t}\n\t\n\t\t\t\tif ( expression.t === REFERENCE ) {\n\t\t\t\t\tmustache.r = expression.n;\n\t\t\t\t} else {\n\t\t\t\t\tif ( referenceExpression = getReferenceExpression( expression ) ) {\n\t\t\t\t\t\tmustache.rx = referenceExpression;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmustache.x = flattenExpression( expression );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn mustache;\n\t\t\t}\n\t\t}\n\t\n\t\t// TODO refactor this! it's bewildering\n\t\tfunction getReferenceExpression ( expression ) {\n\t\t\tvar members = [], refinement;\n\t\n\t\t\twhile ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {\n\t\t\t\trefinement = expression.r;\n\t\n\t\t\t\tif ( refinement.x ) {\n\t\t\t\t\tif ( refinement.x.t === REFERENCE ) {\n\t\t\t\t\t\tmembers.unshift( refinement.x );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmembers.unshift( flattenExpression( refinement.x ) );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmembers.unshift( refinement.n );\n\t\t\t\t}\n\t\n\t\t\t\texpression = expression.x;\n\t\t\t}\n\t\n\t\t\tif ( expression.t !== REFERENCE ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tr: expression.n,\n\t\t\t\tm: members\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readTriple ( parser, tag ) {\n\t\t\tvar expression = readExpression( parser ), triple;\n\t\n\t\t\tif ( !expression ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t}\n\t\n\t\t\ttriple = { t: TRIPLE };\n\t\t\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\t\n\t\t\treturn triple;\n\t\t}\n\t\n\t\tfunction readUnescaped ( parser, tag ) {\n\t\t\tvar expression, triple;\n\t\n\t\t\tif ( !parser.matchString( '&' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\texpression = readExpression( parser );\n\t\n\t\t\tif ( !expression ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t}\n\t\n\t\t\ttriple = { t: TRIPLE };\n\t\t\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\t\n\t\t\treturn triple;\n\t\t}\n\t\n\t\tvar legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n\t\tvar asRE = /^as/i;\n\t\n\t\tfunction readAliases( parser ) {\n\t\t\tvar aliases = [], alias, start = parser.pos;\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\talias = readAlias( parser );\n\t\n\t\t\tif ( alias ) {\n\t\t\t\talias.x = refineExpression( alias.x, {} );\n\t\t\t\taliases.push( alias );\n\t\n\t\t\t\tparser.allowWhitespace();\n\t\n\t\t\t\twhile ( parser.matchString(',') ) {\n\t\t\t\t\talias = readAlias( parser );\n\t\n\t\t\t\t\tif ( !alias ) {\n\t\t\t\t\t\tparser.error( 'Expected another alias.' );\n\t\t\t\t\t}\n\t\n\t\t\t\t\talias.x = refineExpression( alias.x, {} );\n\t\t\t\t\taliases.push( alias );\n\t\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t}\n\t\n\t\t\t\treturn aliases;\n\t\t\t}\n\t\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction readAlias( parser ) {\n\t\t\tvar expr, alias, start = parser.pos;\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\texpr = readExpression( parser, [] );\n\t\n\t\t\tif ( !expr ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchPattern( asRE ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\talias = parser.matchPattern( legalAlias );\n\t\n\t\t\tif ( !alias ) {\n\t\t\t\tparser.error( 'Expected a legal alias name.' );\n\t\t\t}\n\t\n\t\t\treturn { n: alias, x: expr };\n\t\t}\n\t\n\t\tfunction readPartial ( parser, tag ) {\n\t\t\tif ( !parser.matchString( '>' ) ) return null;\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\t// Partial names can include hyphens, so we can't use readExpression\n\t\t\t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n\t\t\t// `foo-bar` should be read as a single name, rather than 'subtract\n\t\t\t// bar from foo'\n\t\t\tparser.relaxedNames = parser.strictRefinement = true;\n\t\t\tvar expression = readExpression( parser );\n\t\t\tparser.relaxedNames = parser.strictRefinement = false;\n\t\n\t\t\tif ( !expression ) return null;\n\t\n\t\t\tvar partial = { t: PARTIAL };\n\t\t\trefineExpression( expression, partial ); // TODO...\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\t// check for alias context e.g. `{{>foo bar as bat, bip as bop}}` then\n\t\t\t// turn it into `{{#with bar as bat, bip as bop}}{{>foo}}{{/with}}`\n\t\t\tvar aliases = readAliases( parser );\n\t\t\tif ( aliases ) {\n\t\t\t\tpartial = {\n\t\t\t\t\tt: ALIAS,\n\t\t\t\t\tz: aliases,\n\t\t\t\t\tf: [ partial ]\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// otherwise check for literal context e.g. `{{>foo bar}}` then\n\t\t\t// turn it into `{{#with bar}}{{>foo}}{{/with}}`\n\t\t\telse {\n\t\t\t\tvar context = readExpression( parser );\n\t\t\t\tif ( context) {\n\t\t\t\t\tpartial = {\n\t\t\t\t\t\tt: SECTION,\n\t\t\t\t\t\tn: SECTION_WITH,\n\t\t\t\t\t\tf: [ partial ]\n\t\t\t\t\t};\n\t\n\t\t\t\t\trefineExpression( context, partial );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t}\n\t\n\t\t\treturn partial;\n\t\t}\n\t\n\t\tfunction readComment ( parser, tag ) {\n\t\t\tvar index;\n\t\n\t\t\tif ( !parser.matchString( '!' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tindex = parser.remaining().indexOf( tag.close );\n\t\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tparser.pos += index + tag.close.length;\n\t\t\t\treturn { t: COMMENT };\n\t\t\t}\n\t\t}\n\t\n\t\tfunction readExpressionOrReference ( parser, expectedFollowers ) {\n\t\t\tvar start, expression, i;\n\t\n\t\t\tstart = parser.pos;\n\t\t\texpression = readExpression( parser );\n\t\n\t\t\tif ( !expression ) {\n\t\t\t\t// valid reference but invalid expression e.g. `{{new}}`?\n\t\t\t\tvar ref = parser.matchPattern( /^(\\w+)/ );\n\t\t\t\tif ( ref ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: REFERENCE,\n\t\t\t\t\t\tn: ref\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < expectedFollowers.length; i += 1 ) {\n\t\t\t\tif ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {\n\t\t\t\t\treturn expression;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tparser.pos = start;\n\t\t\treturn readReference( parser );\n\t\t}\n\t\n\t\tfunction readInterpolator ( parser, tag ) {\n\t\t\tvar start, expression, interpolator, err;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\t// TODO would be good for perf if we could do away with the try-catch\n\t\t\ttry {\n\t\t\t\texpression = readExpressionOrReference( parser, [ tag.close ]);\n\t\t\t} catch ( e ) {\n\t\t\t\terr = e;\n\t\t\t}\n\t\n\t\t\tif ( !expression ) {\n\t\t\t\tif ( parser.str.charAt( start ) === '!' ) {\n\t\t\t\t\t// special case - comment\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tif ( err ) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"' after reference\") );\n\t\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\t// special case - comment\n\t\t\t\t\tif ( parser.nextChar() === '!' ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tparser.error( (\"Expected expression or legal reference\") );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tinterpolator = { t: INTERPOLATOR };\n\t\t\trefineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious\n\t\n\t\t\treturn interpolator;\n\t\t}\n\t\n\t\tvar yieldPattern = /^yield\\s*/;\n\t\n\t\tfunction readYielder ( parser, tag ) {\n\t\t\tif ( !parser.matchPattern( yieldPattern ) ) return null;\n\t\n\t\t\tvar name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"expected legal partial name\") );\n\t\t\t}\n\t\n\t\t\tvar yielder = { t: YIELDER };\n\t\t\tif ( name ) yielder.n = name;\n\t\n\t\t\treturn yielder;\n\t\t}\n\t\n\t\tfunction readClosing ( parser, tag ) {\n\t\t\tvar start, remaining, index, closing;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tif ( !parser.matchString( tag.open ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( '/' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tremaining = parser.remaining();\n\t\t\tindex = remaining.indexOf( tag.close );\n\t\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tclosing = {\n\t\t\t\t\tt: CLOSING,\n\t\t\t\t\tr: remaining.substr( 0, index ).split( ' ' )[0]\n\t\t\t\t};\n\t\n\t\t\t\tparser.pos += index;\n\t\n\t\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t\t}\n\t\n\t\t\t\treturn closing;\n\t\t\t}\n\t\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\t\n\t\tvar elsePattern = /^\\s*else\\s*/;\n\t\n\t\tfunction readElse ( parser, tag ) {\n\t\t\tvar start = parser.pos;\n\t\n\t\t\tif ( !parser.matchString( tag.open ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchPattern( elsePattern ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tt: ELSE\n\t\t\t};\n\t\t}\n\t\n\t\tvar elsePattern$1 = /^\\s*elseif\\s+/;\n\t\n\t\tfunction readElseIf ( parser, tag ) {\n\t\t\tvar start = parser.pos;\n\t\n\t\t\tif ( !parser.matchString( tag.open ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchPattern( elsePattern$1 ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tvar expression = readExpression( parser );\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tt: ELSEIF,\n\t\t\t\tx: expression\n\t\t\t};\n\t\t}\n\t\n\t\tvar handlebarsBlockCodes = {\n\t\t\t'each':    SECTION_EACH,\n\t\t\t'if':      SECTION_IF,\n\t\t\t'with':    SECTION_IF_WITH,\n\t\t\t'unless':  SECTION_UNLESS\n\t\t};\n\t\n\t\tvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n\t\tvar keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n\t\tvar handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' );\n\t\tfunction readSection ( parser, tag ) {\n\t\t\tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose, aliasOnly = false;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tif ( parser.matchString( '^' ) ) {\n\t\t\t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n\t\t\t} else if ( parser.matchString( '#' ) ) {\n\t\t\t\tsection = { t: SECTION, f: [] };\n\t\n\t\t\t\tif ( parser.matchString( 'partial' ) ) {\n\t\t\t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n\t\t\t\t\tparser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );\n\t\t\t\t}\n\t\n\t\t\t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t\t\t\t\texpectedClose = block;\n\t\t\t\t\tsection.n = handlebarsBlockCodes[ block ];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( block === 'with' ) {\n\t\t\t\tvar aliases = readAliases( parser );\n\t\t\t\tif ( aliases ) {\n\t\t\t\t\taliasOnly = true;\n\t\t\t\t\tsection.z = aliases;\n\t\t\t\t\tsection.t = ALIAS;\n\t\t\t\t}\n\t\t\t} else if ( block === 'each' ) {\n\t\t\t\tvar alias = readAlias( parser );\n\t\t\t\tif ( alias ) {\n\t\t\t\t\tsection.z = [ { n: alias.n, x: { r: '.' } } ];\n\t\t\t\t\texpression = alias.x;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !aliasOnly ) {\n\t\t\t\tif ( !expression ) expression = readExpression( parser );\n\t\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\tparser.error( 'Expected expression' );\n\t\t\t\t}\n\t\n\t\t\t\t// optional index and key references\n\t\t\t\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t\t\t\t\tvar extra;\n\t\n\t\t\t\t\tif ( extra = parser.matchPattern( keyIndexRefPattern ) ) {\n\t\t\t\t\t\tsection.i = i + ',' + extra;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsection.i = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t}\n\t\n\t\t\tparser.sectionDepth += 1;\n\t\t\tchildren = section.f;\n\t\n\t\t\tconditions = [];\n\t\n\t\t\tvar pos;\n\t\t\tdo {\n\t\t\t\tpos = parser.pos;\n\t\t\t\tif ( child = readClosing( parser, tag ) ) {\n\t\t\t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\t\tparser.error( (\"Expected \" + (tag.open) + \"/\" + expectedClose + \"\" + (tag.close)) );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tparser.sectionDepth -= 1;\n\t\t\t\t\tclosed = true;\n\t\t\t\t}\n\t\n\t\t\t\telse if ( !aliasOnly && ( child = readElseIf( parser, tag ) ) ) {\n\t\t\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasElse ) {\n\t\t\t\t\t\tparser.error( 'illegal {{elseif...}} after {{else}}' );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( !unlessBlock ) {\n\t\t\t\t\t\tunlessBlock = [];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar mustache = {\n\t\t\t\t\t\tt: SECTION,\n\t\t\t\t\t\tn: SECTION_IF,\n\t\t\t\t\t\tf: children = []\n\t\t\t\t\t};\n\t\t\t\t\trefineExpression( child.x, mustache );\n\t\n\t\t\t\t\tunlessBlock.push( mustache );\n\t\t\t\t}\n\t\n\t\t\t\telse if ( !aliasOnly && ( child = readElse( parser, tag ) ) ) {\n\t\t\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasElse ) {\n\t\t\t\t\t\tparser.error( 'there can only be one {{else}} block, at the end of a section' );\n\t\t\t\t\t}\n\t\n\t\t\t\t\thasElse = true;\n\t\n\t\t\t\t\t// use an unless block if there's no elseif\n\t\t\t\t\tif ( !unlessBlock ) {\n\t\t\t\t\t\tunlessBlock = [];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tunlessBlock.push({\n\t\t\t\t\t\tt: SECTION,\n\t\t\t\t\t\tn: SECTION_UNLESS,\n\t\t\t\t\t\tf: children = []\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\tchild = parser.read( READERS );\n\t\n\t\t\t\t\tif ( !child ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tchildren.push( child );\n\t\t\t\t}\n\t\t\t} while ( !closed );\n\t\n\t\t\tif ( unlessBlock ) {\n\t\t\t\tsection.l = unlessBlock;\n\t\t\t}\n\t\n\t\t\tif ( !aliasOnly ) {\n\t\t\t\trefineExpression( expression, section );\n\t\t\t}\n\t\n\t\t\t// TODO if a section is empty it should be discarded. Don't do\n\t\t\t// that here though - we need to clean everything up first, as\n\t\t\t// it may contain removeable whitespace. As a temporary measure,\n\t\t\t// to pass the existing tests, remove empty `f` arrays\n\t\t\tif ( !section.f.length ) {\n\t\t\t\tdelete section.f;\n\t\t\t}\n\t\n\t\t\treturn section;\n\t\t}\n\t\n\t\tvar OPEN_COMMENT = '<!--';\n\t\tvar CLOSE_COMMENT = '-->';\n\t\tfunction readHtmlComment ( parser ) {\n\t\t\tvar start, content, remaining, endIndex, comment;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tif ( parser.textOnlyMode || !parser.matchString( OPEN_COMMENT ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tremaining = parser.remaining();\n\t\t\tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\t\n\t\t\tif ( endIndex === -1 ) {\n\t\t\t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t\t\t}\n\t\n\t\t\tcontent = remaining.substr( 0, endIndex );\n\t\t\tparser.pos += endIndex + 3;\n\t\n\t\t\tcomment = {\n\t\t\t\tt: COMMENT,\n\t\t\t\tc: content\n\t\t\t};\n\t\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\tcomment.p = parser.getLinePos( start );\n\t\t\t}\n\t\n\t\t\treturn comment;\n\t\t}\n\t\n\t\tvar leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\n\t\tvar trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n\t\tfunction stripStandalones ( items ) {\n\t\t\tvar i, current, backOne, backTwo, lastSectionItem;\n\t\n\t\t\tfor ( i=1; i<items.length; i+=1 ) {\n\t\t\t\tcurrent = items[i];\n\t\t\t\tbackOne = items[i-1];\n\t\t\t\tbackTwo = items[i-2];\n\t\n\t\t\t\t// if we're at the end of a [text][comment][text] sequence...\n\t\t\t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\t\n\t\t\t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t\t\t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\t\n\t\t\t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t\t\t\t\t\titems[i-2] = backTwo.replace( trailingLinebreak, '\\n' );\n\t\n\t\t\t\t\t\t// and the leading line break of the second text token\n\t\t\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t\t\t\t// its first item is a linebreak...\n\t\t\t\tif ( isSection( current ) && isString( backOne ) ) {\n\t\t\t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {\n\t\t\t\t\t\titems[i-1] = backOne.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\tcurrent.f[0] = current.f[0].replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// if the last item was a section, and it is followed by a linebreak, and\n\t\t\t\t// its last item is a linebreak...\n\t\t\t\tif ( isString( current ) && isSection( backOne ) ) {\n\t\t\t\t\tlastSectionItem = lastItem( backOne.f );\n\t\n\t\t\t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn items;\n\t\t}\n\t\n\t\tfunction isString ( item ) {\n\t\t\treturn typeof item === 'string';\n\t\t}\n\t\n\t\tfunction isComment ( item ) {\n\t\t\treturn item.t === COMMENT || item.t === DELIMCHANGE;\n\t\t}\n\t\n\t\tfunction isSection ( item ) {\n\t\t\treturn ( item.t === SECTION || item.t === INVERTED ) && item.f;\n\t\t}\n\t\n\t\tfunction trimWhitespace ( items, leadingPattern, trailingPattern ) {\n\t\t\tvar item;\n\t\n\t\t\tif ( leadingPattern ) {\n\t\t\t\titem = items[0];\n\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\titem = item.replace( leadingPattern, '' );\n\t\n\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\titems.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titems[0] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( trailingPattern ) {\n\t\t\t\titem = lastItem( items );\n\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\titem = item.replace( trailingPattern, '' );\n\t\n\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\titems.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titems[ items.length - 1 ] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n\t\tvar preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n\t\tvar leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\n\t\tvar trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\t\tvar leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n\t\tvar trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n\t\n\t\tfunction cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {\n\t\t\tif ( typeof items === 'string' ) return;\n\t\n\t\t\tvar i,\n\t\t\t\titem,\n\t\t\t\tpreviousItem,\n\t\t\t\tnextItem,\n\t\t\t\tpreserveWhitespaceInsideFragment,\n\t\t\t\tremoveLeadingWhitespaceInsideFragment,\n\t\t\t\tremoveTrailingWhitespaceInsideFragment,\n\t\t\t\tkey;\n\t\n\t\t\t// First pass - remove standalones and comments etc\n\t\t\tstripStandalones( items );\n\t\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = items[i];\n\t\n\t\t\t\t// Remove delimiter changes, unsafe elements etc\n\t\t\t\tif ( item.exclude ) {\n\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t}\n\t\n\t\t\t\t// Remove comments, unless we want to keep them\n\t\t\t\telse if ( stripComments && item.t === COMMENT ) {\n\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// If necessary, remove leading and trailing whitespace\n\t\t\ttrimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );\n\t\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = items[i];\n\t\n\t\t\t\t// Recurse\n\t\t\t\tif ( item.f ) {\n\t\t\t\t\tvar isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );\n\t\t\t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\t\n\t\t\t\t\tif ( !preserveWhitespace && isPreserveWhitespaceElement ) {\n\t\t\t\t\t\ttrimWhitespace( item.f, leadingNewLine, trailingNewLine );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t\t\t\t\t\tpreviousItem = items[ i - 1 ];\n\t\t\t\t\t\tnextItem = items[ i + 1 ];\n\t\n\t\t\t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t\t\t\t\t\t// remove leading whitespace inside the fragment\n\t\t\t\t\t\tif ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {\n\t\t\t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// and vice versa\n\t\t\t\t\t\tif ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace$1.test( nextItem ) ) ) {\n\t\t\t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\n\t\t\t\t\t// clean up name templates (events, decorators, etc)\n\t\t\t\t\tif ( isArray( item.f.n ) ) {\n\t\t\t\t\t\tcleanup( item.f.n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// clean up arg templates (events, decorators, etc)\n\t\t\t\t\tif ( isArray( item.f.d ) ) {\n\t\t\t\t\t\tcleanup( item.f.d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Split if-else blocks into two (an if, and an unless)\n\t\t\t\tif ( item.l ) {\n\t\t\t\t\tcleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\n\t\t\t\t\titem.l.forEach( function ( s ) { return s.l = 1; } );\n\t\t\t\t\titem.l.unshift( i + 1, 0 );\n\t\t\t\t\titems.splice.apply( items, item.l );\n\t\t\t\t\tdelete item.l; // TODO would be nice if there was a way around this\n\t\t\t\t}\n\t\n\t\t\t\t// Clean up element attributes\n\t\t\t\tif ( item.a ) {\n\t\t\t\t\tfor ( key in item.a ) {\n\t\t\t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t\t\t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Clean up conditional attributes\n\t\t\t\tif ( item.m ) {\n\t\t\t\t\tcleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t\tif ( item.m.length < 1 ) delete item.m;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// final pass - fuse text nodes together\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( typeof items[i] === 'string' ) {\n\t\t\t\t\tif ( typeof items[i+1] === 'string' ) {\n\t\t\t\t\t\titems[i] = items[i] + items[i+1];\n\t\t\t\t\t\titems.splice( i + 1, 1 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( !preserveWhitespace ) {\n\t\t\t\t\t\titems[i] = items[i].replace( contiguousWhitespace, ' ' );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( items[i] === '' ) {\n\t\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\t\n\t\tfunction readClosingTag ( parser ) {\n\t\t\tvar start, tag;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\t// are we looking at a closing tag?\n\t\t\tif ( !parser.matchString( '</' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t\t\t\tif ( parser.inside && tag !== parser.inside ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\tt: CLOSING_TAG,\n\t\t\t\t\te: tag\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// We have an illegal closing tag, report it\n\t\t\tparser.pos -= 2;\n\t\t\tparser.error( 'Illegal closing tag' );\n\t\t}\n\t\n\t\tvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\n\t\tvar validTagNameFollower = /^[\\s\\n\\/>]/;\n\t\tvar exclude = { exclude: true };\n\t\tvar disallowedContents;\n\t\t// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\t\tdisallowedContents = {\n\t\t\tli: [ 'li' ],\n\t\t\tdt: [ 'dt', 'dd' ],\n\t\t\tdd: [ 'dt', 'dd' ],\n\t\t\tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\t\t\trt: [ 'rt', 'rp' ],\n\t\t\trp: [ 'rt', 'rp' ],\n\t\t\toptgroup: [ 'optgroup' ],\n\t\t\toption: [ 'option', 'optgroup' ],\n\t\t\tthead: [ 'tbody', 'tfoot' ],\n\t\t\ttbody: [ 'tbody', 'tfoot' ],\n\t\t\ttfoot: [ 'tbody' ],\n\t\t\ttr: [ 'tr', 'tbody' ],\n\t\t\ttd: [ 'td', 'th', 'tr' ],\n\t\t\tth: [ 'td', 'th', 'tr' ]\n\t\t};\n\t\n\t\tfunction readElement ( parser ) {\n\t\t\tvar start,\n\t\t\t\telement,\n\t\t\t\tattribute,\n\t\t\t\tselfClosing,\n\t\t\t\tchildren,\n\t\t\t\tpartials,\n\t\t\t\thasPartials,\n\t\t\t\tchild,\n\t\t\t\tclosed,\n\t\t\t\tpos,\n\t\t\t\tremaining,\n\t\t\t\tclosingTag;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tif ( parser.inside || parser.inAttribute || parser.textOnlyMode ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchString( '<' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// if this is a closing tag, abort straight away\n\t\t\tif ( parser.nextChar() === '/' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\telement = {};\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\telement.p = parser.getLinePos( start );\n\t\t\t}\n\t\n\t\t\tif ( parser.matchString( '!' ) ) {\n\t\t\t\telement.t = DOCTYPE;\n\t\t\t\tif ( !parser.matchPattern( /^doctype/i ) ) {\n\t\t\t\t\tparser.error( 'Expected DOCTYPE declaration' );\n\t\t\t\t}\n\t\n\t\t\t\telement.a = parser.matchPattern( /^(.+?)>/ );\n\t\t\t\treturn element;\n\t\t\t}\n\t\n\t\t\telement.t = ELEMENT;\n\t\n\t\t\t// element name\n\t\t\telement.e = parser.matchPattern( tagNamePattern );\n\t\t\tif ( !element.e ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// next character must be whitespace, closing solidus or '>'\n\t\t\tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t\t\t\tparser.error( 'Illegal tag name' );\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\tparser.inTag = true;\n\t\n\t\t\t// directives and attributes\n\t\t\twhile ( attribute = readMustache( parser ) ) {\n\t\t\t\tif ( attribute !== false ) {\n\t\t\t\t\tif ( !element.m ) element.m = [];\n\t\t\t\t\telement.m.push( attribute );\n\t\t\t\t}\n\t\n\t\t\t\tparser.allowWhitespace();\n\t\t\t}\n\t\n\t\t\tparser.inTag = false;\n\t\n\t\t\t// allow whitespace before closing solidus\n\t\t\tparser.allowWhitespace();\n\t\n\t\t\t// self-closing solidus?\n\t\t\tif ( parser.matchString( '/' ) ) {\n\t\t\t\tselfClosing = true;\n\t\t\t}\n\t\n\t\t\t// closing angle bracket\n\t\t\tif ( !parser.matchString( '>' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tvar lowerCaseName = element.e.toLowerCase();\n\t\t\tvar preserveWhitespace = parser.preserveWhitespace;\n\t\n\t\t\tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t\t\t\tparser.elementStack.push( lowerCaseName );\n\t\n\t\t\t\t// Special case - if we open a script element, further tags should\n\t\t\t\t// be ignored unless they're a closing script element\n\t\t\t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' || lowerCaseName === 'textarea' ) {\n\t\t\t\t\tparser.inside = lowerCaseName;\n\t\t\t\t}\n\t\n\t\t\t\tchildren = [];\n\t\t\t\tpartials = create( null );\n\t\n\t\t\t\tdo {\n\t\t\t\t\tpos = parser.pos;\n\t\t\t\t\tremaining = parser.remaining();\n\t\n\t\t\t\t\tif ( !remaining ) {\n\t\t\t\t\t\tparser.error( (\"Missing end \" + (parser.elementStack.length > 1 ? 'tags' : 'tag') + \" (\" + (parser.elementStack.reverse().map( function ( x ) { return (\"</\" + x + \">\"); } ).join( '' )) + \")\") );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if for example we're in an <li> element, and we see another\n\t\t\t\t\t// <li> tag, close the first so they become siblings\n\t\t\t\t\tif ( !canContain( lowerCaseName, remaining ) ) {\n\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// closing tag\n\t\t\t\t\telse if ( closingTag = readClosingTag( parser ) ) {\n\t\t\t\t\t\tclosed = true;\n\t\n\t\t\t\t\t\tvar closingTagName = closingTag.e.toLowerCase();\n\t\n\t\t\t\t\t\t// if this *isn't* the closing tag for the current element...\n\t\t\t\t\t\tif ( closingTagName !== lowerCaseName ) {\n\t\t\t\t\t\t\t// rewind parser\n\t\t\t\t\t\t\tparser.pos = pos;\n\t\n\t\t\t\t\t\t\t// if it doesn't close a parent tag, error\n\t\t\t\t\t\t\tif ( !~parser.elementStack.indexOf( closingTagName ) ) {\n\t\t\t\t\t\t\t\tvar errorMessage = 'Unexpected closing tag';\n\t\n\t\t\t\t\t\t\t\t// add additional help for void elements, since component names\n\t\t\t\t\t\t\t\t// might clash with them\n\t\t\t\t\t\t\t\tif ( voidElementNames.test( closingTagName ) ) {\n\t\t\t\t\t\t\t\t\terrorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tparser.error( errorMessage );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// implicit close by closing section tag. TODO clean this up\n\t\t\t\t\telse if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {\n\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\t}\n\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ( child = parser.read( PARTIAL_READERS ) ) {\n\t\t\t\t\t\t\tif ( partials[ child.n ] ) {\n\t\t\t\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\t\t\t\tparser.error( 'Duplicate partial definition' );\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\t\n\t\t\t\t\t\t\tpartials[ child.n ] = child.f;\n\t\t\t\t\t\t\thasPartials = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( child = parser.read( READERS ) ) {\n\t\t\t\t\t\t\t\tchildren.push( child );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while ( !closed );\n\t\n\t\t\t\tif ( children.length ) {\n\t\t\t\t\telement.f = children;\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasPartials ) {\n\t\t\t\t\telement.p = partials;\n\t\t\t\t}\n\t\n\t\t\t\tparser.elementStack.pop();\n\t\t\t}\n\t\n\t\t\tparser.inside = null;\n\t\n\t\t\tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t\t\t\treturn exclude;\n\t\t\t}\n\t\n\t\t\treturn element;\n\t\t}\n\t\n\t\tfunction canContain ( name, remaining ) {\n\t\t\tvar match, disallowed;\n\t\n\t\t\tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\t\t\tdisallowed = disallowedContents[ name ];\n\t\n\t\t\tif ( !match || !disallowed ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\treturn !~disallowed.indexOf( match[1].toLowerCase() );\n\t\t}\n\t\n\t\tfunction readText ( parser ) {\n\t\t\tvar index, remaining, disallowed, barrier;\n\t\n\t\t\tremaining = parser.remaining();\n\t\n\t\t\tif ( parser.textOnlyMode ) {\n\t\t\t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n\t\t\t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\t\n\t\t\t\tindex = getLowestIndex( remaining, disallowed );\n\t\t\t} else {\n\t\t\t\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\t\n\t\t\t\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t\t\t\t\tindex = remaining.indexOf( barrier );\n\t\t\t\t} else {\n\t\t\t\t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n\t\t\t\t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\t\n\t\t\t\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t\t\t\t\tif ( parser.inAttribute === true ) {\n\t\t\t\t\t\t// we're inside an unquoted attribute value\n\t\t\t\t\t\tdisallowed.push( (\"\\\"\"), (\"'\"), (\"=\"), (\"<\"), (\">\"), '`' );\n\t\t\t\t\t} else if ( parser.inAttribute ) {\n\t\t\t\t\t\t// quoted attribute value\n\t\t\t\t\t\tdisallowed.push( parser.inAttribute );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisallowed.push( barrier );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tindex = getLowestIndex( remaining, disallowed );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !index ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( index === -1 ) {\n\t\t\t\tindex = remaining.length;\n\t\t\t}\n\t\n\t\t\tparser.pos += index;\n\t\n\t\t\tif ( ( parser.inside && parser.inside !== 'textarea' ) || parser.textOnlyMode ) {\n\t\t\t\treturn remaining.substr( 0, index );\n\t\t\t} else {\n\t\t\t\treturn decodeCharacterReferences( remaining.substr( 0, index ) );\n\t\t\t}\n\t\t}\n\t\n\t\tvar startPattern = /^<!--\\s*/;\n\t\tvar namePattern$1 = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/;\n\t\tvar finishPattern = /\\s*-->/;\n\t\n\t\tfunction readPartialDefinitionComment ( parser ) {\n\t\t\tvar start = parser.pos;\n\t\t\tvar open = parser.standardDelimiters[0];\n\t\t\tvar close = parser.standardDelimiters[1];\n\t\n\t\t\tif ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tvar name = parser.matchPattern( namePattern$1 );\n\t\n\t\t\twarnOnceIfDebug( (\"Inline partial comments are deprecated.\\nUse this...\\n  {{#partial \" + name + \"}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>\" + name + \"}} --> ... <!-- {{/\" + name + \"}} -->'\") );\n\t\n\t\t\t// make sure the rest of the comment is in the correct place\n\t\t\tif ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tvar content = [];\n\t\t\tvar closed;\n\t\n\t\t\tvar endPattern = new RegExp('^<!--\\\\s*' + escapeRegExp( open ) + '\\\\s*\\\\/\\\\s*' + name + '\\\\s*' + escapeRegExp( close ) + '\\\\s*-->');\n\t\n\t\t\tdo {\n\t\t\t\tif ( parser.matchPattern( endPattern ) ) {\n\t\t\t\t\tclosed = true;\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\tvar child = parser.read( READERS );\n\t\t\t\t\tif ( !child ) {\n\t\t\t\t\t\tparser.error( (\"expected closing comment ('<!-- \" + open + \"/\" + name + \"\" + close + \" -->')\") );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontent.push( child );\n\t\t\t\t}\n\t\t\t} while ( !closed );\n\t\n\t\t\treturn {\n\t\t\t\tt: INLINE_PARTIAL,\n\t\t\t\tf: content,\n\t\t\t\tn: name\n\t\t\t};\n\t\t}\n\t\n\t\tvar partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\t\n\t\tfunction readPartialDefinitionSection ( parser ) {\n\t\t\tvar start, name, content, child, closed;\n\t\n\t\t\tstart = parser.pos;\n\t\n\t\t\tvar delimiters = parser.standardDelimiters;\n\t\n\t\t\tif ( !parser.matchString( delimiters[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/ );\n\t\n\t\t\tif ( !name ) {\n\t\t\t\tparser.error( 'expected legal partial name' );\n\t\t\t}\n\t\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( delimiters[1] ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (delimiters[1]) + \"'\") );\n\t\t\t}\n\t\n\t\t\tcontent = [];\n\t\n\t\t\tdo {\n\t\t\t\t// TODO clean this up\n\t\t\t\tif ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] }) ) {\n\t\t\t\t\tif ( !child.r === 'partial' ) {\n\t\t\t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tclosed = true;\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\tchild = parser.read( READERS );\n\t\n\t\t\t\t\tif ( !child ) {\n\t\t\t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontent.push( child );\n\t\t\t\t}\n\t\t\t} while ( !closed );\n\t\n\t\t\treturn {\n\t\t\t\tt: INLINE_PARTIAL,\n\t\t\t\tn: name,\n\t\t\t\tf: content\n\t\t\t};\n\t\t}\n\t\n\t\tfunction readTemplate ( parser ) {\n\t\t\tvar fragment = [];\n\t\t\tvar partials = create( null );\n\t\t\tvar hasPartials = false;\n\t\n\t\t\tvar preserveWhitespace = parser.preserveWhitespace;\n\t\n\t\t\twhile ( parser.pos < parser.str.length ) {\n\t\t\t\tvar pos = parser.pos, item, partial;\n\t\n\t\t\t\tif ( partial = parser.read( PARTIAL_READERS ) ) {\n\t\t\t\t\tif ( partials[ partial.n ] ) {\n\t\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\t\tparser.error( 'Duplicated partial definition' );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\t\n\t\t\t\t\tpartials[ partial.n ] = partial.f;\n\t\t\t\t\thasPartials = true;\n\t\t\t\t} else if ( item = parser.read( READERS ) ) {\n\t\t\t\t\tfragment.push( item );\n\t\t\t\t} else  {\n\t\t\t\t\tparser.error( 'Unexpected template content' );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar result = {\n\t\t\t\tv: TEMPLATE_VERSION,\n\t\t\t\tt: fragment\n\t\t\t};\n\t\n\t\t\tif ( hasPartials ) {\n\t\t\t\tresult.p = partials;\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\tfunction insertExpressions ( obj, expr ) {\n\t\n\t\t\tObject.keys( obj ).forEach( function ( key ) {\n\t\t\t\tif  ( isExpression( key, obj ) ) return addTo( obj, expr );\n\t\n\t\t\t\tvar ref = obj[ key ];\n\t\t\t\tif ( hasChildren( ref ) ) insertExpressions( ref, expr );\n\t\t \t});\n\t\t}\n\t\n\t\tfunction isExpression( key, obj ) {\n\t\t\treturn key === 's' && isArray( obj.r );\n\t\t}\n\t\n\t\tfunction addTo( obj, expr ) {\n\t\t\tvar s = obj.s, r = obj.r;\n\t\t\tif ( !expr[ s ] ) expr[ s ] = fromExpression( s, r.length );\n\t\t}\n\t\n\t\tfunction hasChildren( ref ) {\n\t\t\treturn isArray( ref ) || isObject( ref );\n\t\t}\n\t\n\t\t// See https://github.com/ractivejs/template-spec for information\n\t\t// about the Ractive template specification\n\t\n\t\tvar STANDARD_READERS = [ readPartial, readUnescaped, readSection, readYielder, readInterpolator, readComment ];\n\t\tvar TRIPLE_READERS = [ readTriple ];\n\t\tvar STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?\n\t\n\t\tvar StandardParser;\n\t\n\t\tfunction parse ( template, options ) {\n\t\t\treturn new StandardParser( template, options || {} ).result;\n\t\t}\n\t\n\t\tparse.computedStrings = function( computed ) {\n\t\t\tif ( !computed ) return [];\n\t\n\t\t\tObject.keys( computed ).forEach( function ( key ) {\n\t\t\t\tvar value = computed[ key ];\n\t\t\t\tif ( typeof value === 'string' ) {\n\t\t\t\t\tcomputed[ key ] = fromComputationString( value );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\n\t\tvar READERS = [ readMustache, readHtmlComment, readElement, readText ];\n\t\tvar PARTIAL_READERS = [ readPartialDefinitionComment, readPartialDefinitionSection ];\n\t\n\t\tStandardParser = Parser$1.extend({\n\t\t\tinit: function ( str, options ) {\n\t\t\t\tvar tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],\n\t\t\t\t\tstaticDelimiters = options.staticDelimiters || [ '[[', ']]' ],\n\t\t\t\t\tstaticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];\n\t\n\t\t\t\tthis.standardDelimiters = options.delimiters || [ '{{', '}}' ];\n\t\n\t\t\t\tthis.tags = [\n\t\t\t\t\t{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },\n\t\t\t\t\t{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },\n\t\t\t\t\t{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },\n\t\t\t\t\t{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }\n\t\t\t\t];\n\t\n\t\t\t\tthis.contextLines = options.contextLines || 0;\n\t\n\t\t\t\tthis.sortMustacheTags();\n\t\n\t\t\t\tthis.sectionDepth = 0;\n\t\t\t\tthis.elementStack = [];\n\t\n\t\t\t\tthis.interpolate = {\n\t\t\t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t\t\t\t\tstyle: !options.interpolate || options.interpolate.style !== false,\n\t\t\t\t\ttextarea: true\n\t\t\t\t};\n\t\n\t\t\t\tif ( options.sanitize === true ) {\n\t\t\t\t\toptions.sanitize = {\n\t\t\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t\t\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t\t\t\t\t\teventAttributes: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\tthis.stripComments = options.stripComments !== false;\n\t\t\t\tthis.preserveWhitespace = options.preserveWhitespace;\n\t\t\t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t\t\t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t\t\t\tthis.includeLinePositions = options.includeLinePositions;\n\t\t\t\tthis.textOnlyMode = options.textOnlyMode;\n\t\t\t\tthis.csp = options.csp;\n\t\t\t},\n\t\n\t\t\tpostProcess: function ( result ) {\n\t\t\t\t// special case - empty string\n\t\t\t\tif ( !result.length ) {\n\t\t\t\t\treturn { t: [], v: TEMPLATE_VERSION };\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.sectionDepth > 0 ) {\n\t\t\t\t\tthis.error( 'A section was left open' );\n\t\t\t\t}\n\t\n\t\t\t\tcleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );\n\t\n\t\t\t\tif ( this.csp !== false ) {\n\t\t\t\t\tvar expr = {};\n\t\t\t\t\tinsertExpressions( result[0].t, expr );\n\t\t\t\t\tif ( Object.keys( expr ).length ) result[0].e = expr;\n\t\t\t\t}\n\t\n\t\t\t\treturn result[0];\n\t\t\t},\n\t\n\t\t\tconverters: [\n\t\t\t\treadTemplate\n\t\t\t],\n\t\n\t\t\tsortMustacheTags: function () {\n\t\t\t\t// Sort in order of descending opening delimiter length (longer first),\n\t\t\t\t// to protect against opening delimiters being substrings of each other\n\t\t\t\tthis.tags.sort( function ( a, b ) {\n\t\t\t\t\treturn b.open.length - a.open.length;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\n\t\tvar parseOptions = [\n\t\t\t'delimiters',\n\t\t\t'tripleDelimiters',\n\t\t\t'staticDelimiters',\n\t\t\t'staticTripleDelimiters',\n\t\t\t'csp',\n\t\t\t'interpolate',\n\t\t\t'preserveWhitespace',\n\t\t\t'sanitize',\n\t\t\t'stripComments',\n\t\t\t'contextLines'\n\t\t];\n\t\n\t\tvar TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\n\t\n\t\tvar COMPUTATION_INSTRUCTIONS = \"Either use:\\n\\n\\tRactive.parse.computedStrings( component.computed )\\n\\nat build time to pre-convert the strings to functions, or use functions instead of strings in computed properties.\";\n\t\n\t\n\t\tfunction throwNoParse ( method, error, instructions ) {\n\t\t\tif ( !method ) {\n\t\t\t\tfatal( (\"Missing Ractive.parse - cannot parse \" + error + \". \" + instructions) );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction createFunction ( body, length ) {\n\t\t\tthrowNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );\n\t\t\treturn fromExpression( body, length );\n\t\t}\n\t\n\t\tfunction createFunctionFromString ( str, bindTo ) {\n\t\t\tthrowNoParse( fromComputationString, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS );\n\t\t\treturn fromComputationString( str, bindTo );\n\t\t}\n\t\n\t\tvar parser = {\n\t\n\t\t\tfromId: function ( id, options ) {\n\t\t\t\tif ( !doc ) {\n\t\t\t\t\tif ( options && options.noThrow ) { return; }\n\t\t\t\t\tthrow new Error( (\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\") );\n\t\t\t\t}\n\t\n\t\t\t\tif ( id ) id = id.replace( /^#/, '' );\n\t\n\t\t\t\tvar template;\n\t\n\t\t\t\tif ( !( template = doc.getElementById( id ) )) {\n\t\t\t\t\tif ( options && options.noThrow ) { return; }\n\t\t\t\t\tthrow new Error( (\"Could not find template element with id #\" + id) );\n\t\t\t\t}\n\t\n\t\t\t\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t\t\t\t\tif ( options && options.noThrow ) { return; }\n\t\t\t\t\tthrow new Error( (\"Template element with id #\" + id + \", must be a <script> element\") );\n\t\t\t\t}\n\t\n\t\t\t\treturn ( 'textContent' in template ? template.textContent : template.innerHTML );\n\t\n\t\t\t},\n\t\n\t\t\tisParsed: function ( template) {\n\t\t\t\treturn !( typeof template === 'string' );\n\t\t\t},\n\t\n\t\t\tgetParseOptions: function ( ractive ) {\n\t\t\t\t// Could be Ractive or a Component\n\t\t\t\tif ( ractive.defaults ) { ractive = ractive.defaults; }\n\t\n\t\t\t\treturn parseOptions.reduce( function ( val, key ) {\n\t\t\t\t\tval[ key ] = ractive[ key ];\n\t\t\t\t\treturn val;\n\t\t\t\t}, {});\n\t\t\t},\n\t\n\t\t\tparse: function ( template, options ) {\n\t\t\t\tthrowNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );\n\t\t\t\tvar parsed = parse( template, options );\n\t\t\t\taddFunctions( parsed );\n\t\t\t\treturn parsed;\n\t\t\t},\n\t\n\t\t\tparseFor: function( template, ractive ) {\n\t\t\t\treturn this.parse( template, this.getParseOptions( ractive ) );\n\t\t\t}\n\t\t};\n\t\n\t\tvar templateConfigurator = {\n\t\t\tname: 'template',\n\t\n\t\t\textend: function ( Parent, proto, options ) {\n\t\t\t\t// only assign if exists\n\t\t\t\tif ( 'template' in options ) {\n\t\t\t\t\tvar template = options.template;\n\t\n\t\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\t\tproto.template = template;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproto.template = parseTemplate( template, proto );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tinit: function ( Parent, ractive, options ) {\n\t\t\t\t// TODO because of prototypal inheritance, we might just be able to use\n\t\t\t\t// ractive.template, and not bother passing through the Parent object.\n\t\t\t\t// At present that breaks the test mocks' expectations\n\t\t\t\tvar template = 'template' in options ? options.template : Parent.prototype.template;\n\t\t\t\ttemplate = template || { v: TEMPLATE_VERSION, t: [] };\n\t\n\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\tvar fn = template;\n\t\t\t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\t\n\t\t\t\t\tractive._config.template = {\n\t\t\t\t\t\tfn: fn,\n\t\t\t\t\t\tresult: template\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\ttemplate = parseTemplate( template, ractive );\n\t\n\t\t\t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t\t\t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t\t\t\t// it's unnecessary, because the developer never needs to access\n\t\t\t\t// ractive.template\n\t\t\t\tractive.template = template.t;\n\t\n\t\t\t\tif ( template.p ) {\n\t\t\t\t\textendPartials( ractive.partials, template.p );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\treset: function ( ractive ) {\n\t\t\t\tvar result = resetValue( ractive );\n\t\n\t\t\t\tif ( result ) {\n\t\t\t\t\tvar parsed = parseTemplate( result, ractive );\n\t\n\t\t\t\t\tractive.template = parsed.t;\n\t\t\t\t\textendPartials( ractive.partials, parsed.p, true );\n\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tfunction resetValue ( ractive ) {\n\t\t\tvar initial = ractive._config.template;\n\t\n\t\t\t// If this isn't a dynamic template, there's nothing to do\n\t\t\tif ( !initial || !initial.fn ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar result = getDynamicTemplate( ractive, initial.fn );\n\t\n\t\t\t// TODO deep equality check to prevent unnecessary re-rendering\n\t\t\t// in the case of already-parsed templates\n\t\t\tif ( result !== initial.result ) {\n\t\t\t\tinitial.result = result;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getDynamicTemplate ( ractive, fn ) {\n\t\t\treturn fn.call( ractive, {\n\t\t\t\tfromId: parser.fromId,\n\t\t\t\tisParsed: parser.isParsed,\n\t\t\t\tparse: function ( template, options ) {\n\t\t\t\t\tif ( options === void 0 ) options = parser.getParseOptions( ractive );\n\t\n\t\t\t\t\treturn parser.parse( template, options );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction parseTemplate ( template, ractive ) {\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t// parse will validate and add expression functions\n\t\t\t\ttemplate = parseAsString( template, ractive );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// need to validate and add exp for already parsed template\n\t\t\t\tvalidate$1( template );\n\t\t\t\taddFunctions( template );\n\t\t\t}\n\t\n\t\t\treturn template;\n\t\t}\n\t\n\t\tfunction parseAsString ( template, ractive ) {\n\t\t\t// ID of an element containing the template?\n\t\t\tif ( template[0] === '#' ) {\n\t\t\t\ttemplate = parser.fromId( template );\n\t\t\t}\n\t\n\t\t\treturn parser.parseFor( template, ractive );\n\t\t}\n\t\n\t\tfunction validate$1( template ) {\n\t\n\t\t\t// Check that the template even exists\n\t\t\tif ( template == undefined ) {\n\t\t\t\tthrow new Error( (\"The template cannot be \" + template + \".\") );\n\t\t\t}\n\t\n\t\t\t// Check the parsed template has a version at all\n\t\t\telse if ( typeof template.v !== 'number' ) {\n\t\t\t\tthrow new Error( 'The template parser was passed a non-string template, but the template doesn\\'t have a version.  Make sure you\\'re passing in the template you think you are.' );\n\t\t\t}\n\t\n\t\t\t// Check we're using the correct version\n\t\t\telse if ( template.v !== TEMPLATE_VERSION ) {\n\t\t\t\tthrow new Error( (\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + (template.v) + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\") );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction extendPartials ( existingPartials, newPartials, overwrite ) {\n\t\t\tif ( !newPartials ) return;\n\t\n\t\t\t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t\t\t// case, but not initially...\n\t\n\t\t\tfor ( var key in newPartials ) {\n\t\t\t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t\t\t\t\texistingPartials[ key ] = newPartials[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar registryNames = [\n\t\t\t'adaptors',\n\t\t\t'components',\n\t\t\t'computed',\n\t\t\t'decorators',\n\t\t\t'easing',\n\t\t\t'events',\n\t\t\t'interpolators',\n\t\t\t'partials',\n\t\t\t'transitions'\n\t\t];\n\t\n\t\tvar Registry = function Registry ( name, useDefaults ) {\n\t\t\tthis.name = name;\n\t\t\tthis.useDefaults = useDefaults;\n\t\t};\n\t\n\t\tRegistry.prototype.extend = function extend ( Parent, proto, options ) {\n\t\t\tthis.configure(\n\t\t\t\tthis.useDefaults ? Parent.defaults : Parent,\n\t\t\t\tthis.useDefaults ? proto : proto.constructor,\n\t\t\t\toptions );\n\t\t};\n\t\n\t\tRegistry.prototype.init = function init () {\n\t\t\t// noop\n\t\t};\n\t\n\t\tRegistry.prototype.configure = function configure ( Parent, target, options ) {\n\t\t\tvar name = this.name;\n\t\t\tvar option = options[ name ];\n\t\n\t\t\tvar registry = create( Parent[name] );\n\t\n\t\t\tfor ( var key in option ) {\n\t\t\t\tregistry[ key ] = option[ key ];\n\t\t\t}\n\t\n\t\t\ttarget[ name ] = registry;\n\t\t};\n\t\n\t\tRegistry.prototype.reset = function reset ( ractive ) {\n\t\t\tvar registry = ractive[ this.name ];\n\t\t\tvar changed = false;\n\t\n\t\t\tObject.keys( registry ).forEach( function ( key ) {\n\t\t\t\tvar item = registry[ key ];\n\t\t\t\t\t\n\t\t\t\tif ( item._fn ) {\n\t\t\t\t\tif ( item._fn.isOwner ) {\n\t\t\t\t\t\tregistry[key] = item._fn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete registry[key];\n\t\t\t\t\t}\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn changed;\n\t\t};\n\t\n\t\tvar registries = registryNames.map( function ( name ) { return new Registry( name, name === 'computed' ); } );\n\t\n\t\tfunction wrap ( parent, name, method ) {\n\t\t\tif ( !/_super/.test( method ) ) return method;\n\t\n\t\t\tfunction wrapper () {\n\t\t\t\tvar superMethod = getSuperMethod( wrapper._parent, name );\n\t\t\t\tvar hasSuper = '_super' in this;\n\t\t\t\tvar oldSuper = this._super;\n\t\n\t\t\t\tthis._super = superMethod;\n\t\n\t\t\t\tvar result = method.apply( this, arguments );\n\t\n\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\tthis._super = oldSuper;\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._super;\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\n\t\t\twrapper._parent = parent;\n\t\t\twrapper._method = method;\n\t\n\t\t\treturn wrapper;\n\t\t}\n\t\n\t\tfunction getSuperMethod ( parent, name ) {\n\t\t\tif ( name in parent ) {\n\t\t\t\tvar value = parent[ name ];\n\t\n\t\t\t\treturn typeof value === 'function' ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tfunction () { return value; };\n\t\t\t}\n\t\n\t\t\treturn noop;\n\t\t}\n\t\n\t\tfunction getMessage( deprecated, correct, isError ) {\n\t\t\treturn \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\"\n\t\t\t\t+ ( isError ? (\" You cannot specify both options, please use options.\" + correct + \".\") : '' );\n\t\t}\n\t\n\t\tfunction deprecateOption ( options, deprecatedOption, correct ) {\n\t\t\tif ( deprecatedOption in options ) {\n\t\t\t\tif( !( correct in options ) ) {\n\t\t\t\t\twarnIfDebug( getMessage( deprecatedOption, correct ) );\n\t\t\t\t\toptions[ correct ] = options[ deprecatedOption ];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( getMessage( deprecatedOption, correct, true ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction deprecate ( options ) {\n\t\t\tdeprecateOption( options, 'beforeInit', 'onconstruct' );\n\t\t\tdeprecateOption( options, 'init', 'onrender' );\n\t\t\tdeprecateOption( options, 'complete', 'oncomplete' );\n\t\t\tdeprecateOption( options, 'eventDefinitions', 'events' );\n\t\n\t\t\t// Using extend with Component instead of options,\n\t\t\t// like Human.extend( Spider ) means adaptors as a registry\n\t\t\t// gets copied to options. So we have to check if actually an array\n\t\t\tif ( isArray( options.adaptors ) ) {\n\t\t\t\tdeprecateOption( options, 'adaptors', 'adapt' );\n\t\t\t}\n\t\t}\n\t\n\t\tvar custom = {\n\t\t\tadapt: adaptConfigurator,\n\t\t\tcss: cssConfigurator,\n\t\t\tdata: dataConfigurator,\n\t\t\ttemplate: templateConfigurator\n\t\t};\n\t\n\t\tvar defaultKeys = Object.keys( defaults );\n\t\n\t\tvar isStandardKey = makeObj( defaultKeys.filter( function ( key ) { return !custom[ key ]; } ) );\n\t\n\t\t// blacklisted keys that we don't double extend\n\t\tvar isBlacklisted = makeObj( defaultKeys.concat( registries.map( function ( r ) { return r.name; } ) ) );\n\t\n\t\tvar order = [].concat(\n\t\t\tdefaultKeys.filter( function ( key ) { return !registries[ key ] && !custom[ key ]; } ),\n\t\t\tregistries,\n\t\t\t//custom.data,\n\t\t\tcustom.template,\n\t\t\tcustom.css\n\t\t);\n\t\n\t\tvar config = {\n\t\t\textend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },\n\t\n\t\t\tinit: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },\n\t\n\t\t\treset: function ( ractive ) {\n\t\t\t\treturn order.filter( function ( c ) {\n\t\t\t\t\treturn c.reset && c.reset( ractive );\n\t\t\t\t}).map( function ( c ) { return c.name; } );\n\t\t\t},\n\t\n\t\t\t// this defines the order. TODO this isn't used anywhere in the codebase,\n\t\t\t// only in the test suite - should get rid of it\n\t\t\torder: order\n\t\t};\n\t\n\t\tfunction configure ( method, Parent, target, options ) {\n\t\t\tdeprecate( options );\n\t\n\t\t\tfor ( var key in options ) {\n\t\t\t\tif ( isStandardKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar value = options[ key ];\n\t\n\t\t\t\t\t// warn the developer if they passed a function and ignore its value\n\t\n\t\t\t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n\t\t\t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n\t\t\t\t\t// function object as the result of querySelector methods\n\t\t\t\t\tif ( key !== 'el' && typeof value === 'function' ) {\n\t\t\t\t\t\twarnIfDebug( (\"\" + key + \" is a Ractive option that does not expect a function and will be ignored\"),\n\t\t\t\t\t\t\tmethod === 'init' ? target : null );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// disallow combination of `append` and `enhance`\n\t\t\tif ( options.append && options.enhance ) {\n\t\t\t\tthrow new Error( 'Cannot use append and enhance at the same time' );\n\t\t\t}\n\t\n\t\t\tregistries.forEach( function ( registry ) {\n\t\t\t\tregistry[ method ]( Parent, target, options );\n\t\t\t});\n\t\n\t\t\tadaptConfigurator[ method ]( Parent, target, options );\n\t\t\ttemplateConfigurator[ method ]( Parent, target, options );\n\t\t\tcssConfigurator[ method ]( Parent, target, options );\n\t\n\t\t\textendOtherMethods( Parent.prototype, target, options );\n\t\t}\n\t\n\t\tfunction extendOtherMethods ( parent, target, options ) {\n\t\t\tfor ( var key in options ) {\n\t\t\t\tif ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar member = options[ key ];\n\t\n\t\t\t\t\t// if this is a method that overwrites a method, wrap it:\n\t\t\t\t\tif ( typeof member === 'function' ) {\n\t\t\t\t\t\tmember = wrap( parent, key, member );\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttarget[ key ] = member;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction makeObj ( array ) {\n\t\t\tvar obj = {};\n\t\t\tarray.forEach( function ( x ) { return obj[x] = true; } );\n\t\t\treturn obj;\n\t\t}\n\t\n\t\tvar shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];\n\t\n\t\tvar completeHook$1 = new Hook( 'complete' );\n\t\tvar resetHook = new Hook( 'reset' );\n\t\tvar renderHook$1 = new Hook( 'render' );\n\t\tvar unrenderHook = new Hook( 'unrender' );\n\t\n\t\tfunction Ractive$reset ( data ) {\n\t\t\tdata = data || {};\n\t\n\t\t\tif ( typeof data !== 'object' ) {\n\t\t\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t\t\t}\n\t\n\t\t\t// TEMP need to tidy this up\n\t\t\tdata = dataConfigurator.init( this.constructor, this, { data: data });\n\t\n\t\t\tvar promise = runloop.start( this, true );\n\t\n\t\t\t// If the root object is wrapped, try and use the wrapper's reset value\n\t\t\tvar wrapper = this.viewmodel.wrapper;\n\t\t\tif ( wrapper && wrapper.reset ) {\n\t\t\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t\t\t// reset was rejected, we need to replace the object\n\t\t\t\t\tthis.viewmodel.set( data );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.viewmodel.set( data );\n\t\t\t}\n\t\n\t\t\t// reset config items and track if need to rerender\n\t\t\tvar changes = config.reset( this );\n\t\t\tvar rerender;\n\t\n\t\t\tvar i = changes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t\t\t\t\trerender = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( rerender ) {\n\t\t\t\tunrenderHook.fire( this );\n\t\t\t\tthis.fragment.resetTemplate( this.template );\n\t\t\t\trenderHook$1.fire( this );\n\t\t\t\tcompleteHook$1.fire( this );\n\t\t\t}\n\t\n\t\t\trunloop.end();\n\t\n\t\t\tresetHook.fire( this, data );\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tfunction collect( source, name, attr, dest ) {\n\t\t\tsource.forEach( function ( item ) {\n\t\t\t\t// queue to rerender if the item is a partial and the current name matches\n\t\t\t\tif ( item.type === PARTIAL && ( item.refName ===  name || item.name === name ) ) {\n\t\t\t\t\titem.inAttribute = attr;\n\t\t\t\t\tdest.push( item );\n\t\t\t\t\treturn; // go no further\n\t\t\t\t}\n\t\n\t\t\t\t// if it has a fragment, process its items\n\t\t\t\tif ( item.fragment ) {\n\t\t\t\t\tcollect( item.fragment.iterations || item.fragment.items, name, attr, dest );\n\t\t\t\t}\n\t\n\t\t\t\t// or if it is itself a fragment, process its items\n\t\t\t\telse if ( isArray( item.items ) ) {\n\t\t\t\t\tcollect( item.items, name, attr, dest );\n\t\t\t\t}\n\t\n\t\t\t\t// or if it is a component, step in and process its items\n\t\t\t\telse if ( item.type === COMPONENT && item.instance ) {\n\t\t\t\t\t// ...unless the partial is shadowed\n\t\t\t\t\tif ( item.instance.partials[ name ] ) return;\n\t\t\t\t\tcollect( item.instance.fragment.items, name, attr, dest );\n\t\t\t\t}\n\t\n\t\t\t\t// if the item is an element, process its attributes too\n\t\t\t\tif ( item.type === ELEMENT ) {\n\t\t\t\t\tif ( isArray( item.attributes ) ) {\n\t\t\t\t\t\tcollect( item.attributes, name, true, dest );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction forceResetTemplate ( partial ) {\n\t\t\tpartial.forceResetTemplate();\n\t\t}\n\t\n\t\tfunction resetPartial ( name, partial ) {\n\t\t\tvar collection = [];\n\t\t\tcollect( this.fragment.items, name, false, collection );\n\t\n\t\t\tvar promise = runloop.start( this, true );\n\t\n\t\t\tthis.partials[ name ] = partial;\n\t\t\tcollection.forEach( forceResetTemplate );\n\t\n\t\t\trunloop.end();\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tvar Item = function Item ( options ) {\n\t\t\tthis.parentFragment = options.parentFragment;\n\t\t\tthis.ractive = options.parentFragment.ractive;\n\t\n\t\t\tthis.template = options.template;\n\t\t\tthis.index = options.index;\n\t\t\tthis.type = options.template.t;\n\t\n\t\t\tthis.dirty = false;\n\t\t};\n\t\n\t\tItem.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t}\n\t\t};\n\t\n\t\tItem.prototype.destroyed = function destroyed () {\n\t\t\tif ( this.fragment ) this.fragment.destroyed();\n\t\t};\n\t\n\t\tItem.prototype.find = function find () {\n\t\t\treturn null;\n\t\t};\n\t\n\t\tItem.prototype.findAll = function findAll () {\n\t\t\t// noop\n\t\t};\n\t\n\t\tItem.prototype.findComponent = function findComponent () {\n\t\t\treturn null;\n\t\t};\n\t\n\t\tItem.prototype.findAllComponents = function findAllComponents () {\n\t\t\t// noop;\n\t\t};\n\t\n\t\tItem.prototype.findNextNode = function findNextNode () {\n\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t};\n\t\n\t\tItem.prototype.shuffled = function shuffled () {\n\t\t\tif ( this.fragment ) this.fragment.shuffled();\n\t\t};\n\t\n\t\tItem.prototype.valueOf = function valueOf () {\n\t\t\treturn this.toString();\n\t\t};\n\t\n\t\tvar ComputationChild = (function (Model) {\n\t\t\tfunction ComputationChild () {\n\t\t\t\tModel.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tComputationChild.prototype = Object.create( Model && Model.prototype );\n\t\t\tComputationChild.prototype.constructor = ComputationChild;\n\t\n\t\t\tComputationChild.prototype.get = function get ( shouldCapture ) {\n\t\t\t\tif ( shouldCapture ) capture( this );\n\t\n\t\t\t\tvar parentValue = this.parent.get();\n\t\t\t\treturn parentValue ? parentValue[ this.key ] : undefined;\n\t\t\t};\n\t\n\t\t\tComputationChild.prototype.handleChange = function handleChange$1 () {\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\tthis.links.forEach( marked );\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\tthis.children.forEach( handleChange );\n\t\t\t\tthis.clearUnresolveds(); // TODO is this necessary?\n\t\t\t};\n\t\n\t\t\tComputationChild.prototype.joinKey = function joinKey ( key ) {\n\t\t\t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar child = new ComputationChild( this, key );\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.childByKey[ key ];\n\t\t\t};\n\t\n\t\t\treturn ComputationChild;\n\t\t}(Model));\n\t\n\t\tfunction createResolver ( proxy, ref, index ) {\n\t\t\tvar resolver = proxy.fragment.resolve( ref, function ( model ) {\n\t\t\t\tremoveFromArray( proxy.resolvers, resolver );\n\t\t\t\tproxy.models[ index ] = model;\n\t\t\t\tproxy.bubble();\n\t\t\t});\n\t\n\t\t\tproxy.resolvers.push( resolver );\n\t\t}\n\t\n\t\tvar ExpressionProxy = (function (Model) {\n\t\t\tfunction ExpressionProxy ( fragment, template ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tModel.call( this, fragment.ractive.viewmodel, null );\n\t\n\t\t\t\tthis.fragment = fragment;\n\t\t\t\tthis.template = template;\n\t\n\t\t\t\tthis.isReadonly = true;\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\tthis.fn = getFunction( template.s, template.r.length );\n\t\n\t\t\t\tthis.resolvers = [];\n\t\t\t\tthis.models = this.template.r.map( function ( ref, index ) {\n\t\t\t\t\tvar model = resolveReference( this$1.fragment, ref );\n\t\n\t\t\t\t\tif ( !model ) {\n\t\t\t\t\t\tcreateResolver( this$1, ref, index );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn model;\n\t\t\t\t});\n\t\t\t\tthis.dependencies = [];\n\t\n\t\t\t\tthis.shuffle = undefined;\n\t\n\t\t\t\tthis.bubble();\n\t\t\t}\n\t\n\t\t\tExpressionProxy.prototype = Object.create( Model && Model.prototype );\n\t\t\tExpressionProxy.prototype.constructor = ExpressionProxy;\n\t\n\t\t\tExpressionProxy.prototype.bubble = function bubble ( actuallyChanged ) {\n\t\t\t\t// refresh the keypath\n\t\t\t\tif ( actuallyChanged === void 0 ) actuallyChanged = true;\n\t\n\t\t\t\tif ( this.registered ) delete this.root.expressions[ this.keypath ];\n\t\t\t\tthis.keypath = undefined;\n\t\n\t\t\t\tif ( actuallyChanged ) {\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\tthis.handleChange();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.get = function get ( shouldCapture ) {\n\t\t\t\tif ( shouldCapture ) capture( this );\n\t\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tthis.value = this.getValue();\n\t\t\t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t}\n\t\n\t\t\t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.getKeypath = function getKeypath () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.template ) return '@undefined';\n\t\t\t\tif ( !this.keypath ) {\n\t\t\t\t\tthis.keypath = '@' + this.template.s.replace( /_(\\d+)/g, function ( match, i ) {\n\t\t\t\t\t\tif ( i >= this$1.models.length ) return match;\n\t\n\t\t\t\t\t\tvar model = this$1.models[i];\n\t\t\t\t\t\treturn model ? model.getKeypath() : '@undefined';\n\t\t\t\t\t});\n\t\n\t\t\t\t\tthis.root.expressions[ this.keypath ] = this;\n\t\t\t\t\tthis.registered = true;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.keypath;\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.getValue = function getValue () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tstartCapturing();\n\t\t\t\tvar result;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tvar params = this.models.map( function ( m ) { return m ? m.get( true ) : undefined; } );\n\t\t\t\t\tresult = this.fn.apply( this.fragment.ractive, params );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n\t\t\t\t}\n\t\n\t\t\t\tvar dependencies = stopCapturing();\n\t\t\t\t// remove missing deps\n\t\t\t\tthis.dependencies.filter( function ( d ) { return !~dependencies.indexOf( d ); } ).forEach( function ( d ) {\n\t\t\t\t\td.unregister( this$1 );\n\t\t\t\t\tremoveFromArray( this$1.dependencies, d );\n\t\t\t\t});\n\t\t\t\t// register new deps\n\t\t\t\tdependencies.filter( function ( d ) { return !~this$1.dependencies.indexOf( d ); } ).forEach( function ( d ) {\n\t\t\t\t\td.register( this$1 );\n\t\t\t\t\tthis$1.dependencies.push( d );\n\t\t\t\t});\n\t\n\t\t\t\treturn result;\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.handleChange = function handleChange$1 () {\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\tthis.links.forEach( marked );\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\tthis.children.forEach( handleChange );\n\t\n\t\t\t\tthis.clearUnresolveds();\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n\t\t\t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar child = new ComputationChild( this, key );\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.childByKey[ key ];\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.mark = function mark () {\n\t\t\t\tthis.handleChange();\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\t\tvar idx = this.models.indexOf( previous );\n\t\n\t\t\t\tif ( ~idx ) {\n\t\t\t\t\tnext = rebindMatch( this.template.r[idx], next, previous );\n\t\t\t\t\tif ( next !== previous ) {\n\t\t\t\t\t\tprevious.unregister( this );\n\t\t\t\t\t\tthis.models.splice( idx, 1, next );\n\t\t\t\t\t\t// TODO: set up a resolver if there is no next?\n\t\t\t\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.bubble( !safe );\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.retrieve = function retrieve () {\n\t\t\t\treturn this.get();\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.teardown = function teardown () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.unbind();\n\t\t\t\tthis.fragment = undefined;\n\t\t\t\tif ( this.dependencies ) this.dependencies.forEach( function ( d ) { return d.unregister( this$1 ); } );\n\t\t\t\tModel.prototype.teardown.call(this);\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.unregister = function unregister( dep ) {\n\t\t\t\tModel.prototype.unregister.call( this, dep );\n\t\t\t\tif ( !this.deps.length ) this.teardown();\n\t\t\t};\n\t\n\t\t\tExpressionProxy.prototype.unbind = function unbind$1 () {\n\t\t\t\tthis.resolvers.forEach( unbind );\n\t\t\t};\n\t\n\t\t\treturn ExpressionProxy;\n\t\t}(Model));\n\t\n\t\tvar ReferenceExpressionChild = (function (Model) {\n\t\t\tfunction ReferenceExpressionChild ( parent, key ) {\n\t\t\t\tModel.call ( this, parent, key );\n\t\t\t}\n\t\n\t\t\tReferenceExpressionChild.prototype = Object.create( Model && Model.prototype );\n\t\t\tReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;\n\t\n\t\t\tReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {\n\t\t\t\tif ( isEqual( value, this.value ) ) return;\n\t\n\t\t\t\tvar parent = this.parent, keys = [ this.key ];\n\t\t\t\twhile ( parent ) {\n\t\t\t\t\tif ( parent.base ) {\n\t\t\t\t\t\tvar target = parent.model.joinAll( keys );\n\t\t\t\t\t\ttarget.applyValue( value );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkeys.unshift( parent.key );\n\t\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {\n\t\t\t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar child = new ReferenceExpressionChild( this, key );\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.childByKey[ key ];\n\t\t\t};\n\t\n\t\t\tReferenceExpressionChild.prototype.retrieve = function retrieve () {\n\t\t\t\tvar parent = this.parent.get();\n\t\t\t\treturn parent && parent[ this.key ];\n\t\t\t};\n\t\n\t\t\treturn ReferenceExpressionChild;\n\t\t}(Model));\n\t\n\t\tvar ReferenceExpressionProxy = (function (Model) {\n\t\t\tfunction ReferenceExpressionProxy ( fragment, template ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tModel.call( this, null, null );\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.root = fragment.ractive.viewmodel;\n\t\t\t\tthis.template = template;\n\t\n\t\t\t\tthis.resolvers = [];\n\t\n\t\t\t\tthis.base = resolve$2( fragment, template );\n\t\t\t\tvar baseResolver;\n\t\n\t\t\t\tif ( !this.base ) {\n\t\t\t\t\tbaseResolver = fragment.resolve( template.r, function ( model ) {\n\t\t\t\t\t\tthis$1.base = model;\n\t\t\t\t\t\tthis$1.bubble();\n\t\n\t\t\t\t\t\tremoveFromArray( this$1.resolvers, baseResolver );\n\t\t\t\t\t});\n\t\n\t\t\t\t\tthis.resolvers.push( baseResolver );\n\t\t\t\t}\n\t\n\t\t\t\tvar intermediary = this.intermediary = {\n\t\t\t\t\thandleChange: function () { return this$1.handleChange(); },\n\t\t\t\t\trebinding: function ( next, previous ) {\n\t\t\t\t\t\tif ( previous === this$1.base ) {\n\t\t\t\t\t\t\tnext = rebindMatch( template, next, previous );\n\t\t\t\t\t\t\tif ( next !== this$1.base ) {\n\t\t\t\t\t\t\t\tthis$1.base.unregister( intermediary );\n\t\t\t\t\t\t\t\tthis$1.base = next;\n\t\t\t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar idx = this$1.members.indexOf( previous );\n\t\t\t\t\t\t\tif ( ~idx ) {\n\t\t\t\t\t\t\t\t// only direct references will rebind... expressions handle themselves\n\t\t\t\t\t\t\t\tnext = rebindMatch( template.m[idx].n, next, previous );\n\t\t\t\t\t\t\t\tif ( next !== this$1.members[idx] ) {\n\t\t\t\t\t\t\t\t\tthis$1.members.splice( idx, 1, next );\n\t\t\t\t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( next !== previous ) previous.unregister( intermediary );\n\t\t\t\t\t\tif ( next ) next.addShuffleTask( function () { return next.register( intermediary ); } );\n\t\n\t\t\t\t\t\tthis$1.bubble();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tthis.members = template.m.map( function ( template, i ) {\n\t\t\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t\t\treturn { get: function () { return template; } };\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar model;\n\t\t\t\t\tvar resolver;\n\t\n\t\t\t\t\tif ( template.t === REFERENCE ) {\n\t\t\t\t\t\tmodel = resolveReference( fragment, template.n );\n\t\n\t\t\t\t\t\tif ( model ) {\n\t\t\t\t\t\t\tmodel.register( intermediary );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolver = fragment.resolve( template.n, function ( model ) {\n\t\t\t\t\t\t\t\tthis$1.members[i] = model;\n\t\n\t\t\t\t\t\t\t\tmodel.register( intermediary );\n\t\t\t\t\t\t\t\tthis$1.handleChange();\n\t\n\t\t\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn model;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmodel = new ExpressionProxy( fragment, template );\n\t\t\t\t\tmodel.register( intermediary );\n\t\t\t\t\treturn model;\n\t\t\t\t});\n\t\n\t\t\t\tthis.isUnresolved = true;\n\t\t\t\tthis.bubble();\n\t\t\t}\n\t\n\t\t\tReferenceExpressionProxy.prototype = Object.create( Model && Model.prototype );\n\t\t\tReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;\n\t\n\t\t\tReferenceExpressionProxy.prototype.bubble = function bubble () {\n\t\t\t\tif ( !this.base ) return;\n\t\t\t\tif ( !this.dirty ) this.handleChange();\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.forceResolution = function forceResolution () {\n\t\t\t\tthis.resolvers.forEach( function ( resolver ) { return resolver.forceResolution(); } );\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.bubble();\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.get = function get ( shouldCapture ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.bubble();\n\t\n\t\t\t\t\tvar i = this.members.length, resolved = true;\n\t\t\t\t\twhile ( resolved && i-- ) {\n\t\t\t\t\t\tif ( !this$1.members[i] ) resolved = false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.base && resolved ) {\n\t\t\t\t\t\tvar keys = this.members.map( function ( m ) { return escapeKey( String( m.get() ) ); } );\n\t\t\t\t\t\tvar model = this.base.joinAll( keys );\n\t\n\t\t\t\t\t\tif ( model !== this.model ) {\n\t\t\t\t\t\t\tif ( this.model ) {\n\t\t\t\t\t\t\t\tthis.model.unregister( this );\n\t\t\t\t\t\t\t\tthis.model.unregisterTwowayBinding( this );\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis.model = model;\n\t\t\t\t\t\t\tthis.parent = model.parent;\n\t\t\t\t\t\t\tthis.model.register( this );\n\t\t\t\t\t\t\tthis.model.registerTwowayBinding( this );\n\t\n\t\t\t\t\t\t\tif ( this.keypathModel ) this.keypathModel.handleChange();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.value = this.model ? this.model.get( shouldCapture ) : undefined;\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tthis.mark();\n\t\t\t\t\treturn this.value;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.model ? this.model.get( shouldCapture ) : undefined;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// indirect two-way bindings\n\t\t\tReferenceExpressionProxy.prototype.getValue = function getValue () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.value = this.model ? this.model.get() : undefined;\n\t\n\t\t\t\tvar i = this.bindings.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar value = this$1.bindings[i].getValue();\n\t\t\t\t\tif ( value !== this$1.value ) return value;\n\t\t\t\t}\n\t\n\t\t\t\t// check one-way bindings\n\t\t\t\tvar oneway = findBoundValue( this.deps );\n\t\t\t\tif ( oneway ) return oneway.value;\n\t\n\t\t\t\treturn this.value;\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {\n\t\t\t\treturn this.model ? this.model.getKeypath() : '@undefined';\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.handleChange = function handleChange$1 () {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.mark();\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n\t\t\t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar child = new ReferenceExpressionChild( this, key );\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.childByKey[ key ];\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.mark = function mark$1 () {\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\t}\n\t\n\t\t\t\tthis.links.forEach( marked );\n\t\t\t\tthis.children.forEach( mark );\n\t\t\t\tthis.clearUnresolveds();\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.retrieve = function retrieve () {\n\t\t\t\treturn this.value;\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.rebinding = function rebinding () { }; // NOOP\n\t\n\t\t\tReferenceExpressionProxy.prototype.set = function set ( value ) {\n\t\t\t\tif ( !this.model ) throw new Error( 'Unresolved reference expression. This should not happen!' );\n\t\t\t\tthis.model.set( value );\n\t\t\t};\n\t\n\t\t\tReferenceExpressionProxy.prototype.unbind = function unbind$1 () {\n\t\t\t\tthis.resolvers.forEach( unbind );\n\t\t\t\tif ( this.model ) {\n\t\t\t\t\tthis.model.unregister( this );\n\t\t\t\t\tthis.model.unregisterTwowayBinding( this );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn ReferenceExpressionProxy;\n\t\t}(Model));\n\t\n\t\tfunction resolve$2 ( fragment, template ) {\n\t\t\tif ( template.r ) {\n\t\t\t\treturn resolveReference( fragment, template.r );\n\t\t\t}\n\t\n\t\t\telse if ( template.x ) {\n\t\t\t\treturn new ExpressionProxy( fragment, template.x );\n\t\t\t}\n\t\n\t\t\telse if ( template.rx ) {\n\t\t\t\treturn new ReferenceExpressionProxy( fragment, template.rx );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction resolveAliases( section ) {\n\t\t\tif ( section.template.z ) {\n\t\t\t\tsection.aliases = {};\n\t\n\t\t\t\tvar refs = section.template.z;\n\t\t\t\tfor ( var i = 0; i < refs.length; i++ ) {\n\t\t\t\t\tsection.aliases[ refs[i].n ] = resolve$2( section.parentFragment, refs[i].x );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar Alias = (function (Item) {\n\t\t\tfunction Alias ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.fragment = null;\n\t\t\t}\n\t\n\t\t\tAlias.prototype = Object.create( Item && Item.prototype );\n\t\t\tAlias.prototype.constructor = Alias;\n\t\n\t\t\tAlias.prototype.bind = function bind () {\n\t\t\t\tresolveAliases( this );\n\t\n\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: this.template.f\n\t\t\t\t}).bind();\n\t\t\t};\n\t\n\t\t\tAlias.prototype.detach = function detach () {\n\t\t\t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n\t\t\t};\n\t\n\t\t\tAlias.prototype.find = function find ( selector ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\treturn this.fragment.find( selector );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tAlias.prototype.findAll = function findAll ( selector, query ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tAlias.prototype.findComponent = function findComponent ( name ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tAlias.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tAlias.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\t\treturn this.fragment && this.fragment.firstNode( skipParent );\n\t\t\t};\n\t\n\t\t\tAlias.prototype.rebinding = function rebinding () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.locked ) return;\n\t\t\t\tthis.locked = true;\n\t\t\t\trunloop.scheduleTask( function () {\n\t\t\t\t\tthis$1.locked = false;\n\t\t\t\t\tresolveAliases( this$1 );\n\t\t\t\t});\n\t\t\t};\n\t\n\t\t\tAlias.prototype.render = function render ( target ) {\n\t\t\t\tthis.rendered = true;\n\t\t\t\tif ( this.fragment ) this.fragment.render( target );\n\t\t\t};\n\t\n\t\t\tAlias.prototype.toString = function toString ( escape ) {\n\t\t\t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n\t\t\t};\n\t\n\t\t\tAlias.prototype.unbind = function unbind () {\n\t\t\t\tthis.aliases = {};\n\t\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t\t};\n\t\n\t\t\tAlias.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n\t\t\t\tthis.rendered = false;\n\t\t\t};\n\t\n\t\t\tAlias.prototype.update = function update () {\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tthis.fragment.update();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Alias;\n\t\t}(Item));\n\t\n\t\tfunction findElement( start, orComponent, name ) {\n\t\t\tif ( orComponent === void 0 ) orComponent = true;\n\t\n\t\t\twhile ( start && ( start.type !== ELEMENT || ( name && start.name !== name ) ) && ( !orComponent || start.type !== COMPONENT ) ) {\n\t\t\t\t// start is a fragment - look at the owner\n\t\t\t\tif ( start.owner ) start = start.owner;\n\t\t\t\t// start is a component or yielder - look at the container\n\t\t\t\telse if ( start.component ) start = start.containerFragment || start.component.parentFragment;\n\t\t\t\t// start is an item - look at the parent\n\t\t\t\telse if ( start.parent ) start = start.parent;\n\t\t\t\t// start is an item without a parent - look at the parent fragment\n\t\t\t\telse if ( start.parentFragment ) start = start.parentFragment;\n\t\n\t\t\t\telse start = undefined;\n\t\t\t}\n\t\n\t\t\treturn start;\n\t\t}\n\t\n\t\tvar space = /\\s+/;\n\t\tvar remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\n\t\tvar escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\2/gi;\n\t\tvar value = /\\0(\\d+)/g;\n\t\n\t\tfunction readStyle ( css ) {\n\t\t\tvar values = [];\n\t\n\t\t\tif ( typeof css !== 'string' ) return {};\n\t\n\t\t\treturn css.replace( escape, function ( match ) { return (\"\\u0000\" + (values.push( match ) - 1)); })\n\t\t\t\t.replace( remove, '' )\n\t\t\t\t.split( ';' )\n\t\t\t\t.filter( function ( rule ) { return !!rule.trim(); } )\n\t\t\t\t.map( function ( rule ) { return rule.replace( value, function ( match, n ) { return values[ n ]; } ); } )\n\t\t\t\t.reduce(function ( rules, rule ) {\n\t\t\t\t\tvar i = rule.indexOf(':');\n\t\t\t\t\tvar name = rule.substr( 0, i ).trim();\n\t\t\t\t\trules[ name ] = rule.substr( i + 1 ).trim();\n\t\t\t\t\treturn rules;\n\t\t\t\t}, {});\n\t\t}\n\t\n\t\tfunction readClass ( str ) {\n\t\t\tvar list = str.split( space );\n\t\n\t\t\t// remove any empty entries\n\t\t\tvar i = list.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !list[i] ) list.splice( i, 1 );\n\t\t\t}\n\t\n\t\t\treturn list;\n\t\t}\n\t\n\t\tvar textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];\n\t\n\t\tfunction getUpdateDelegate ( attribute ) {\n\t\t\tvar element = attribute.element, name = attribute.name;\n\t\n\t\t\tif ( name === 'id' ) return updateId;\n\t\n\t\t\tif ( name === 'value' ) {\n\t\t\t\tif ( attribute.interpolator ) attribute.interpolator.bound = true;\n\t\n\t\t\t\t// special case - selects\n\t\t\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\t\t\treturn element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t\t\t}\n\t\n\t\t\t\tif ( element.name === 'textarea' ) return updateStringValue;\n\t\n\t\t\t\t// special case - contenteditable\n\t\t\t\tif ( element.getAttribute( 'contenteditable' ) != null ) return updateContentEditableValue;\n\t\n\t\t\t\t// special case - <input>\n\t\t\t\tif ( element.name === 'input' ) {\n\t\t\t\t\tvar type = element.getAttribute( 'type' );\n\t\n\t\t\t\t\t// type='file' value='{{fileList}}'>\n\t\t\t\t\tif ( type === 'file' ) return noop; // read-only\n\t\n\t\t\t\t\t// type='radio' name='{{twoway}}'\n\t\t\t\t\tif ( type === 'radio' && element.binding && element.binding.attribute.name === 'name' ) return updateRadioValue;\n\t\n\t\t\t\t\tif ( ~textTypes.indexOf( type ) ) return updateStringValue;\n\t\t\t\t}\n\t\n\t\t\t\treturn updateValue;\n\t\t\t}\n\t\n\t\t\tvar node = element.node;\n\t\n\t\t\t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n\t\t\tif ( attribute.isTwoway && name === 'name' ) {\n\t\t\t\tif ( node.type === 'radio' ) return updateRadioName;\n\t\t\t\tif ( node.type === 'checkbox' ) return updateCheckboxName;\n\t\t\t}\n\t\n\t\t\tif ( name === 'style' ) return updateStyleAttribute;\n\t\n\t\t\tif ( name.indexOf( 'style-' ) === 0 ) return updateInlineStyle;\n\t\n\t\t\t// special case - class names. IE fucks things up, again\n\t\t\tif ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === html ) ) return updateClassName;\n\t\n\t\t\tif ( name.indexOf( 'class-' ) === 0 ) return updateInlineClass;\n\t\n\t\t\tif ( attribute.isBoolean ) {\n\t\t\t\tvar type$1 = element.getAttribute( 'type' );\n\t\t\t\tif ( attribute.interpolator && name === 'checked' && ( type$1 === 'checkbox' || type$1 === 'radio' ) ) attribute.interpolator.bound = true;\n\t\t\t\treturn updateBoolean;\n\t\t\t}\n\t\n\t\t\tif ( attribute.namespace && attribute.namespace !== attribute.node.namespaceURI ) return updateNamespacedAttribute;\n\t\n\t\t\treturn updateAttribute;\n\t\t}\n\t\n\t\tfunction updateId ( reset ) {\n\t\t\tvar ref = this, node = ref.node;\n\t\t\tvar value = this.getValue();\n\t\n\t\t\t// remove the mapping to this node if it hasn't already been replaced\n\t\t\tif ( this.ractive.nodes[ node.id ] === node ) delete this.ractive.nodes[ node.id ];\n\t\t\tif ( reset ) return node.removeAttribute( 'id' );\n\t\n\t\t\tthis.ractive.nodes[ value ] = node;\n\t\n\t\t\tnode.id = value;\n\t\t}\n\t\n\t\tfunction updateMultipleSelectValue ( reset ) {\n\t\t\tvar value = this.getValue();\n\t\n\t\t\tif ( !isArray( value ) ) value = [ value ];\n\t\n\t\t\tvar options = this.node.options;\n\t\t\tvar i = options.length;\n\t\n\t\t\tif ( reset ) {\n\t\t\t\twhile ( i-- ) options[i].selected = false;\n\t\t\t} else {\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar option = options[i];\n\t\t\t\t\tvar optionValue = option._ractive ?\n\t\t\t\t\t\toption._ractive.value :\n\t\t\t\t\t\toption.value; // options inserted via a triple don't have _ractive\n\t\n\t\t\t\t\toption.selected = arrayContains( value, optionValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateSelectValue ( reset ) {\n\t\t\tvar value = this.getValue();\n\t\n\t\t\tif ( !this.locked ) { // TODO is locked still a thing?\n\t\t\t\tthis.node._ractive.value = value;\n\t\n\t\t\t\tvar options = this.node.options;\n\t\t\t\tvar i = options.length;\n\t\t\t\tvar wasSelected = false;\n\t\n\t\t\t\tif ( reset ) {\n\t\t\t\t\twhile ( i-- ) options[i].selected = false;\n\t\t\t\t} else {\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvar option = options[i];\n\t\t\t\t\t\tvar optionValue = option._ractive ?\n\t\t\t\t\t\t\toption._ractive.value :\n\t\t\t\t\t\t\toption.value; // options inserted via a triple don't have _ractive\n\t\t\t\t\t\tif ( option.disabled && option.selected ) wasSelected = true;\n\t\n\t\t\t\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t\t\t\t\t\t\toption.selected = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( !wasSelected ) this.node.selectedIndex = -1;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tfunction updateContentEditableValue ( reset ) {\n\t\t\tvar value = this.getValue();\n\t\n\t\t\tif ( !this.locked ) {\n\t\t\t\tif ( reset ) this.node.innerHTML = '';\n\t\t\t\telse this.node.innerHTML = value === undefined ? '' : value;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateRadioValue ( reset ) {\n\t\t\tvar node = this.node;\n\t\t\tvar wasChecked = node.checked;\n\t\n\t\t\tvar value = this.getValue();\n\t\n\t\t\tif ( reset ) return node.checked = false;\n\t\n\t\t\t//node.value = this.element.getAttribute( 'value' );\n\t\t\tnode.value = this.node._ractive.value = value;\n\t\t\tnode.checked = value === this.element.getAttribute( 'name' );\n\t\n\t\t\t// This is a special case - if the input was checked, and the value\n\t\t\t// changed so that it's no longer checked, the twoway binding is\n\t\t\t// most likely out of date. To fix it we have to jump through some\n\t\t\t// hoops... this is a little kludgy but it works\n\t\t\tif ( wasChecked && !node.checked && this.element.binding && this.element.binding.rendered ) {\n\t\t\t\tthis.element.binding.group.model.set( this.element.binding.group.getValue() );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateValue ( reset ) {\n\t\t\tif ( !this.locked ) {\n\t\t\t\tif ( reset ) {\n\t\t\t\t\tthis.node.removeAttribute( 'value' );\n\t\t\t\t\tthis.node.value = this.node._ractive.value = null;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar value = this.getValue();\n\t\n\t\t\t\tthis.node.value = this.node._ractive.value = value;\n\t\t\t\tthis.node.setAttribute( 'value', value );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateStringValue ( reset ) {\n\t\t\tif ( !this.locked ) {\n\t\t\t\tif ( reset ) {\n\t\t\t\t\tthis.node._ractive.value = '';\n\t\t\t\t\tthis.node.removeAttribute( 'value' );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar value = this.getValue();\n\t\n\t\t\t\tthis.node._ractive.value = value;\n\t\n\t\t\t\tthis.node.value = safeToStringValue( value );\n\t\t\t\tthis.node.setAttribute( 'value', safeToStringValue( value ) );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateRadioName ( reset ) {\n\t\t\tif ( reset ) this.node.checked = false;\n\t\t\telse this.node.checked = ( this.getValue() == this.node._ractive.value );\n\t\t}\n\t\n\t\tfunction updateCheckboxName ( reset ) {\n\t\t\tvar ref = this, element = ref.element, node = ref.node;\n\t\t\tvar binding = element.binding;\n\t\n\t\t\tvar value = this.getValue();\n\t\t\tvar valueAttribute = element.getAttribute( 'value' );\n\t\n\t\t\tif ( reset ) {\n\t\t\t\t// TODO: WAT?\n\t\t\t}\n\t\n\t\t\tif ( !isArray( value ) ) {\n\t\t\t\tbinding.isChecked = node.checked = ( value == valueAttribute );\n\t\t\t} else {\n\t\t\t\tvar i = value.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( valueAttribute == value[i] ) {\n\t\t\t\t\t\tbinding.isChecked = node.checked = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbinding.isChecked = node.checked = false;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateStyleAttribute ( reset ) {\n\t\t\tvar props = reset ? {} : readStyle( this.getValue() || '' );\n\t\t\tvar style = this.node.style;\n\t\t\tvar keys = Object.keys( props );\n\t\t\tvar prev = this.previous || [];\n\t\n\t\t\tvar i = 0;\n\t\t\twhile ( i < keys.length ) {\n\t\t\t\tif ( keys[i] in style ) {\n\t\t\t\t\tvar safe = props[ keys[i] ].replace( '!important', '' );\n\t\t\t\t\tstyle.setProperty( keys[i], safe, safe.length !== props[ keys[i] ].length ? 'important' : '' );\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\n\t\t\t// remove now-missing attrs\n\t\t\ti = prev.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !~keys.indexOf( prev[i] ) && prev[i] in style ) style.setProperty( prev[i], '', '' );\n\t\t\t}\n\t\n\t\t\tthis.previous = keys;\n\t\t}\n\t\n\t\tfunction updateInlineStyle ( reset ) {\n\t\t\tif ( !this.style ) {\n\t\t\t\tthis.style = decamelize( this.name.substr( 6 ) );\n\t\t\t}\n\t\n\t\t\tvar value = reset ? '' : safeToStringValue( this.getValue() );\n\t\t\tvar safe = value.replace( '!important', '' );\n\t\t\tthis.node.style.setProperty( this.style, safe, safe.length !== value.length ? 'important' : '' );\n\t\t}\n\t\n\t\tfunction updateClassName ( reset ) {\n\t\t\tvar value = reset ? [] : readClass( safeToStringValue( this.getValue() ) );\n\t\t\tvar attr = readClass( this.node.className );\n\t\t\tvar prev = this.previous || attr.slice( 0 );\n\t\n\t\t\tvar i = 0;\n\t\t\twhile ( i < value.length ) {\n\t\t\t\tif ( !~attr.indexOf( value[i] ) ) attr.push( value[i] );\n\t\t\t\ti++;\n\t\t\t}\n\t\n\t\t\t// remove now-missing classes\n\t\t\ti = prev.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !~value.indexOf( prev[i] ) ) {\n\t\t\t\t\tvar idx = attr.indexOf( prev[i] );\n\t\t\t\t\tif ( ~idx ) attr.splice( idx, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar className = attr.join( ' ' );\n\t\n\t\t\tif ( className !== this.node.className ) {\n\t\t\t\tthis.node.className = className;\n\t\t\t}\n\t\n\t\t\tthis.previous = value;\n\t\t}\n\t\n\t\tfunction updateInlineClass ( reset ) {\n\t\t\tvar name = this.name.substr( 6 );\n\t\t\tvar attr = readClass( this.node.className );\n\t\t\tvar value = reset ? false : this.getValue();\n\t\n\t\t\tif ( !this.inlineClass ) this.inlineClass = name;\n\t\n\t\t\tif ( value && !~attr.indexOf( name ) ) attr.push( name );\n\t\t\telse if ( !value && ~attr.indexOf( name ) ) attr.splice( attr.indexOf( name ), 1 );\n\t\n\t\t\tthis.node.className = attr.join( ' ' );\n\t\t}\n\t\n\t\tfunction updateBoolean ( reset ) {\n\t\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t\t// otherwise the cursor will often be sent to the wrong place\n\t\t\tif ( !this.locked ) {\n\t\t\t\tif ( reset ) {\n\t\t\t\t\tif ( this.useProperty ) this.node[ this.propertyName ] = false;\n\t\t\t\t\tthis.node.removeAttribute( this.propertyName );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.useProperty ) {\n\t\t\t\t\tthis.node[ this.propertyName ] = this.getValue();\n\t\t\t\t} else {\n\t\t\t\t\tif ( this.getValue() ) {\n\t\t\t\t\t\tthis.node.setAttribute( this.propertyName, '' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.node.removeAttribute( this.propertyName );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction updateAttribute ( reset ) {\n\t\t\tif ( reset ) this.node.removeAttribute( this.name );\n\t\t\telse this.node.setAttribute( this.name, safeToStringValue( this.getString() ) );\n\t\t}\n\t\n\t\tfunction updateNamespacedAttribute ( reset ) {\n\t\t\tif ( reset ) this.node.removeAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ) );\n\t\t\telse this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) );\n\t\t}\n\t\n\t\tvar propertyNames = {\n\t\t\t'accept-charset': 'acceptCharset',\n\t\t\taccesskey: 'accessKey',\n\t\t\tbgcolor: 'bgColor',\n\t\t\t'class': 'className',\n\t\t\tcodebase: 'codeBase',\n\t\t\tcolspan: 'colSpan',\n\t\t\tcontenteditable: 'contentEditable',\n\t\t\tdatetime: 'dateTime',\n\t\t\tdirname: 'dirName',\n\t\t\t'for': 'htmlFor',\n\t\t\t'http-equiv': 'httpEquiv',\n\t\t\tismap: 'isMap',\n\t\t\tmaxlength: 'maxLength',\n\t\t\tnovalidate: 'noValidate',\n\t\t\tpubdate: 'pubDate',\n\t\t\treadonly: 'readOnly',\n\t\t\trowspan: 'rowSpan',\n\t\t\ttabindex: 'tabIndex',\n\t\t\tusemap: 'useMap'\n\t\t};\n\t\n\t\tfunction lookupNamespace ( node, prefix ) {\n\t\t\tvar qualified = \"xmlns:\" + prefix;\n\t\n\t\t\twhile ( node ) {\n\t\t\t\tif ( node.hasAttribute && node.hasAttribute( qualified ) ) return node.getAttribute( qualified );\n\t\t\t\tnode = node.parentNode;\n\t\t\t}\n\t\n\t\t\treturn namespaces[ prefix ];\n\t\t}\n\t\n\t\tvar Attribute = (function (Item) {\n\t\t\tfunction Attribute ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.name = options.template.n;\n\t\t\t\tthis.namespace = null;\n\t\n\t\t\t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n\t\t\t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n\t\t\t\tthis.parentFragment = options.parentFragment; // shared\n\t\t\t\tthis.ractive = this.parentFragment.ractive;\n\t\n\t\t\t\tthis.rendered = false;\n\t\t\t\tthis.updateDelegate = null;\n\t\t\t\tthis.fragment = null;\n\t\n\t\t\t\tthis.element.attributeByName[ this.name ] = this;\n\t\n\t\t\t\tif ( !isArray( options.template.f ) ) {\n\t\t\t\t\tthis.value = options.template.f;\n\t\t\t\t\tif ( this.value === 0 ) {\n\t\t\t\t\t\tthis.value = '';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\ttemplate: options.template.f\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tthis.interpolator = this.fragment &&\n\t\t\t\t\tthis.fragment.items.length === 1 &&\n\t\t\t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n\t\t\t\t\tthis.fragment.items[0];\n\t\n\t\t\t\tif ( this.interpolator ) this.interpolator.owner = this;\n\t\t\t}\n\t\n\t\t\tAttribute.prototype = Object.create( Item && Item.prototype );\n\t\t\tAttribute.prototype.constructor = Attribute;\n\t\n\t\t\tAttribute.prototype.bind = function bind () {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.bind();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.bubble = function bubble () {\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\t\tthis.element.bubble();\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.destroyed = function destroyed () {\n\t\t\t\tthis.updateDelegate( true );\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.getString = function getString () {\n\t\t\t\treturn this.fragment ?\n\t\t\t\t\tthis.fragment.toString() :\n\t\t\t\t\tthis.value != null ? '' + this.value : '';\n\t\t\t};\n\t\n\t\t\t// TODO could getValue ever be called for a static attribute,\n\t\t\t// or can we assume that this.fragment exists?\n\t\t\tAttribute.prototype.getValue = function getValue () {\n\t\t\t\treturn this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.render = function render () {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tthis.node = node;\n\t\n\t\t\t\t// should we use direct property access, or setAttribute?\n\t\t\t\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\t\t\t\tthis.propertyName = propertyNames[ this.name ] || this.name;\n\t\n\t\t\t\t\tif ( node[ this.propertyName ] !== undefined ) {\n\t\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\t\tif ( booleanAttributes.test( this.name ) || this.isTwoway ) {\n\t\t\t\t\t\tthis.isBoolean = true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.propertyName === 'value' ) {\n\t\t\t\t\t\tnode._ractive.value = this.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( node.namespaceURI ) {\n\t\t\t\t\tvar index = this.name.indexOf( ':' );\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\tthis.namespace = lookupNamespace( node, this.name.slice( 0, index ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.namespace = node.namespaceURI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.rendered = true;\n\t\t\t\tthis.updateDelegate = getUpdateDelegate( this );\n\t\t\t\tthis.updateDelegate();\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.toString = function toString () {\n\t\t\t\tvar value = this.getValue();\n\t\n\t\t\t\t// Special case - select and textarea values (should not be stringified)\n\t\t\t\tif ( this.name === 'value' && ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Special case  bound radio `name` attributes\n\t\t\t\tif ( this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute( 'type' ) === 'radio' ) {\n\t\t\t\t\treturn (\"name=\\\"{{\" + (this.interpolator.model.getKeypath()) + \"}}\\\"\");\n\t\t\t\t}\n\t\n\t\t\t\t// Special case - style and class attributes and directives\n\t\t\t\tif ( this.owner === this.element && ( this.name === 'style' || this.name === 'class' || this.style || this.inlineClass ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( !this.rendered && this.owner === this.element && ( !this.name.indexOf( 'style-' ) || !this.name.indexOf( 'class-' ) ) ) {\n\t\t\t\t\tif ( !this.name.indexOf( 'style-' ) ) {\n\t\t\t\t\t\tthis.style = decamelize( this.name.substr( 6 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.inlineClass = this.name.substr( 6 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( booleanAttributes.test( this.name ) ) return value ? this.name : '';\n\t\t\t\tif ( value == null ) return '';\n\t\n\t\t\t\tvar str = safeAttributeString( this.getString() );\n\t\t\t\treturn str ?\n\t\t\t\t\t(\"\" + (this.name) + \"=\\\"\" + str + \"\\\"\") :\n\t\t\t\t\tthis.name;\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.unbind = function unbind () {\n\t\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.unrender = function unrender () {\n\t\t\t\tthis.updateDelegate( true );\n\t\n\t\t\t\tthis.rendered = false;\n\t\t\t};\n\t\n\t\t\tAttribute.prototype.update = function update () {\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t\t\tif ( this.rendered ) this.updateDelegate();\n\t\t\t\t\tif ( this.isTwoway && !this.locked ) {\n\t\t\t\t\t\tthis.interpolator.twowayBinding.lastVal( true, this.interpolator.model.get() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Attribute;\n\t\t}(Item));\n\t\n\t\tvar BindingFlag = (function (Item) {\n\t\t\tfunction BindingFlag ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\t\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\t\t\tthis.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n\t\n\t\t\t\tif ( this.element.type === ELEMENT ) {\n\t\t\t\t\tif ( isArray( options.template.f ) ) {\n\t\t\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\ttemplate: options.template.f\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.interpolator = this.fragment &&\n\t\t\t\t\t\t\t\t\t\tthis.fragment.items.length === 1 &&\n\t\t\t\t\t\t\t\t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n\t\t\t\t\t\t\t\t\t\tthis.fragment.items[0];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tBindingFlag.prototype = Object.create( Item && Item.prototype );\n\t\t\tBindingFlag.prototype.constructor = BindingFlag;\n\t\n\t\t\tBindingFlag.prototype.bind = function bind () {\n\t\t\t\tif ( this.fragment ) this.fragment.bind();\n\t\t\t\tset$2( this, this.getValue(), true );\n\t\t\t};\n\t\n\t\t\tBindingFlag.prototype.bubble = function bubble () {\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.element.bubble();\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tBindingFlag.prototype.getValue = function getValue () {\n\t\t\t\tif ( this.fragment ) return this.fragment.valueOf();\n\t\t\t\telse if ( 'value' in this ) return this.value;\n\t\t\t\telse if ( 'f' in this.template ) return this.template.f;\n\t\t\t\telse return true;\n\t\t\t};\n\t\n\t\t\tBindingFlag.prototype.render = function render () {\n\t\t\t\tset$2( this, this.getValue(), true );\n\t\t\t};\n\t\n\t\t\tBindingFlag.prototype.toString = function toString () { return ''; };\n\t\n\t\t\tBindingFlag.prototype.unbind = function unbind () {\n\t\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\n\t\t\t\tdelete this.element[ this.flag ];\n\t\t\t};\n\t\n\t\t\tBindingFlag.prototype.unrender = function unrender () {\n\t\t\t\tif ( this.element.rendered ) this.element.recreateTwowayBinding();\n\t\t\t};\n\t\n\t\t\tBindingFlag.prototype.update = function update () {\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t\t\tset$2( this, this.getValue(), true );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn BindingFlag;\n\t\t}(Item));\n\t\n\t\tfunction set$2 ( flag, value, update ) {\n\t\t\tif ( value === 0 ) {\n\t\t\t\tflag.value = true;\n\t\t\t} else if ( value === 'true' ) {\n\t\t\t\tflag.value = true;\n\t\t\t} else if ( value === 'false' || value === '0' ) {\n\t\t\t\tflag.value = false;\n\t\t\t} else {\n\t\t\t\tflag.value = value;\n\t\t\t}\n\t\n\t\t\tvar current = flag.element[ flag.flag ];\n\t\t\tflag.element[ flag.flag ] = flag.value;\n\t\t\tif ( update && !flag.element.attributes.binding && current !== flag.value ) {\n\t\t\t\tflag.element.recreateTwowayBinding();\n\t\t\t}\n\t\n\t\t\treturn flag.value;\n\t\t}\n\t\n\t\tvar div$1 = doc ? createElement( 'div' ) : null;\n\t\n\t\tvar attributes = false;\n\t\tfunction inAttributes() { return attributes; }\n\t\tfunction doInAttributes( fn ) {\n\t\t\tattributes = true;\n\t\t\tfn();\n\t\t\tattributes = false;\n\t\t}\n\t\n\t\tvar ConditionalAttribute = (function (Item) {\n\t\t\tfunction ConditionalAttribute ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.attributes = [];\n\t\n\t\t\t\tthis.owner = options.owner;\n\t\n\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\tractive: this.ractive,\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: this.template\n\t\t\t\t});\n\t\t\t\t// this fragment can't participate in node-y things\n\t\t\t\tthis.fragment.findNextNode = noop;\n\t\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\t\n\t\t\tConditionalAttribute.prototype = Object.create( Item && Item.prototype );\n\t\t\tConditionalAttribute.prototype.constructor = ConditionalAttribute;\n\t\n\t\t\tConditionalAttribute.prototype.bind = function bind () {\n\t\t\t\tthis.fragment.bind();\n\t\t\t};\n\t\n\t\t\tConditionalAttribute.prototype.bubble = function bubble () {\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\tthis.owner.bubble();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tConditionalAttribute.prototype.render = function render () {\n\t\t\t\tthis.node = this.owner.node;\n\t\t\t\tif ( this.node ) {\n\t\t\t\t\tthis.isSvg = this.node.namespaceURI === svg$1;\n\t\t\t\t}\n\t\n\t\t\t\tattributes = true;\n\t\t\t\tif ( !this.rendered ) this.fragment.render();\n\t\t\t\tattributes = false;\n\t\n\t\t\t\tthis.rendered = true;\n\t\t\t\tthis.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n\t\t\t\tthis.update();\n\t\t\t};\n\t\n\t\t\tConditionalAttribute.prototype.toString = function toString () {\n\t\t\t\treturn this.fragment.toString();\n\t\t\t};\n\t\n\t\t\tConditionalAttribute.prototype.unbind = function unbind () {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t};\n\t\n\t\t\tConditionalAttribute.prototype.unrender = function unrender () {\n\t\t\t\tthis.rendered = false;\n\t\t\t\tthis.fragment.unrender();\n\t\t\t};\n\t\n\t\t\tConditionalAttribute.prototype.update = function update () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar str;\n\t\t\t\tvar attrs;\n\t\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\n\t\t\t\t\tattributes = true;\n\t\t\t\t\tthis.fragment.update();\n\t\t\t\t\tattributes = false;\n\t\n\t\t\t\t\tif ( this.rendered && this.node ) {\n\t\t\t\t\t\tstr = this.fragment.toString();\n\t\t\t\t\t\tattrs = parseAttributes( str, this.isSvg );\n\t\n\t\t\t\t\t\t// any attributes that previously existed but no longer do\n\t\t\t\t\t\t// must be removed\n\t\t\t\t\t\tthis.attributes.filter( function ( a ) { return notIn( attrs, a ); } ).forEach( function ( a ) {\n\t\t\t\t\t\t\tthis$1.node.removeAttribute( a.name );\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\tattrs.forEach( function ( a ) {\n\t\t\t\t\t\t\tthis$1.node.setAttribute( a.name, a.value );\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\tthis.attributes = attrs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn ConditionalAttribute;\n\t\t}(Item));\n\t\n\t\tfunction parseAttributes ( str, isSvg ) {\n\t\t\tvar tagName = isSvg ? 'svg' : 'div';\n\t\t\treturn str\n\t\t\t\t? (div$1.innerHTML = \"<\" + tagName + \" \" + str + \"></\" + tagName + \">\") &&\n\t\t\t\t\ttoArray(div$1.childNodes[0].attributes)\n\t\t\t\t: [];\n\t\t}\n\t\n\t\tfunction notIn ( haystack, needle ) {\n\t\t\tvar i = haystack.length;\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( haystack[i].name === needle.name ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\t}\n\t\n\t\tfunction processWrapper ( wrapper, array, methodName, newIndices ) {\n\t\t\tvar __model = wrapper.__model;\n\t\n\t\t\tif ( newIndices ) {\n\t\t\t\t__model.shuffle( newIndices );\n\t\t\t} else {\n\t\t\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t\t\t// TODO use merge logic?\n\t\t\t\t//root.viewmodel.mark( keypath );\n\t\t\t}\n\t\t}\n\t\n\t\tvar mutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ];\n\t\tvar patchedArrayProto = [];\n\t\n\t\tmutatorMethods.forEach( function ( methodName ) {\n\t\t\tvar method = function () {\n\t\t\t\tvar this$1 = this;\n\t\t\t\tvar args = [], len = arguments.length;\n\t\t\t\twhile ( len-- ) args[ len ] = arguments[ len ];\n\t\n\t\t\t\tvar newIndices = getNewIndices( this.length, methodName, args );\n\t\n\t\t\t\t// lock any magic array wrappers, so that things don't get fudged\n\t\t\t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = true; } );\n\t\n\t\t\t\t// apply the underlying method\n\t\t\t\tvar result = Array.prototype[ methodName ].apply( this, arguments );\n\t\n\t\t\t\t// trigger changes\n\t\t\t\trunloop.start();\n\t\n\t\t\t\tthis._ractive.setting = true;\n\t\t\t\tvar i = this._ractive.wrappers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprocessWrapper( this$1._ractive.wrappers[i], this$1, methodName, newIndices );\n\t\t\t\t}\n\t\n\t\t\t\trunloop.end();\n\t\n\t\t\t\tthis._ractive.setting = false;\n\t\n\t\t\t\t// unlock the magic arrays... magic... bah\n\t\t\t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = false; } );\n\t\n\t\t\t\treturn result;\n\t\t\t};\n\t\n\t\t\tdefineProperty( patchedArrayProto, methodName, {\n\t\t\t\tvalue: method,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t});\n\t\n\t\tvar patchArrayMethods;\n\t\tvar unpatchArrayMethods;\n\t\n\t\t// can we use prototype chain injection?\n\t\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n\t\tif ( ({}).__proto__ ) {\n\t\t\t// yes, we can\n\t\t\tpatchArrayMethods = function ( array ) { return array.__proto__ = patchedArrayProto; };\n\t\t\tunpatchArrayMethods = function ( array ) { return array.__proto__ = Array.prototype; };\n\t\t}\n\t\n\t\telse {\n\t\t\t// no, we can't\n\t\t\tpatchArrayMethods = function ( array ) {\n\t\t\t\tvar i = mutatorMethods.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar methodName = mutatorMethods[i];\n\t\t\t\t\tdefineProperty( array, methodName, {\n\t\t\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tunpatchArrayMethods = function ( array ) {\n\t\t\t\tvar i = mutatorMethods.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tpatchArrayMethods.unpatch = unpatchArrayMethods; // TODO export separately?\n\t\tvar patch = patchArrayMethods;\n\t\n\t\tvar errorMessage$1 = 'Something went wrong in a rather interesting way';\n\t\n\t\tvar arrayAdaptor = {\n\t\t\tfilter: function ( object ) {\n\t\t\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t\t\t// or the array didn't trigger the get() itself\n\t\t\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t\t\t},\n\t\t\twrap: function ( ractive, array, keypath ) {\n\t\t\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t\t\t}\n\t\t};\n\t\n\t\tvar ArrayWrapper = function ArrayWrapper ( ractive, array ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.value = array;\n\t\t\tthis.__model = null; // filled in later\n\t\n\t\t\t// if this array hasn't already been ractified, ractify it\n\t\t\tif ( !array._ractive ) {\n\t\t\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\t\t\tdefineProperty( array, '_ractive', {\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\twrappers: [],\n\t\t\t\t\t\tinstances: [],\n\t\t\t\t\t\tsetting: false\n\t\t\t\t\t},\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\n\t\t\t\tpatch( array );\n\t\t\t}\n\t\n\t\t\t// store the ractive instance, so we can handle transitions later\n\t\t\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\t\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\t\t\tarray._ractive.instances.push( ractive );\n\t\t\t}\n\t\n\t\t\tarray._ractive.instances[ ractive._guid ] += 1;\n\t\t\tarray._ractive.wrappers.push( this );\n\t\t};\n\t\n\t\tArrayWrapper.prototype.get = function get () {\n\t\t\treturn this.value;\n\t\t};\n\t\n\t\tArrayWrapper.prototype.reset = function reset ( value ) {\n\t\t\treturn this.value === value;\n\t\t};\n\t\n\t\tArrayWrapper.prototype.teardown = function teardown () {\n\t\t\tvar array, storage, wrappers, instances, index;\n\t\n\t\t\tarray = this.value;\n\t\t\tstorage = array._ractive;\n\t\t\twrappers = storage.wrappers;\n\t\t\tinstances = storage.instances;\n\t\n\t\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t\t// and immediate setup\n\t\t\tif ( storage.setting ) {\n\t\t\t\treturn false; // so that we don't remove it from cached wrappers\n\t\t\t}\n\t\n\t\t\tindex = wrappers.indexOf( this );\n\t\t\tif ( index === -1 ) {\n\t\t\t\tthrow new Error( errorMessage$1 );\n\t\t\t}\n\t\n\t\t\twrappers.splice( index, 1 );\n\t\n\t\t\t// if nothing else depends on this array, we can revert it to its\n\t\t\t// natural state\n\t\t\tif ( !wrappers.length ) {\n\t\t\t\tdelete array._ractive;\n\t\t\t\tpatch.unpatch( this.value );\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\t// remove ractive instance if possible\n\t\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\t\tindex = instances.indexOf( this.root );\n\t\n\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\tthrow new Error( errorMessage$1 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinstances.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tvar magicAdaptor;\n\t\n\t\ttry {\n\t\t\tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\t\n\t\t\tmagicAdaptor = {\n\t\t\t\tfilter: function ( value ) {\n\t\t\t\t\treturn value && typeof value === 'object';\n\t\t\t\t},\n\t\t\t\twrap: function ( ractive, value, keypath ) {\n\t\t\t\t\treturn new MagicWrapper( ractive, value, keypath );\n\t\t\t\t}\n\t\t\t};\n\t\t} catch ( err ) {\n\t\t\tmagicAdaptor = false;\n\t\t}\n\t\n\t\tvar magicAdaptor$1 = magicAdaptor;\n\t\n\t\tfunction createOrWrapDescriptor ( originalDescriptor, ractive, keypath, wrapper ) {\n\t\t\tif ( originalDescriptor.set && originalDescriptor.set.__magic ) {\n\t\t\t\toriginalDescriptor.set.__magic.dependants.push({ ractive: ractive, keypath: keypath });\n\t\t\t\treturn originalDescriptor;\n\t\t\t}\n\t\n\t\t\tvar setting;\n\t\n\t\t\tvar dependants = [{ ractive: ractive, keypath: keypath }];\n\t\n\t\t\tvar descriptor = {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn 'value' in originalDescriptor ? originalDescriptor.value : originalDescriptor.get.call( this );\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tif ( setting ) return;\n\t\n\t\t\t\t\tif ( 'value' in originalDescriptor ) {\n\t\t\t\t\t\toriginalDescriptor.value = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toriginalDescriptor.set.call( this, value );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( wrapper.locked ) return;\n\t\t\t\t\tsetting = true;\n\t\t\t\t\tdependants.forEach( function (ref) {\n\t\t\t\t\t\tvar ractive = ref.ractive;\n\t\t\t\t\t\tvar keypath = ref.keypath;\n\t\n\t\t\t\t\t\tractive.set( keypath, value );\n\t\t\t\t\t});\n\t\t\t\t\tsetting = false;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t};\n\t\n\t\t\tdescriptor.set.__magic = { dependants: dependants, originalDescriptor: originalDescriptor };\n\t\n\t\t\treturn descriptor;\n\t\t}\n\t\n\t\tfunction revert ( descriptor, ractive, keypath ) {\n\t\t\tif ( !descriptor.set || !descriptor.set.__magic ) return true;\n\t\n\t\t\tvar dependants = descriptor.set.__magic;\n\t\t\tvar i = dependants.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar dependant = dependants[i];\n\t\t\t\tif ( dependant.ractive === ractive && dependant.keypath === keypath ) {\n\t\t\t\t\tdependants.splice( i, 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar MagicWrapper = function MagicWrapper ( ractive, value, keypath ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.ractive = ractive;\n\t\t\tthis.value = value;\n\t\t\tthis.keypath = keypath;\n\t\n\t\t\tthis.originalDescriptors = {};\n\t\n\t\t\t// wrap all properties with getters\n\t\t\tObject.keys( value ).forEach( function ( key ) {\n\t\t\t\tvar originalDescriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n\t\t\t\tthis$1.originalDescriptors[ key ] = originalDescriptor;\n\t\n\t\t\t\tvar childKeypath = keypath ? (\"\" + keypath + \".\" + (escapeKey( key ))) : escapeKey( key );\n\t\n\t\t\t\tvar descriptor = createOrWrapDescriptor( originalDescriptor, ractive, childKeypath, this$1 );\n\t\n\t\n\t\n\t\t\t\tObject.defineProperty( this$1.value, key, descriptor );\n\t\t\t});\n\t\t};\n\t\n\t\tMagicWrapper.prototype.get = function get () {\n\t\t\treturn this.value;\n\t\t};\n\t\n\t\tMagicWrapper.prototype.reset = function reset ( value ) {\n\t\t\treturn this.value === value;\n\t\t};\n\t\n\t\tMagicWrapper.prototype.set = function set ( key, value ) {\n\t\t\tthis.value[ key ] = value;\n\t\t};\n\t\n\t\tMagicWrapper.prototype.teardown = function teardown () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tObject.keys( this.value ).forEach( function ( key ) {\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n\t\t\t\tif ( !descriptor.set || !descriptor.set.__magic ) return;\n\t\n\t\t\t\trevert( descriptor );\n\t\n\t\t\t\tif ( descriptor.set.__magic.dependants.length === 1 ) {\n\t\t\t\t\tObject.defineProperty( this$1.value, key, descriptor.set.__magic.originalDescriptor );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\tvar MagicArrayWrapper = function MagicArrayWrapper ( ractive, array, keypath ) {\n\t\t\tthis.value = array;\n\t\n\t\t\tthis.magic = true;\n\t\n\t\t\tthis.magicWrapper = magicAdaptor$1.wrap( ractive, array, keypath );\n\t\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t\t\tthis.arrayWrapper.magic = this.magicWrapper;\n\t\n\t\t\t// ugh, this really is a terrible hack\n\t\t\tObject.defineProperty( this, '__model', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.arrayWrapper.__model;\n\t\t\t\t},\n\t\t\t\tset: function ( model ) {\n\t\t\t\t\tthis.arrayWrapper.__model = model;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\tMagicArrayWrapper.prototype.get = function get () {\n\t\t\treturn this.value;\n\t\t};\n\t\n\t\tMagicArrayWrapper.prototype.teardown = function teardown () {\n\t\t\tthis.arrayWrapper.teardown();\n\t\t\tthis.magicWrapper.teardown();\n\t\t};\n\t\n\t\tMagicArrayWrapper.prototype.reset = function reset ( value ) {\n\t\t\treturn this.arrayWrapper.reset( value ) && this.magicWrapper.reset( value );\n\t\t};\n\t\n\t\tvar magicArrayAdaptor = {\n\t\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\t\treturn magicAdaptor$1.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t\t},\n\t\n\t\t\twrap: function ( ractive, array, keypath ) {\n\t\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t\t}\n\t\t};\n\t\n\t\t// TODO this is probably a bit anal, maybe we should leave it out\n\t\tfunction prettify ( fnBody ) {\n\t\t\tvar lines = fnBody\n\t\t\t\t.replace( /^\\t+/gm, function ( tabs ) { return tabs.split( '\\t' ).join( '  ' ); } )\n\t\t\t\t.split( '\\n' );\n\t\n\t\t\tvar minIndent = lines.length < 2 ? 0 :\n\t\t\t\tlines.slice( 1 ).reduce( function ( prev, line ) {\n\t\t\t\t\treturn Math.min( prev, /^\\s*/.exec( line )[0].length );\n\t\t\t\t}, Infinity );\n\t\n\t\t\treturn lines.map( function ( line, i ) {\n\t\t\t\treturn '    ' + ( i ? line.substring( minIndent ) : line );\n\t\t\t}).join( '\\n' );\n\t\t}\n\t\n\t\t// Ditto. This function truncates the stack to only include app code\n\t\tfunction truncateStack ( stack ) {\n\t\t\tif ( !stack ) return '';\n\t\n\t\t\tvar lines = stack.split( '\\n' );\n\t\t\tvar name = Computation.name + '.getValue';\n\t\n\t\t\tvar truncated = [];\n\t\n\t\t\tvar len = lines.length;\n\t\t\tfor ( var i = 1; i < len; i += 1 ) {\n\t\t\t\tvar line = lines[i];\n\t\n\t\t\t\tif ( ~line.indexOf( name ) ) {\n\t\t\t\t\treturn truncated.join( '\\n' );\n\t\t\t\t} else {\n\t\t\t\t\ttruncated.push( line );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar Computation = (function (Model) {\n\t\t\tfunction Computation ( viewmodel, signature, key ) {\n\t\t\t\tModel.call( this, null, null );\n\t\n\t\t\t\tthis.root = this.parent = viewmodel;\n\t\t\t\tthis.signature = signature;\n\t\n\t\t\t\tthis.key = key; // not actually used, but helps with debugging\n\t\t\t\tthis.isExpression = key && key[0] === '@';\n\t\n\t\t\t\tthis.isReadonly = !this.signature.setter;\n\t\n\t\t\t\tthis.context = viewmodel.computationContext;\n\t\n\t\t\t\tthis.dependencies = [];\n\t\n\t\t\t\tthis.children = [];\n\t\t\t\tthis.childByKey = {};\n\t\n\t\t\t\tthis.deps = [];\n\t\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\t// TODO: is there a less hackish way to do this?\n\t\t\t\tthis.shuffle = undefined;\n\t\t\t}\n\t\n\t\t\tComputation.prototype = Object.create( Model && Model.prototype );\n\t\t\tComputation.prototype.constructor = Computation;\n\t\n\t\t\tComputation.prototype.get = function get ( shouldCapture ) {\n\t\t\t\tif ( shouldCapture ) capture( this );\n\t\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tthis.value = this.getValue();\n\t\t\t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t}\n\t\n\t\t\t\t// if capturing, this value needs to be unwrapped because it's for external use\n\t\t\t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n\t\t\t};\n\t\n\t\t\tComputation.prototype.getValue = function getValue () {\n\t\t\t\tstartCapturing();\n\t\t\t\tvar result;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tresult = this.signature.getter.call( this.context );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n\t\n\t\t\t\t\t// TODO this is all well and good in Chrome, but...\n\t\t\t\t\t// ...also, should encapsulate this stuff better, and only\n\t\t\t\t\t// show it if Ractive.DEBUG\n\t\t\t\t\tif ( hasConsole ) {\n\t\t\t\t\t\tif ( console.groupCollapsed ) console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' );\n\t\t\t\t\t\tvar functionBody = prettify( this.signature.getterString );\n\t\t\t\t\t\tvar stack = this.signature.getterUseStack ? '\\n\\n' + truncateStack( err.stack ) : '';\n\t\t\t\t\t\tconsole.error( (\"\" + (err.name) + \": \" + (err.message) + \"\\n\\n\" + functionBody + \"\" + stack) );\n\t\t\t\t\t\tif ( console.groupCollapsed ) console.groupEnd();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar dependencies = stopCapturing();\n\t\t\t\tthis.setDependencies( dependencies );\n\t\n\t\t\t\t// if not the first computation and the value is not the same,\n\t\t\t\t// register the change for change events\n\t\t\t\tif ( 'value' in this && result !== this.value ) {\n\t\t\t\t\tthis.registerChange( this.getKeypath(), result );\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\t\t};\n\t\n\t\t\tComputation.prototype.handleChange = function handleChange$1 () {\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\tthis.links.forEach( marked );\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\tthis.children.forEach( handleChange );\n\t\t\t\tthis.clearUnresolveds(); // TODO same question as on Model - necessary for primitives?\n\t\t\t};\n\t\n\t\t\tComputation.prototype.joinKey = function joinKey ( key ) {\n\t\t\t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar child = new ComputationChild( this, key );\n\t\t\t\t\tthis.children.push( child );\n\t\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.childByKey[ key ];\n\t\t\t};\n\t\n\t\t\tComputation.prototype.mark = function mark () {\n\t\t\t\tthis.handleChange();\n\t\t\t};\n\t\n\t\t\tComputation.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\t\t// computations will grab all of their deps again automagically\n\t\t\t\tif ( next !== previous ) this.handleChange();\n\t\t\t};\n\t\n\t\t\tComputation.prototype.set = function set ( value ) {\n\t\t\t\tif ( !this.signature.setter ) {\n\t\t\t\t\tthrow new Error( (\"Cannot set read-only computed value '\" + (this.key) + \"'\") );\n\t\t\t\t}\n\t\n\t\t\t\tthis.signature.setter( value );\n\t\t\t\tthis.mark();\n\t\t\t};\n\t\n\t\t\tComputation.prototype.setDependencies = function setDependencies ( dependencies ) {\n\t\t\t\t// unregister any soft dependencies we no longer have\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar i = this.dependencies.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar model = this$1.dependencies[i];\n\t\t\t\t\tif ( !~dependencies.indexOf( model ) ) model.unregister( this$1 );\n\t\t\t\t}\n\t\n\t\t\t\t// and add any new ones\n\t\t\t\ti = dependencies.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar model$1 = dependencies[i];\n\t\t\t\t\tif ( !~this$1.dependencies.indexOf( model$1 ) ) model$1.register( this$1 );\n\t\t\t\t}\n\t\n\t\t\t\tthis.dependencies = dependencies;\n\t\t\t};\n\t\n\t\t\tComputation.prototype.teardown = function teardown () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar i = this.dependencies.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( this$1.dependencies[i] ) this$1.dependencies[i].unregister( this$1 );\n\t\t\t\t}\n\t\t\t\tif ( this.root.computations[this.key] === this ) delete this.root.computations[this.key];\n\t\t\t\tModel.prototype.teardown.call(this);\n\t\t\t};\n\t\n\t\t\tComputation.prototype.unregister = function unregister ( dependent ) {\n\t\t\t\tModel.prototype.unregister.call( this, dependent );\n\t\t\t\t// tear down expressions with no deps, because they will be replaced when needed\n\t\t\t\tif ( this.isExpression && this.deps.length === 0 ) this.teardown();\n\t\t\t};\n\t\n\t\t\treturn Computation;\n\t\t}(Model));\n\t\n\t\tvar RactiveModel = (function (Model) {\n\t\t\tfunction RactiveModel ( ractive ) {\n\t\t\t\tModel.call( this, null, '' );\n\t\t\t\tthis.value = ractive;\n\t\t\t\tthis.isRoot = true;\n\t\t\t\tthis.root = this;\n\t\t\t\tthis.adaptors = [];\n\t\t\t\tthis.ractive = ractive;\n\t\t\t\tthis.changes = {};\n\t\t\t}\n\t\n\t\t\tRactiveModel.prototype = Object.create( Model && Model.prototype );\n\t\t\tRactiveModel.prototype.constructor = RactiveModel;\n\t\n\t\t\tRactiveModel.prototype.getKeypath = function getKeypath() {\n\t\t\t\treturn '@this';\n\t\t\t};\n\t\n\t\t\treturn RactiveModel;\n\t\t}(Model));\n\t\n\t\tvar hasProp$1 = Object.prototype.hasOwnProperty;\n\t\n\t\tvar RootModel = (function (Model) {\n\t\t\tfunction RootModel ( options ) {\n\t\t\t\tModel.call( this, null, null );\n\t\n\t\t\t\t// TODO deprecate this\n\t\t\t\tthis.changes = {};\n\t\n\t\t\t\tthis.isRoot = true;\n\t\t\t\tthis.root = this;\n\t\t\t\tthis.ractive = options.ractive; // TODO sever this link\n\t\n\t\t\t\tthis.value = options.data;\n\t\t\t\tthis.adaptors = options.adapt;\n\t\t\t\tthis.adapt();\n\t\n\t\t\t\tthis.computationContext = options.ractive;\n\t\t\t\tthis.computations = {};\n\t\n\t\t\t\t// TODO this is only for deprecation of using expression keypaths\n\t\t\t\tthis.expressions = {};\n\t\t\t}\n\t\n\t\t\tRootModel.prototype = Object.create( Model && Model.prototype );\n\t\t\tRootModel.prototype.constructor = RootModel;\n\t\n\t\t\tRootModel.prototype.applyChanges = function applyChanges () {\n\t\t\t\tthis._changeHash = {};\n\t\t\t\tthis.flush();\n\t\n\t\t\t\treturn this._changeHash;\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.compute = function compute ( key, signature ) {\n\t\t\t\tvar computation = new Computation( this, signature, key );\n\t\t\t\tthis.computations[ escapeKey( key ) ] = computation;\n\t\n\t\t\t\treturn computation;\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.createLink = function createLink ( keypath, target, targetPath ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar keys = splitKeypathI( keypath );\n\t\n\t\t\t\tvar model = this;\n\t\t\t\twhile ( keys.length ) {\n\t\t\t\t\tvar key = keys.shift();\n\t\t\t\t\tmodel = this$1.childByKey[ key ] || this$1.joinKey( key );\n\t\t\t\t}\n\t\n\t\t\t\treturn model.link( target, targetPath );\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.get = function get ( shouldCapture, options ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( shouldCapture ) capture( this );\n\t\n\t\t\t\tif ( !options || options.virtual !== false ) {\n\t\t\t\t\tvar result = this.getVirtual();\n\t\t\t\t\tvar keys = Object.keys( this.computations );\n\t\t\t\t\tvar i = keys.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvar computation = this$1.computations[ keys[i] ];\n\t\t\t\t\t\t// exclude template expressions\n\t\t\t\t\t\tif ( !computation.isExpression ) {\n\t\t\t\t\t\t\tresult[ keys[i] ] = computation.get();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.value;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.getKeypath = function getKeypath () {\n\t\t\t\treturn '';\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.getRactiveModel = function getRactiveModel() {\n\t\t\t\treturn this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.getValueChildren = function getValueChildren () {\n\t\t\t\tvar children = Model.prototype.getValueChildren.call( this, this.value );\n\t\n\t\t\t\tthis.children.forEach( function ( child ) {\n\t\t\t\t\tif ( child._link ) {\n\t\t\t\t\t\tvar idx = children.indexOf( child );\n\t\t\t\t\t\tif ( ~idx ) children.splice( idx, 1, child._link );\n\t\t\t\t\t\telse children.push( child._link );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tfor ( var k in this.computations ) {\n\t\t\t\t\tchildren.push( this.computations[k] );\n\t\t\t\t}\n\t\n\t\t\t\treturn children;\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.handleChange = function handleChange$1 () {\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.has = function has ( key ) {\n\t\t\t\tvar value = this.value;\n\t\t\t\tvar unescapedKey = unescapeKey( key );\n\t\n\t\t\t\tif ( hasProp$1.call( value, unescapedKey ) ) return true;\n\t\n\t\t\t\t// mappings/links and computations\n\t\t\t\tif ( key in this.computations || this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link ) return true;\n\t\t\t\t// TODO remove this after deprecation is done\n\t\t\t\tif ( key in this.expressions ) return true;\n\t\n\t\t\t\t// We climb up the constructor chain to find if one of them contains the unescapedKey\n\t\t\t\tvar constructor = value.constructor;\n\t\t\t\twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n\t\t\t\t\tif ( hasProp$1.call( constructor.prototype, unescapedKey ) ) return true;\n\t\t\t\t\tconstructor = constructor.constructor;\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.joinKey = function joinKey ( key, opts ) {\n\t\t\t\tif ( key === '@global' ) return GlobalModel$1;\n\t\t\t\tif ( key === '@this' ) return this.getRactiveModel();\n\t\n\t\t\t\tif ( this.expressions.hasOwnProperty( key ) ) {\n\t\t\t\t\twarnIfDebug( (\"Accessing expression keypaths (\" + (key.substr(1)) + \") from the instance is deprecated. You can used a getNodeInfo or event object to access keypaths with expression context.\") );\n\t\t\t\t\treturn this.expressions[ key ];\n\t\t\t\t}\n\t\n\t\t\t\treturn this.computations.hasOwnProperty( key ) ? this.computations[ key ] :\n\t\t\t\t       Model.prototype.joinKey.call( this, key, opts );\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.map = function map ( localKey, origin ) {\n\t\t\t\tvar local = this.joinKey( localKey );\n\t\t\t\tlocal.link( origin );\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.rebinding = function rebinding () {\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.set = function set ( value ) {\n\t\t\t\t// TODO wrapping root node is a baaaad idea. We should prevent this\n\t\t\t\tvar wrapper = this.wrapper;\n\t\t\t\tif ( wrapper ) {\n\t\t\t\t\tvar shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;\n\t\n\t\t\t\t\tif ( shouldTeardown ) {\n\t\t\t\t\t\twrapper.teardown();\n\t\t\t\t\t\tthis.wrapper = null;\n\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t\tthis.adapt();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t}\n\t\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\tthis.children.forEach( mark );\n\t\t\t\tthis.clearUnresolveds(); // TODO do we need to do this with primitive values? if not, what about e.g. unresolved `length` property of null -> string?\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.retrieve = function retrieve () {\n\t\t\t\treturn this.wrapper ? this.wrapper.get() : this.value;\n\t\t\t};\n\t\n\t\t\tRootModel.prototype.update = function update () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\treturn RootModel;\n\t\t}(Model));\n\t\n\t\tfunction getComputationSignature ( ractive, key, signature ) {\n\t\t\tvar getter;\n\t\t\tvar setter;\n\t\n\t\t\t// useful for debugging\n\t\t\tvar getterString;\n\t\t\tvar getterUseStack;\n\t\t\tvar setterString;\n\t\n\t\t\tif ( typeof signature === 'function' ) {\n\t\t\t\tgetter = bind( signature, ractive );\n\t\t\t\tgetterString = signature.toString();\n\t\t\t\tgetterUseStack = true;\n\t\t\t}\n\t\n\t\t\tif ( typeof signature === 'string' ) {\n\t\t\t\tgetter = createFunctionFromString( signature, ractive );\n\t\t\t\tgetterString = signature;\n\t\t\t}\n\t\n\t\t\tif ( typeof signature === 'object' ) {\n\t\t\t\tif ( typeof signature.get === 'string' ) {\n\t\t\t\t\tgetter = createFunctionFromString( signature.get, ractive );\n\t\t\t\t\tgetterString = signature.get;\n\t\t\t\t} else if ( typeof signature.get === 'function' ) {\n\t\t\t\t\tgetter = bind( signature.get, ractive );\n\t\t\t\t\tgetterString = signature.get.toString();\n\t\t\t\t\tgetterUseStack = true;\n\t\t\t\t} else {\n\t\t\t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t\t\t\t}\n\t\n\t\t\t\tif ( typeof signature.set === 'function' ) {\n\t\t\t\t\tsetter = bind( signature.set, ractive );\n\t\t\t\t\tsetterString = signature.set.toString();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tgetter: getter,\n\t\t\t\tsetter: setter,\n\t\t\t\tgetterString: getterString,\n\t\t\t\tsetterString: setterString,\n\t\t\t\tgetterUseStack: getterUseStack\n\t\t\t};\n\t\t}\n\t\n\t\tvar constructHook = new Hook( 'construct' );\n\t\n\t\tvar registryNames$1 = [\n\t\t\t'adaptors',\n\t\t\t'components',\n\t\t\t'decorators',\n\t\t\t'easing',\n\t\t\t'events',\n\t\t\t'interpolators',\n\t\t\t'partials',\n\t\t\t'transitions'\n\t\t];\n\t\n\t\tvar uid = 0;\n\t\n\t\tfunction construct ( ractive, options ) {\n\t\t\tif ( Ractive.DEBUG ) welcome();\n\t\n\t\t\tinitialiseProperties( ractive );\n\t\n\t\t\t// TODO remove this, eventually\n\t\t\tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\t\n\t\t\t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\t\t\tconstructHook.fire( ractive, options );\n\t\n\t\t\t// Add registries\n\t\t\tregistryNames$1.forEach( function ( name ) {\n\t\t\t\tractive[ name ] = extendObj( create( ractive.constructor[ name ] || null ), options[ name ] );\n\t\t\t});\n\t\n\t\t\t// Create a viewmodel\n\t\t\tvar viewmodel = new RootModel({\n\t\t\t\tadapt: getAdaptors( ractive, ractive.adapt, options ),\n\t\t\t\tdata: dataConfigurator.init( ractive.constructor, ractive, options ),\n\t\t\t\tractive: ractive\n\t\t\t});\n\t\n\t\t\tractive.viewmodel = viewmodel;\n\t\n\t\t\t// Add computed properties\n\t\t\tvar computed = extendObj( create( ractive.constructor.prototype.computed ), options.computed );\n\t\n\t\t\tfor ( var key in computed ) {\n\t\t\t\tvar signature = getComputationSignature( ractive, key, computed[ key ] );\n\t\t\t\tviewmodel.compute( key, signature );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction combine$2 ( arrays ) {\n\t\t\tvar res = [];\n\t\t\tvar args = res.concat.apply( res, arrays );\n\t\n\t\t\tvar i = args.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !~res.indexOf( args[i] ) ) {\n\t\t\t\t\tres.unshift( args[i] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn res;\n\t\t}\n\t\n\t\tfunction getAdaptors ( ractive, protoAdapt, options ) {\n\t\t\tprotoAdapt = protoAdapt.map( lookup );\n\t\t\tvar adapt = ensureArray( options.adapt ).map( lookup );\n\t\n\t\t\tvar builtins = [];\n\t\t\tvar srcs = [ protoAdapt, adapt ];\n\t\t\tif ( ractive.parent && !ractive.isolated ) {\n\t\t\t\tsrcs.push( ractive.parent.viewmodel.adaptors );\n\t\t\t}\n\t\t\tsrcs.push( builtins );\n\t\n\t\t\tvar magic = 'magic' in options ? options.magic : ractive.magic;\n\t\t\tvar modifyArrays = 'modifyArrays' in options ? options.modifyArrays : ractive.modifyArrays;\n\t\n\t\t\tif ( magic ) {\n\t\t\t\tif ( !magicSupported ) {\n\t\t\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t\t\t}\n\t\n\t\t\t\tif ( modifyArrays ) {\n\t\t\t\t\tbuiltins.push( magicArrayAdaptor );\n\t\t\t\t}\n\t\n\t\t\t\tbuiltins.push( magicAdaptor$1 );\n\t\t\t}\n\t\n\t\t\tif ( modifyArrays ) {\n\t\t\t\tbuiltins.push( arrayAdaptor );\n\t\t\t}\n\t\n\t\t\treturn combine$2( srcs );\n\t\n\t\n\t\t\tfunction lookup ( adaptor ) {\n\t\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\t\n\t\t\t\t\tif ( !adaptor ) {\n\t\t\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn adaptor;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction initialiseProperties ( ractive ) {\n\t\t\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t\t\t// existed\n\t\t\tractive._guid = 'r-' + uid++;\n\t\n\t\t\t// events\n\t\t\tractive._subs = create( null );\n\t\n\t\t\t// storage for item configuration from instantiation to reset,\n\t\t\t// like dynamic functions or original values\n\t\t\tractive._config = {};\n\t\n\t\t\t// nodes registry\n\t\t\tractive.nodes = {};\n\t\n\t\t\t// events\n\t\t\tractive.event = null;\n\t\t\tractive._eventQueue = [];\n\t\n\t\t\t// live queries\n\t\t\tractive._liveQueries = [];\n\t\t\tractive._liveComponentQueries = [];\n\t\n\t\t\t// observers\n\t\t\tractive._observers = [];\n\t\n\t\t\tif(!ractive.component){\n\t\t\t\tractive.root = ractive;\n\t\t\t\tractive.parent = ractive.container = null; // TODO container still applicable?\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction deprecateRactiveData () {\n\t\t\tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n\t\t}\n\t\n\t\tfunction getChildQueue ( queue, ractive ) {\n\t\t\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n\t\t}\n\t\n\t\tfunction fire ( hookQueue, ractive ) {\n\t\t\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\t\n\t\t\thookQueue.hook.fire( ractive );\n\t\n\t\t\t// queue is \"live\" because components can end up being\n\t\t\t// added while hooks fire on parents that modify data values.\n\t\t\twhile ( childQueue.length ) {\n\t\t\t\tfire( hookQueue, childQueue.shift() );\n\t\t\t}\n\t\n\t\t\tdelete hookQueue.queue[ ractive._guid ];\n\t\t}\n\t\n\t\tvar HookQueue = function HookQueue ( event ) {\n\t\t\tthis.hook = new Hook( event );\n\t\t\tthis.inProcess = {};\n\t\t\tthis.queue = {};\n\t\t};\n\t\n\t\tHookQueue.prototype.begin = function begin ( ractive ) {\n\t\t\tthis.inProcess[ ractive._guid ] = true;\n\t\t};\n\t\n\t\tHookQueue.prototype.end = function end ( ractive ) {\n\t\t\tvar parent = ractive.parent;\n\t\n\t\t\t// If this is *isn't* a child of a component that's in process,\n\t\t\t// it should call methods or fire at this point\n\t\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\t\tfire( this, ractive );\n\t\t\t}\n\t\t\t// elsewise, handoff to parent to fire when ready\n\t\t\telse {\n\t\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t\t}\n\t\n\t\t\tdelete this.inProcess[ ractive._guid ];\n\t\t};\n\t\n\t\tvar configHook = new Hook( 'config' );\n\t\tvar initHook = new HookQueue( 'init' );\n\t\n\t\tfunction initialise ( ractive, userOptions, options ) {\n\t\t\tObject.keys( ractive.viewmodel.computations ).forEach( function ( key ) {\n\t\t\t\tvar computation = ractive.viewmodel.computations[ key ];\n\t\n\t\t\t\tif ( ractive.viewmodel.value.hasOwnProperty( key ) ) {\n\t\t\t\t\tcomputation.set( ractive.viewmodel.value[ key ] );\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t// init config from Parent and options\n\t\t\tconfig.init( ractive.constructor, ractive, userOptions );\n\t\n\t\t\tconfigHook.fire( ractive );\n\t\t\tinitHook.begin( ractive );\n\t\n\t\t\tvar fragment;\n\t\n\t\t\t// Render virtual DOM\n\t\t\tif ( ractive.template ) {\n\t\t\t\tvar cssIds;\n\t\n\t\t\t\tif ( options.cssIds || ractive.cssId ) {\n\t\t\t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\t\n\t\t\t\t\tif ( ractive.cssId ) {\n\t\t\t\t\t\tcssIds.push( ractive.cssId );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tractive.fragment = fragment = new Fragment({\n\t\t\t\t\towner: ractive,\n\t\t\t\t\ttemplate: ractive.template,\n\t\t\t\t\tcssIds: cssIds\n\t\t\t\t}).bind( ractive.viewmodel );\n\t\t\t}\n\t\n\t\t\tinitHook.end( ractive );\n\t\n\t\t\tif ( fragment ) {\n\t\t\t\t// render automatically ( if `el` is specified )\n\t\t\t\tvar el = getElement( ractive.el );\n\t\t\t\tif ( el ) {\n\t\t\t\t\tvar promise = ractive.render( el, ractive.append );\n\t\n\t\t\t\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t\t\t\t\t\tpromise['catch']( function ( err ) {\n\t\t\t\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t\t\t\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive: ractive });\n\t\t\t\t\t\t\tlogIfDebug( err );\n\t\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar DOMEvent = function DOMEvent ( name, owner ) {\n\t\t\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\t\t\tfatal( (\"Only component proxy-events may contain \\\"*\\\" wildcards, <\" + (owner.name) + \" on-\" + name + \"=\\\"...\\\"/> is not valid\") );\n\t\t\t}\n\t\n\t\t\tthis.name = name;\n\t\t\tthis.owner = owner;\n\t\t\tthis.node = null;\n\t\t\tthis.handler = null;\n\t\t};\n\t\n\t\tDOMEvent.prototype.listen = function listen ( directive ) {\n\t\t\tvar node = this.node = this.owner.node;\n\t\t\tvar name = this.name;\n\t\n\t\t\tif ( !( (\"on\" + name) in node ) ) {\n\t\t\t\twarnOnce( missingPlugin( name, 'events' ) );\n\t\t\t\t}\n\t\n\t\t\t\tnode.addEventListener( name, this.handler = function( event ) {\n\t\t\t\tdirective.fire({\n\t\t\t\t\t\tnode: node,\n\t\t\t\t\toriginal: event\n\t\t\t\t\t});\n\t\t\t\t}, false );\n\t\t};\n\t\n\t\tDOMEvent.prototype.unlisten = function unlisten () {\n\t\t\tif ( this.handler ) this.node.removeEventListener( this.name, this.handler, false );\n\t\t};\n\t\n\t\tvar CustomEvent = function CustomEvent ( eventPlugin, owner ) {\n\t\t\tthis.eventPlugin = eventPlugin;\n\t\t\tthis.owner = owner;\n\t\t\tthis.handler = null;\n\t\t};\n\t\n\t\tCustomEvent.prototype.listen = function listen ( directive ) {\n\t\t\tvar node = this.owner.node;\n\t\n\t\t\tthis.handler = this.eventPlugin( node, function ( event ) {\n\t\t\t\tif ( event === void 0 ) event = {};\n\t\n\t\t\t\t\tevent.node = event.node || node;\n\t\t\t\tdirective.fire( event );\n\t\t\t});\n\t\t};\n\t\n\t\tCustomEvent.prototype.unlisten = function unlisten () {\n\t\t\tthis.handler.teardown();\n\t\t};\n\t\n\t\tvar RactiveEvent = function RactiveEvent ( ractive, name ) {\n\t\t\tthis.ractive = ractive;\n\t\t\tthis.name = name;\n\t\t\tthis.handler = null;\n\t\t};\n\t\n\t\tRactiveEvent.prototype.listen = function listen ( directive ) {\n\t\t\tvar ractive = this.ractive;\n\t\n\t\t\tthis.handler = ractive.on( this.name, function () {\n\t\t\t\tvar event;\n\t\n\t\t\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\t\t\tif ( arguments.length && arguments[0] && arguments[0].node ) {\n\t\t\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t\t\t\tevent.component = ractive;\n\t\t\t\t}\n\t\n\t\t\t\tvar args = Array.prototype.slice.call( arguments );\n\t\t\t\tdirective.fire( event, args );\n\t\n\t\t\t\t// cancel bubbling\n\t\t\t\treturn false;\n\t\t\t});\n\t\t};\n\t\n\t\tRactiveEvent.prototype.unlisten = function unlisten () {\n\t\t\tthis.handler.cancel();\n\t\t};\n\t\n\t\tvar specialPattern = /^(event|arguments)(\\..+)?$/;\n\t\tvar dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\t\n\t\tvar EventDirective = function EventDirective ( options ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\t\tthis.template = options.template;\n\t\t\tthis.parentFragment = options.parentFragment;\n\t\t\tthis.ractive = options.parentFragment.ractive;\n\t\n\t\t\tthis.events = [];\n\t\n\t\t\tif ( this.element.type === COMPONENT ) {\n\t\t\t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n\t\t\t\t\tthis$1.events.push( new RactiveEvent( this$1.element.instance, n ) );\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n\t\t\t\t\tvar fn = findInViewHierarchy( 'events', this$1.ractive, n );\n\t\t\t\t\t// we need to pass in \"this\" in order to get\n\t\t\t\t\t// access to node when it is created.\n\t\t\t\t\tthis$1.events.push(fn ? new CustomEvent( fn, this$1.element ) : new DOMEvent( n, this$1.element ));\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tthis.context = null;\n\t\n\t\t\t// method calls\n\t\t\tthis.resolvers = null;\n\t\t\tthis.models = null;\n\t\n\t\t\t// handler directive\n\t\t\tthis.action = null;\n\t\t\tthis.args = null;\n\t\t};\n\t\n\t\tEventDirective.prototype.bind = function bind () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.context = this.parentFragment.findContext();\n\t\n\t\t\tvar template = this.template.f;\n\t\n\t\t\tif ( template.x ) {\n\t\t\t\tthis.fn = getFunction( template.x.s, template.x.r.length );\n\t\t\t\tthis.resolvers = [];\n\t\t\t\tthis.models = template.x.r.map( function ( ref, i ) {\n\t\t\t\t\tvar specialMatch = specialPattern.exec( ref );\n\t\t\t\t\tif ( specialMatch ) {\n\t\t\t\t\t\t// on-click=\"foo(event.node)\"\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tspecial: specialMatch[1],\n\t\t\t\t\t\t\tkeys: specialMatch[2] ? splitKeypathI( specialMatch[2].substr(1) ) : []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar dollarMatch = dollarArgsPattern.exec( ref );\n\t\t\t\t\tif ( dollarMatch ) {\n\t\t\t\t\t\t// on-click=\"foo($1)\"\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tspecial: 'arguments',\n\t\t\t\t\t\t\tkeys: [ dollarMatch[1] - 1 ].concat( dollarMatch[2] ? splitKeypathI( dollarMatch[2].substr( 1 ) ) : [] )\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar resolver;\n\t\n\t\t\t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t\t\t\t\tif ( !model ) {\n\t\t\t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t\t\t\t\t\t\tthis$1.models[i] = model;\n\t\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\t\tmodel.register( this$1 );\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t\t} else model.register( this$1 );\n\t\n\t\t\t\t\treturn model;\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\t// TODO deprecate this style of directive\n\t\t\t\tthis.action = typeof template === 'string' ? // on-click='foo'\n\t\t\t\t\ttemplate :\n\t\t\t\t\ttypeof template.n === 'string' ? // on-click='{{dynamic}}'\n\t\t\t\t\t\ttemplate.n :\n\t\t\t\t\t\tnew Fragment({\n\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\ttemplate: template.n\n\t\t\t\t\t\t});\n\t\n\t\t\t\tthis.args = template.a ? // static arguments\n\t\t\t\t\t( typeof template.a === 'string' ? [ template.a ] : template.a ) :\n\t\t\t\t\ttemplate.d ? // dynamic arguments\n\t\t\t\t\t\tnew Fragment({\n\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\ttemplate: template.d\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\t[]; // no arguments\n\t\t\t}\n\t\n\t\t\tif ( this.action && typeof this.action !== 'string' ) this.action.bind();\n\t\t\tif ( this.args && template.d ) this.args.bind();\n\t\t};\n\t\n\t\tEventDirective.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.owner.bubble();\n\t\t\t}\n\t\t};\n\t\n\t\tEventDirective.prototype.destroyed = function destroyed () {\n\t\t\tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n\t\t};\n\t\n\t\tEventDirective.prototype.fire = function fire ( event, passedArgs ) {\n\t\n\t\t\t// augment event object\n\t\t\tif ( passedArgs === void 0 ) passedArgs = [];\n\t\n\t\t\t\tif ( event && !event.hasOwnProperty( '_element' ) ) {\n\t\t\t\t   addHelpers( event, this.owner );\n\t\t\t}\n\t\n\t\t\tif ( this.fn ) {\n\t\t\t\tvar values = [];\n\t\n\t\t\t\tif ( event ) passedArgs.unshift( event );\n\t\n\t\t\t\tif ( this.models ) {\n\t\t\t\t\tthis.models.forEach( function ( model ) {\n\t\t\t\t\t\tif ( !model ) return values.push( undefined );\n\t\n\t\t\t\t\t\tif ( model.special ) {\n\t\t\t\t\t\t\tvar obj = model.special === 'event' ? event : passedArgs;\n\t\t\t\t\t\t\tvar keys = model.keys.slice();\n\t\n\t\t\t\t\t\t\twhile ( keys.length ) obj = obj[ keys.shift() ];\n\t\t\t\t\t\t\treturn values.push( obj );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( model.wrapper ) {\n\t\t\t\t\t\t\treturn values.push( model.wrapperValue );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvalues.push( model.get() );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\t// make event available as `this.event`\n\t\t\t\tvar ractive = this.ractive;\n\t\t\t\tvar oldEvent = ractive.event;\n\t\n\t\t\t\tractive.event = event;\n\t\t\t\tvar result = this.fn.apply( ractive, values ).pop();\n\t\n\t\t\t\t// Auto prevent and stop if return is explicitly false\n\t\t\t\tif ( result === false ) {\n\t\t\t\t\tvar original = event ? event.original : undefined;\n\t\t\t\t\tif ( original ) {\n\t\t\t\t\t\toriginal.preventDefault && original.preventDefault();\n\t\t\t\t\t\toriginal.stopPropagation && original.stopPropagation();\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarnOnceIfDebug( (\"handler '\" + (this.template.n) + \"' returned false, but there is no event available to cancel\") );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tractive.event = oldEvent;\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\tvar action = this.action.toString();\n\t\t\t\tvar args = this.template.f.d ? this.args.getArgsList() : this.args;\n\t\n\t\t\t\tif ( passedArgs.length ) args = args.concat( passedArgs );\n\t\n\t\t\t\tif ( event ) event.name = action;\n\t\n\t\t\t\tfireEvent( this.ractive, action, {\n\t\t\t\t\tevent: event,\n\t\t\t\t\targs: args\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\n\t\tEventDirective.prototype.handleChange = function handleChange () {};\n\t\n\t\tEventDirective.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.models ) return;\n\t\t\tvar idx = this.models.indexOf( previous );\n\t\n\t\t\tif ( ~idx ) {\n\t\t\t\tthis.models.splice( idx, 1, next );\n\t\t\t\tprevious.unregister( this );\n\t\t\t\tif ( next ) next.addShuffleTask( function () { return next.register( this$1 ); } );\n\t\t\t}\n\t\t};\n\t\n\t\tEventDirective.prototype.render = function render () {\n\t\t\t// render events after everything else, so they fire after bindings\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\trunloop.scheduleTask( function () { return this$1.events.forEach( function ( e ) { return e.listen( this$1 ); }, true ); } );\n\t\t};\n\t\n\t\tEventDirective.prototype.toString = function toString() { return ''; };\n\t\n\t\tEventDirective.prototype.unbind = function unbind$1 () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar template = this.template.f;\n\t\n\t\t\tif ( template.m ) {\n\t\t\t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t\t\t\tthis.resolvers = [];\n\t\n\t\t\t\tif ( this.models ) this.models.forEach( function ( m ) {\n\t\t\t\t\tif ( m.unregister ) m.unregister( this$1 );\n\t\t\t\t});\n\t\t\t\tthis.models = null;\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\t// TODO this is brittle and non-explicit, fix it\n\t\t\t\tif ( this.action && this.action.unbind ) this.action.unbind();\n\t\t\t\tif ( this.args && this.args.unbind ) this.args.unbind();\n\t\t\t}\n\t\t};\n\t\n\t\tEventDirective.prototype.unrender = function unrender () {\n\t\t\tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n\t\t};\n\t\n\t\tEventDirective.prototype.update = function update () {\n\t\t\tif ( this.method || !this.dirty ) return; // nothing to do\n\t\n\t\t\tthis.dirty = false;\n\t\n\t\t\t// ugh legacy\n\t\t\tif ( this.action && this.action.update ) this.action.update();\n\t\t\tif ( this.args && this.args.update ) this.args.update();\n\t\t};\n\t\n\t\t// TODO it's unfortunate that this has to run every time a\n\t\t// component is rendered... is there a better way?\n\t\tfunction updateLiveQueries ( component ) {\n\t\t\t// Does this need to be added to any live queries?\n\t\t\tvar instance = component.ractive;\n\t\n\t\t\tdo {\n\t\t\t\tvar liveQueries = instance._liveComponentQueries;\n\t\n\t\t\t\tvar i = liveQueries.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar name = liveQueries[i];\n\t\t\t\t\tvar query = liveQueries[ (\"_\" + name) ];\n\t\n\t\t\t\t\tif ( query.test( component ) ) {\n\t\t\t\t\t\tquery.add( component.instance );\n\t\t\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t\t\tcomponent.liveQueries.push( query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while ( instance = instance.parent );\n\t\t}\n\t\n\t\tfunction removeFromLiveComponentQueries ( component ) {\n\t\t\tvar instance = component.ractive;\n\t\n\t\t\twhile ( instance ) {\n\t\t\t\tvar query = instance._liveComponentQueries[ (\"_\" + (component.name)) ];\n\t\t\t\tif ( query ) query.remove( component );\n\t\n\t\t\t\tinstance = instance.parent;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction makeDirty ( query ) {\n\t\t\tquery.makeDirty();\n\t\t}\n\t\n\t\tvar teardownHook = new Hook( 'teardown' );\n\t\n\t\tvar Component = (function (Item) {\n\t\t\tfunction Component ( options, ComponentConstructor ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tItem.call( this, options );\n\t\t\t\tthis.type = COMPONENT; // override ELEMENT from super\n\t\n\t\t\t\tvar instance = create( ComponentConstructor.prototype );\n\t\n\t\t\t\tthis.instance = instance;\n\t\t\t\tthis.name = options.template.e;\n\t\t\t\tthis.parentFragment = options.parentFragment;\n\t\n\t\t\t\tthis.liveQueries = [];\n\t\n\t\t\t\tif ( instance.el ) {\n\t\t\t\t\twarnIfDebug( (\"The <\" + (this.name) + \"> component has a default 'el' property; it has been disregarded\") );\n\t\t\t\t}\n\t\n\t\t\t\tvar partials = options.template.p || {};\n\t\t\t\tif ( !( 'content' in partials ) ) partials.content = options.template.f || [];\n\t\t\t\tthis._partials = partials; // TEMP\n\t\n\t\t\t\tthis.yielders = {};\n\t\n\t\t\t\t// find container\n\t\t\t\tvar fragment = options.parentFragment;\n\t\t\t\tvar container;\n\t\t\t\twhile ( fragment ) {\n\t\t\t\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\t\t\t\tcontainer = fragment.owner.container;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t}\n\t\n\t\t\t\t// add component-instance-specific properties\n\t\t\t\tinstance.parent = this.parentFragment.ractive;\n\t\t\t\tinstance.container = container || null;\n\t\t\t\tinstance.root = instance.parent.root;\n\t\t\t\tinstance.component = this;\n\t\n\t\t\t\tconstruct( this.instance, { partials: partials });\n\t\n\t\t\t\t// for hackability, this could be an open option\n\t\t\t\t// for any ractive instance, but for now, just\n\t\t\t\t// for components and just for ractive...\n\t\t\t\tinstance._inlinePartials = partials;\n\t\n\t\t\t\tthis.attributeByName = {};\n\t\n\t\t\t\tthis.attributes = [];\n\t\t\t\tvar leftovers = [];\n\t\t\t\t( this.template.m || [] ).forEach( function ( template ) {\n\t\t\t\t\tswitch ( template.t ) {\n\t\t\t\t\t\tcase ATTRIBUTE:\n\t\t\t\t\t\tcase EVENT:\n\t\t\t\t\t\tcase TRANSITION:\n\t\t\t\t\t\t\tthis$1.attributes.push( createItem({\n\t\t\t\t\t\t\t\towner: this$1,\n\t\t\t\t\t\t\t\tparentFragment: this$1.parentFragment,\n\t\t\t\t\t\t\t\ttemplate: template\n\t\t\t\t\t\t\t}) );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase BINDING_FLAG:\n\t\t\t\t\t\tcase DECORATOR:\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tleftovers.push( template );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tthis.attributes.push( new ConditionalAttribute({\n\t\t\t\t\towner: this,\n\t\t\t\t\tparentFragment: this.parentFragment,\n\t\t\t\t\ttemplate: leftovers\n\t\t\t\t}) );\n\t\n\t\t\t\tthis.eventHandlers = [];\n\t\t\t\tif ( this.template.v ) this.setupEvents();\n\t\t\t}\n\t\n\t\t\tComponent.prototype = Object.create( Item && Item.prototype );\n\t\t\tComponent.prototype.constructor = Component;\n\t\n\t\t\tComponent.prototype.bind = function bind$1$$ () {\n\t\t\t\tthis.attributes.forEach( bind$1 );\n\t\n\t\t\t\tinitialise( this.instance, {\n\t\t\t\t\tpartials: this._partials\n\t\t\t\t}, {\n\t\t\t\t\tcssIds: this.parentFragment.cssIds\n\t\t\t\t});\n\t\n\t\t\t\tthis.eventHandlers.forEach( bind$1 );\n\t\n\t\t\t\tthis.bound = true;\n\t\t\t};\n\t\n\t\t\tComponent.prototype.bubble = function bubble () {\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tComponent.prototype.checkYielders = function checkYielders () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tObject.keys( this.yielders ).forEach( function ( name ) {\n\t\t\t\t\tif ( this$1.yielders[ name ].length > 1 ) {\n\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t\tthrow new Error( (\"A component template can only have one {{yield\" + (name ? ' ' + name : '') + \"}} declaration at a time\") );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\n\t\t\tComponent.prototype.destroyed = function destroyed () {\n\t\t\t\tif ( this.instance.fragment ) this.instance.fragment.destroyed();\n\t\t\t};\n\t\n\t\t\tComponent.prototype.detach = function detach () {\n\t\t\t\treturn this.instance.fragment.detach();\n\t\t\t};\n\t\n\t\t\tComponent.prototype.find = function find ( selector ) {\n\t\t\t\treturn this.instance.fragment.find( selector );\n\t\t\t};\n\t\n\t\t\tComponent.prototype.findAll = function findAll ( selector, query ) {\n\t\t\t\tthis.instance.fragment.findAll( selector, query );\n\t\t\t};\n\t\n\t\t\tComponent.prototype.findComponent = function findComponent ( name ) {\n\t\t\t\tif ( !name || this.name === name ) return this.instance;\n\t\n\t\t\t\tif ( this.instance.fragment ) {\n\t\t\t\t\treturn this.instance.fragment.findComponent( name );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tComponent.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\t\tif ( query.test( this ) ) {\n\t\t\t\t\tquery.add( this.instance );\n\t\n\t\t\t\t\tif ( query.live ) {\n\t\t\t\t\t\tthis.liveQueries.push( query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.instance.fragment.findAllComponents( name, query );\n\t\t\t};\n\t\n\t\t\tComponent.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\t\treturn this.instance.fragment.firstNode( skipParent );\n\t\t\t};\n\t\n\t\t\tComponent.prototype.render = function render$1$$ ( target, occupants ) {\n\t\t\t\trender$1( this.instance, target, null, occupants );\n\t\n\t\t\t\tthis.checkYielders();\n\t\t\t\tthis.attributes.forEach( render );\n\t\t\t\tthis.eventHandlers.forEach( render );\n\t\t\t\tupdateLiveQueries( this );\n\t\n\t\t\t\tthis.rendered = true;\n\t\t\t};\n\t\n\t\t\tComponent.prototype.setupEvents = function setupEvents () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar handlers = this.eventHandlers;\n\t\n\t\t\t\tObject.keys( this.template.v ).forEach( function ( key ) {\n\t\t\t\t\tvar eventNames = key.split( '-' );\n\t\t\t\t\tvar template = this$1.template.v[ key ];\n\t\n\t\t\t\t\teventNames.forEach( function ( eventName ) {\n\t\t\t\t\t\tvar event = new RactiveEvent( this$1.instance, eventName );\n\t\t\t\t\t\thandlers.push( new EventDirective( this$1, event, template ) );\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\t\n\t\t\tComponent.prototype.shuffled = function shuffled () {\n\t\t\t\tthis.liveQueries.forEach( makeDirty );\n\t\t\t\tItem.prototype.shuffled.call(this);\n\t\t\t};\n\t\n\t\t\tComponent.prototype.toString = function toString () {\n\t\t\t\treturn this.instance.toHTML();\n\t\t\t};\n\t\n\t\t\tComponent.prototype.unbind = function unbind$1 () {\n\t\t\t\tthis.bound = false;\n\t\n\t\t\t\tthis.attributes.forEach( unbind );\n\t\n\t\t\t\tvar instance = this.instance;\n\t\t\t\tinstance.viewmodel.teardown();\n\t\t\t\tinstance.fragment.unbind();\n\t\t\t\tinstance._observers.forEach( cancel );\n\t\n\t\t\t\tremoveFromLiveComponentQueries( this );\n\t\n\t\t\t\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\t\t\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t\t\t\t}\n\t\n\t\t\t\tteardownHook.fire( instance );\n\t\t\t};\n\t\n\t\t\tComponent.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.rendered = false;\n\t\n\t\t\t\tthis.shouldDestroy = shouldDestroy;\n\t\t\t\tthis.instance.unrender();\n\t\t\t\tthis.attributes.forEach( unrender );\n\t\t\t\tthis.eventHandlers.forEach( unrender );\n\t\t\t\tthis.liveQueries.forEach( function ( query ) { return query.remove( this$1.instance ); } );\n\t\t\t};\n\t\n\t\t\tComponent.prototype.update = function update$1 () {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.instance.fragment.update();\n\t\t\t\tthis.checkYielders();\n\t\t\t\tthis.attributes.forEach( update );\n\t\t\t\tthis.eventHandlers.forEach( update );\n\t\t\t};\n\t\n\t\t\treturn Component;\n\t\t}(Item));\n\t\n\t\tvar missingDecorator = {\n\t\t\tupdate: noop,\n\t\t\tteardown: noop\n\t\t};\n\t\n\t\tvar Decorator = function Decorator ( options ) {\n\t\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\t\tthis.parentFragment = this.owner.parentFragment;\n\t\t\tthis.ractive = this.owner.ractive;\n\t\t\tvar template = this.template = options.template;\n\t\n\t\t\tthis.dynamicName = typeof template.f.n === 'object';\n\t\t\tthis.dynamicArgs = !!template.f.d;\n\t\n\t\t\tif ( this.dynamicName ) {\n\t\t\t\tthis.nameFragment = new Fragment({\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: template.f.n\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.name = template.f.n || template.f;\n\t\t\t}\n\t\n\t\t\tif ( this.dynamicArgs ) {\n\t\t\t\tthis.argsFragment = new Fragment({\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: template.f.d\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif ( template.f.a && template.f.a.s ) {\n\t\t\t\t\tthis.args = [];\n\t\t\t\t} else {\n\t\t\t\t\tthis.args = template.f.a || [];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.node = null;\n\t\t\tthis.intermediary = null;\n\t\n\t\t\tthis.element.decorators.push( this );\n\t\t};\n\t\n\t\tDecorator.prototype.bind = function bind () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.dynamicName ) {\n\t\t\t\tthis.nameFragment.bind();\n\t\t\t\tthis.name = this.nameFragment.toString();\n\t\t\t}\n\t\n\t\t\tif ( this.dynamicArgs ) this.argsFragment.bind();\n\t\n\t\t\t// TODO: dry this up once deprecation is done\n\t\t\tif ( this.template.f.a && this.template.f.a.s ) {\n\t\t\t\tthis.resolvers = [];\n\t\t\t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n\t\t\t\t\tvar resolver;\n\t\t\t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t\t\t\t\tif ( !model ) {\n\t\t\t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t\t\t\t\t\t\tthis$1.models[i] = model;\n\t\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\t\tmodel.register( this$1 );\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t\t} else model.register( this$1 );\n\t\n\t\t\t\t\treturn model;\n\t\t\t\t});\n\t\t\t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n\t\t\t}\n\t\t};\n\t\n\t\tDecorator.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.owner.bubble();\n\t\t\t}\n\t\t};\n\t\n\t\tDecorator.prototype.destroyed = function destroyed () {\n\t\t\tif ( this.intermediary ) this.intermediary.teardown();\n\t\t\tthis.shouldDestroy = true;\n\t\t};\n\t\n\t\tDecorator.prototype.handleChange = function handleChange () { this.bubble(); };\n\t\n\t\tDecorator.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\tvar idx = this.models.indexOf( previous );\n\t\t\tif ( !~idx ) return;\n\t\n\t\t\tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n\t\t\tif ( next === previous ) return;\n\t\n\t\t\tprevious.unregister( this );\n\t\t\tthis.models.splice( idx, 1, next );\n\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t\n\t\t\tif ( !safe ) this.bubble();\n\t\t};\n\t\n\t\tDecorator.prototype.render = function render () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\trunloop.scheduleTask( function () {\n\t\t\t\tvar fn = findInViewHierarchy( 'decorators', this$1.ractive, this$1.name );\n\t\n\t\t\t\tif ( !fn ) {\n\t\t\t\t\twarnOnce( missingPlugin( this$1.name, 'decorator' ) );\n\t\t\t\t\tthis$1.intermediary = missingDecorator;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tthis$1.node = this$1.element.node;\n\t\n\t\t\t\tvar args;\n\t\t\t\tif ( this$1.argsFn ) {\n\t\t\t\t\targs = this$1.models.map( function ( model ) {\n\t\t\t\t\t\tif ( !model ) return undefined;\n\t\n\t\t\t\t\t\treturn model.get();\n\t\t\t\t\t});\n\t\t\t\t\targs = this$1.argsFn.apply( this$1.ractive, args );\n\t\t\t\t} else {\n\t\t\t\t\targs = this$1.dynamicArgs ? this$1.argsFragment.getArgsList() : this$1.args;\n\t\t\t\t}\n\t\n\t\t\t\tthis$1.intermediary = fn.apply( this$1.ractive, [ this$1.node ].concat( args ) );\n\t\n\t\t\t\tif ( !this$1.intermediary || !this$1.intermediary.teardown ) {\n\t\t\t\t\tthrow new Error( (\"The '\" + (this$1.name) + \"' decorator must return an object with a teardown method\") );\n\t\t\t\t}\n\t\n\t\t\t\t// watch out for decorators that cause their host element to be unrendered\n\t\t\t\tif ( this$1.shouldDestroy ) this$1.destroyed();\n\t\t\t}, true );\n\t\t\tthis.rendered = true;\n\t\t};\n\t\n\t\tDecorator.prototype.toString = function toString () { return ''; };\n\t\n\t\tDecorator.prototype.unbind = function unbind$1 () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.dynamicName ) this.nameFragment.unbind();\n\t\t\tif ( this.dynamicArgs ) this.argsFragment.unbind();\n\t\t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t\t\tif ( this.models ) this.models.forEach( function ( m ) {\n\t\t\t\tif ( m ) m.unregister( this$1 );\n\t\t\t});\n\t\t};\n\t\n\t\tDecorator.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tif ( ( !shouldDestroy || this.element.rendered ) && this.intermediary ) this.intermediary.teardown();\n\t\t\tthis.rendered = false;\n\t\t};\n\t\n\t\tDecorator.prototype.update = function update () {\n\t\t\tif ( !this.dirty ) return;\n\t\n\t\t\tthis.dirty = false;\n\t\n\t\t\tvar nameChanged = false;\n\t\n\t\t\tif ( this.dynamicName && this.nameFragment.dirty ) {\n\t\t\t\tvar name = this.nameFragment.toString();\n\t\t\t\tnameChanged = name !== this.name;\n\t\t\t\tthis.name = name;\n\t\t\t}\n\t\n\t\t\tif ( this.intermediary ) {\n\t\t\t\tif ( nameChanged || !this.intermediary.update ) {\n\t\t\t\t\tthis.unrender();\n\t\t\t\t\tthis.render();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( this.dynamicArgs ) {\n\t\t\t\t\t\tif ( this.argsFragment.dirty ) {\n\t\t\t\t\t\t\tvar args = this.argsFragment.getArgsList();\n\t\t\t\t\t\t\tthis.intermediary.update.apply( this.ractive, args );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( this.argsFn ) {\n\t\t\t\t\t\tvar args$1 = this.models.map( function ( model ) {\n\t\t\t\t\t\t\tif ( !model ) return undefined;\n\t\n\t\t\t\t\t\t\treturn model.get();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis.intermediary.update.apply( this.ractive, this.argsFn.apply( this.ractive, args$1 ) );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.intermediary.update.apply( this.ractive, this.args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// need to run these for unrender/render cases\n\t\t\t// so can't just be in conditional if above\n\t\n\t\t\tif ( this.dynamicName && this.nameFragment.dirty ) {\n\t\t\t\tthis.nameFragment.update();\n\t\t\t}\n\t\n\t\t\tif ( this.dynamicArgs && this.argsFragment.dirty ) {\n\t\t\t\tthis.argsFragment.update();\n\t\t\t}\n\t\t};\n\t\n\t\tvar Doctype = (function (Item) {\n\t\t\tfunction Doctype () {\n\t\t\t\tItem.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tDoctype.prototype = Object.create( Item && Item.prototype );\n\t\t\tDoctype.prototype.constructor = Doctype;\n\t\n\t\t\tDoctype.prototype.bind = function bind () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tDoctype.prototype.render = function render () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tDoctype.prototype.teardown = function teardown () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tDoctype.prototype.toString = function toString () {\n\t\t\t\treturn '<!DOCTYPE' + this.template.a + '>';\n\t\t\t};\n\t\n\t\t\tDoctype.prototype.unbind = function unbind () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tDoctype.prototype.unrender = function unrender () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tDoctype.prototype.update = function update () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\treturn Doctype;\n\t\t}(Item));\n\t\n\t\tfunction updateLiveQueries$1 ( element ) {\n\t\t\t// Does this need to be added to any live queries?\n\t\t\tvar node = element.node;\n\t\t\tvar instance = element.ractive;\n\t\n\t\t\tdo {\n\t\t\t\tvar liveQueries = instance._liveQueries;\n\t\n\t\t\t\tvar i = liveQueries.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar selector = liveQueries[i];\n\t\t\t\t\tvar query = liveQueries[ (\"_\" + selector) ];\n\t\n\t\t\t\t\tif ( query.test( node ) ) {\n\t\t\t\t\t\tquery.add( node );\n\t\t\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t\t\telement.liveQueries.push( query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while ( instance = instance.parent );\n\t\t}\n\t\n\t\tfunction warnAboutAmbiguity ( description, ractive ) {\n\t\t\twarnOnceIfDebug( (\"The \" + description + \" being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: ractive });\n\t\t}\n\t\n\t\tvar Binding = function Binding ( element, name ) {\n\t\t\tif ( name === void 0 ) name = 'value';\n\t\n\t\t\t\tthis.element = element;\n\t\t\tthis.ractive = element.ractive;\n\t\t\tthis.attribute = element.attributeByName[ name ];\n\t\n\t\t\tvar interpolator = this.attribute.interpolator;\n\t\t\tinterpolator.twowayBinding = this;\n\t\n\t\t\tvar model = interpolator.model;\n\t\n\t\t\t// not bound?\n\t\t\tif ( !model ) {\n\t\t\t\t// try to force resolution\n\t\t\t\tinterpolator.resolver.forceResolution();\n\t\t\t\tmodel = interpolator.model;\n\t\n\t\t\t\twarnAboutAmbiguity( (\"'\" + (interpolator.template.r) + \"' reference\"), this.ractive );\n\t\t\t\t}\n\t\n\t\t\t\telse if ( model.isUnresolved ) {\n\t\t\t\t\t// reference expressions (e.g. foo[bar])\n\t\t\t\t\tmodel.forceResolution();\n\t\t\t\t\twarnAboutAmbiguity( 'expression', this.ractive );\n\t\t\t}\n\t\n\t\t\t// TODO include index/key/keypath refs as read-only\n\t\t\telse if ( model.isReadonly ) {\n\t\t\t\tvar keypath = model.getKeypath().replace( /^@/, '' );\n\t\t\t\twarnOnceIfDebug( (\"Cannot use two-way binding on <\" + (element.name) + \"> element: \" + keypath + \" is read-only. To suppress this warning use <\" + (element.name) + \" twoway='false'...>\"), { ractive: this.ractive });\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tthis.attribute.isTwoway = true;\n\t\t\tthis.model = model;\n\t\n\t\t\t// initialise value, if it's undefined\n\t\t\tvar value = model.get();\n\t\t\tthis.wasUndefined = value === undefined;\n\t\n\t\t\tif ( value === undefined && this.getInitialValue ) {\n\t\t\t\tvalue = this.getInitialValue();\n\t\t\t\tmodel.set( value );\n\t\t\t}\n\t\t\tthis.lastVal( true, value );\n\t\n\t\t\tvar parentForm = findElement( this.element, false, 'form' );\n\t\t\tif ( parentForm ) {\n\t\t\t\tthis.resetValue = value;\n\t\t\t\tparentForm.formBindings.push( this );\n\t\t\t}\n\t\t};\n\t\n\t\tBinding.prototype.bind = function bind () {\n\t\t\tthis.model.registerTwowayBinding( this );\n\t\t};\n\t\n\t\tBinding.prototype.handleChange = function handleChange () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar value = this.getValue();\n\t\t\tif ( this.lastVal() === value ) return;\n\t\n\t\t\trunloop.start( this.root );\n\t\t\tthis.attribute.locked = true;\n\t\t\tthis.model.set( value );\n\t\t\tthis.lastVal( true, value );\n\t\n\t\t\t// if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n\t\t\tif ( this.model.get() !== value ) this.attribute.locked = false;\n\t\t\telse runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t\n\t\t\trunloop.end();\n\t\t};\n\t\n\t\tBinding.prototype.lastVal = function lastVal ( setting, value ) {\n\t\t\tif ( setting ) this.lastValue = value;\n\t\t\telse return this.lastValue;\n\t\t};\n\t\n\t\tBinding.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.model && this.model === previous ) previous.unregisterTwowayBinding( this );\n\t\t\tif ( next ) {\n\t\t\t\tthis.model = next;\n\t\t\t\trunloop.scheduleTask( function () { return next.registerTwowayBinding( this$1 ); } );\n\t\t\t}\n\t\t};\n\t\n\t\tBinding.prototype.render = function render () {\n\t\t\tthis.node = this.element.node;\n\t\t\tthis.node._ractive.binding = this;\n\t\t\tthis.rendered = true; // TODO is this used anywhere?\n\t\t};\n\t\n\t\t\tBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tthis.model.set( node.value );\n\t\t};\n\t\n\t\tBinding.prototype.unbind = function unbind () {\n\t\t\tthis.model.unregisterTwowayBinding( this );\n\t\t};\n\t\n\t\tBinding.prototype.unrender = function unrender () {\n\t\t\t\t// noop?\n\t\t\t};\n\t\n\t\t// This is the handler for DOM events that would lead to a change in the model\n\t\t// (i.e. change, sometimes, input, and occasionally click and keyup)\n\t\tfunction handleDomEvent () {\n\t\t\tthis._ractive.binding.handleChange();\n\t\t}\n\t\n\t\tvar CheckboxBinding = (function (Binding) {\n\t\t\tfunction CheckboxBinding ( element ) {\n\t\t\t\tBinding.call( this, element, 'checked' );\n\t\t\t}\n\t\n\t\t\tCheckboxBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tCheckboxBinding.prototype.constructor = CheckboxBinding;\n\t\n\t\t\tCheckboxBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\n\t\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\n\t\t\t\tif ( this.node.attachEvent ) {\n\t\t\t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tCheckboxBinding.prototype.unrender = function unrender () {\n\t\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\tCheckboxBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\treturn !!this.element.getAttribute( 'checked' );\n\t\t\t};\n\t\n\t\t\tCheckboxBinding.prototype.getValue = function getValue () {\n\t\t\t\treturn this.node.checked;\n\t\t\t};\n\t\n\t\t\tCheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tthis.model.set( node.checked );\n\t\t\t};\n\t\n\t\t\treturn CheckboxBinding;\n\t\t}(Binding));\n\t\n\t\tfunction getBindingGroup ( group, model, getValue ) {\n\t\t\tvar hash = \"\" + group + \"-bindingGroup\";\n\t\t\treturn model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) );\n\t\t}\n\t\n\t\tvar BindingGroup = function BindingGroup ( hash, model, getValue ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.model = model;\n\t\t\tthis.hash = hash;\n\t\t\tthis.getValue = function () {\n\t\t\t\tthis$1.value = getValue.call(this$1);\n\t\t\t\treturn this$1.value;\n\t\t\t};\n\t\n\t\t\tthis.bindings = [];\n\t\t};\n\t\n\t\tBindingGroup.prototype.add = function add ( binding ) {\n\t\t\tthis.bindings.push( binding );\n\t\t};\n\t\n\t\tBindingGroup.prototype.bind = function bind () {\n\t\t\tthis.value = this.model.get();\n\t\t\tthis.model.registerTwowayBinding( this );\n\t\t\tthis.bound = true;\n\t\t};\n\t\n\t\tBindingGroup.prototype.remove = function remove ( binding ) {\n\t\t\tremoveFromArray( this.bindings, binding );\n\t\t\tif ( !this.bindings.length ) {\n\t\t\t\tthis.unbind();\n\t\t\t}\n\t\t};\n\t\n\t\tBindingGroup.prototype.unbind = function unbind () {\n\t\t\tthis.model.unregisterTwowayBinding( this );\n\t\t\tthis.bound = false;\n\t\t\tdelete this.model[this.hash];\n\t\t};\n\t\n\t\tvar push$2 = [].push;\n\t\n\t\tfunction getValue() {\n\t\t\tvar all = this.bindings.filter(function ( b ) { return b.node && b.node.checked; }).map(function ( b ) { return b.element.getAttribute( 'value' ); });\n\t\t\tvar res = [];\n\t\t\tall.forEach(function ( v ) { if ( !arrayContains( res, v ) ) res.push( v ); });\n\t\t\treturn res;\n\t\t}\n\t\n\t\tvar CheckboxNameBinding = (function (Binding) {\n\t\t\tfunction CheckboxNameBinding ( element ) {\n\t\t\t\tBinding.call( this, element, 'name' );\n\t\n\t\t\t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\t\n\t\t\t\t// Each input has a reference to an array containing it and its\n\t\t\t\t// group, as two-way binding depends on being able to ascertain\n\t\t\t\t// the status of all inputs within the group\n\t\t\t\tthis.group = getBindingGroup( 'checkboxes', this.model, getValue );\n\t\t\t\tthis.group.add( this );\n\t\n\t\t\t\tif ( this.noInitialValue ) {\n\t\t\t\t\tthis.group.noInitialValue = true;\n\t\t\t\t}\n\t\n\t\t\t\t// If no initial value was set, and this input is checked, we\n\t\t\t\t// update the model\n\t\t\t\tif ( this.group.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\t\t\tvar existingValue = this.model.get();\n\t\t\t\t\tvar bindingValue = this.element.getAttribute( 'value' );\n\t\n\t\t\t\t\tif ( !arrayContains( existingValue, bindingValue ) ) {\n\t\t\t\t\t\tpush$2.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tCheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tCheckboxNameBinding.prototype.constructor = CheckboxNameBinding;\n\t\n\t\t\tCheckboxNameBinding.prototype.bind = function bind () {\n\t\t\t\tif ( !this.group.bound ) {\n\t\t\t\t\tthis.group.bind();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.changed = function changed () {\n\t\t\t\tvar wasChecked = !!this.isChecked;\n\t\t\t\tthis.isChecked = this.node.checked;\n\t\t\t\treturn this.isChecked === wasChecked;\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\t// This only gets called once per group (of inputs that\n\t\t\t\t// share a name), because it only gets called if there\n\t\t\t\t// isn't an initial value. By the same token, we can make\n\t\t\t\t// a note of that fact that there was no initial value,\n\t\t\t\t// and populate it using any `checked` attributes that\n\t\t\t\t// exist (which users should avoid, but which we should\n\t\t\t\t// support anyway to avoid breaking expectations)\n\t\t\t\tthis.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n\t\t\t\treturn [];\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.getValue = function getValue$1 () {\n\t\t\t\treturn this.group.value;\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.handleChange = function handleChange () {\n\t\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\t\tthis.group.value = this.model.get();\n\t\t\t\tvar value = this.element.getAttribute( 'value' );\n\t\t\t\tif ( this.isChecked && !arrayContains( this.group.value, value ) ) {\n\t\t\t\t\tthis.group.value.push( value );\n\t\t\t\t} else if ( !this.isChecked && arrayContains( this.group.value, value ) ) {\n\t\t\t\t\tremoveFromArray( this.group.value, value );\n\t\t\t\t}\n\t\t\t\t// make sure super knows there's a change\n\t\t\t\tthis.lastValue = null;\n\t\t\t\tBinding.prototype.handleChange.call(this);\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tvar existingValue = this.model.get();\n\t\t\t\tvar bindingValue = this.element.getAttribute( 'value' );\n\t\n\t\t\t\tif ( isArray( existingValue ) ) {\n\t\t\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t\t\t} else {\n\t\t\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t\t\t}\n\t\n\t\t\t\tnode.name = '{{' + this.model.getKeypath() + '}}';\n\t\t\t\tnode.checked = this.isChecked;\n\t\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\n\t\t\t\t// in case of IE emergency, bind to click event as well\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tthis.group.bindings.forEach( function ( binding ) { return binding.wasUndefined = true; } );\n\t\n\t\t\t\tif ( node.checked ) {\n\t\t\t\t\tvar valueSoFar = this.group.getValue();\n\t\t\t\t\tvalueSoFar.push( this.element.getAttribute( 'value' ) );\n\t\n\t\t\t\t\tthis.group.model.set( valueSoFar );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.unbind = function unbind () {\n\t\t\t\tthis.group.remove( this );\n\t\t\t};\n\t\n\t\t\tCheckboxNameBinding.prototype.unrender = function unrender () {\n\t\t\t\tvar node = this.element.node;\n\t\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\treturn CheckboxNameBinding;\n\t\t}(Binding));\n\t\n\t\tvar ContentEditableBinding = (function (Binding) {\n\t\t\tfunction ContentEditableBinding () {\n\t\t\t\tBinding.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tContentEditableBinding.prototype.constructor = ContentEditableBinding;\n\t\n\t\t\tContentEditableBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t\t\t};\n\t\n\t\t\tContentEditableBinding.prototype.getValue = function getValue () {\n\t\t\t\treturn this.element.node.innerHTML;\n\t\t\t};\n\t\n\t\t\tContentEditableBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.addEventListener( 'blur', handleDomEvent, false );\n\t\n\t\t\t\tif ( !this.ractive.lazy ) {\n\t\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tthis.model.set( node.innerHTML );\n\t\t\t};\n\t\n\t\t\tContentEditableBinding.prototype.unrender = function unrender () {\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tnode.removeEventListener( 'blur', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\treturn ContentEditableBinding;\n\t\t}(Binding));\n\t\n\t\tfunction handleBlur () {\n\t\t\thandleDomEvent.call( this );\n\t\n\t\t\tvar value = this._ractive.binding.model.get();\n\t\t\tthis.value = value == undefined ? '' : value;\n\t\t}\n\t\n\t\tfunction handleDelay ( delay ) {\n\t\t\tvar timeout;\n\t\n\t\t\treturn function () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( timeout ) clearTimeout( timeout );\n\t\n\t\t\t\ttimeout = setTimeout( function () {\n\t\t\t\t\tvar binding = this$1._ractive.binding;\n\t\t\t\t\tif ( binding.rendered ) handleDomEvent.call( this$1 );\n\t\t\t\t\ttimeout = null;\n\t\t\t\t}, delay );\n\t\t\t};\n\t\t}\n\t\n\t\tvar GenericBinding = (function (Binding) {\n\t\t\tfunction GenericBinding () {\n\t\t\t\tBinding.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tGenericBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tGenericBinding.prototype.constructor = GenericBinding;\n\t\n\t\t\tGenericBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\treturn '';\n\t\t\t};\n\t\n\t\t\tGenericBinding.prototype.getValue = function getValue () {\n\t\t\t\treturn this.node.value;\n\t\t\t};\n\t\n\t\t\tGenericBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\n\t\t\t\t// any lazy setting for this element overrides the root\n\t\t\t\t// if the value is a number, it's a timeout\n\t\t\t\tvar lazy = this.ractive.lazy;\n\t\t\t\tvar timeout = false;\n\t\n\t\t\t\tif ( 'lazy' in this.element ) {\n\t\t\t\t\tlazy = this.element.lazy;\n\t\t\t\t}\n\t\n\t\t\t\tif ( isNumeric( lazy ) ) {\n\t\t\t\t\ttimeout = +lazy;\n\t\t\t\t\tlazy = false;\n\t\t\t\t}\n\t\n\t\t\t\tthis.handler = timeout ? handleDelay( timeout ) : handleDomEvent;\n\t\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\n\t\t\t\tif ( !lazy ) {\n\t\t\t\t\tnode.addEventListener( 'input', this.handler, false );\n\t\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t\t\t};\n\t\n\t\t\tGenericBinding.prototype.unrender = function unrender () {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tthis.rendered = false;\n\t\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'input', this.handler, false );\n\t\t\t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t\t\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t\t\t};\n\t\n\t\t\treturn GenericBinding;\n\t\t}(Binding));\n\t\n\t\tvar FileBinding = (function (GenericBinding) {\n\t\t\tfunction FileBinding () {\n\t\t\t\tGenericBinding.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tFileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n\t\t\tFileBinding.prototype.constructor = FileBinding;\n\t\n\t\t\tFileBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\treturn undefined;\n\t\t\t};\n\t\n\t\t\tFileBinding.prototype.getValue = function getValue () {\n\t\t\t\treturn this.node.files;\n\t\t\t};\n\t\n\t\t\tFileBinding.prototype.render = function render () {\n\t\t\t\tthis.element.lazy = false;\n\t\t\t\tGenericBinding.prototype.render.call(this);\n\t\t\t};\n\t\n\t\t\tFileBinding.prototype.setFromNode = function setFromNode( node ) {\n\t\t\t\tthis.model.set( node.files );\n\t\t\t};\n\t\n\t\t\treturn FileBinding;\n\t\t}(GenericBinding));\n\t\n\t\tfunction getSelectedOptions ( select ) {\n\t\t    return select.selectedOptions\n\t\t\t\t? toArray( select.selectedOptions )\n\t\t\t\t: select.options\n\t\t\t\t\t? toArray( select.options ).filter( function ( option ) { return option.selected; } )\n\t\t\t\t\t: [];\n\t\t}\n\t\n\t\tvar MultipleSelectBinding = (function (Binding) {\n\t\t\tfunction MultipleSelectBinding () {\n\t\t\t\tBinding.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tMultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tMultipleSelectBinding.prototype.constructor = MultipleSelectBinding;\n\t\n\t\t\tMultipleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar value = this.getValue();\n\t\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t\t\t\t\tthis.model.set( value );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\treturn this.element.options\n\t\t\t\t\t.filter( function ( option ) { return option.getAttribute( 'selected' ); } )\n\t\t\t\t\t.map( function ( option ) { return option.getAttribute( 'value' ); } );\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.getValue = function getValue () {\n\t\t\t\tvar options = this.element.node.options;\n\t\t\t\tvar len = options.length;\n\t\n\t\t\t\tvar selectedValues = [];\n\t\n\t\t\t\tfor ( var i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvar option = options[i];\n\t\n\t\t\t\t\tif ( option.selected ) {\n\t\t\t\t\t\tvar optionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t\tselectedValues.push( optionValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn selectedValues;\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.handleChange = function handleChange () {\n\t\t\t\tvar attribute = this.attribute;\n\t\t\t\tvar previousValue = attribute.getValue();\n\t\n\t\t\t\tvar value = this.getValue();\n\t\n\t\t\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\t\t\tBinding.prototype.handleChange.call(this);\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\n\t\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\n\t\t\t\tif ( this.model.get() === undefined ) {\n\t\t\t\t\t// get value from DOM, if possible\n\t\t\t\t\tthis.handleChange();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tvar selectedOptions = getSelectedOptions( node );\n\t\t\t\tvar i = selectedOptions.length;\n\t\t\t\tvar result = new Array( i );\n\t\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar option = selectedOptions[i];\n\t\t\t\t\tresult[i] = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t}\n\t\n\t\t\t\tthis.model.set( result );\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.setValue = function setValue () {\n\t\t\t\tthrow new Error( 'TODO not implemented yet' );\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.unrender = function unrender () {\n\t\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\tMultipleSelectBinding.prototype.updateModel = function updateModel () {\n\t\t\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\t\t\tthis.keypath.set( this.initialValue );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn MultipleSelectBinding;\n\t\t}(Binding));\n\t\n\t\tvar NumericBinding = (function (GenericBinding) {\n\t\t\tfunction NumericBinding () {\n\t\t\t\tGenericBinding.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tNumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n\t\t\tNumericBinding.prototype.constructor = NumericBinding;\n\t\n\t\t\tNumericBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\treturn undefined;\n\t\t\t};\n\t\n\t\t\tNumericBinding.prototype.getValue = function getValue () {\n\t\t\t\tvar value = parseFloat( this.node.value );\n\t\t\t\treturn isNaN( value ) ? undefined : value;\n\t\t\t};\n\t\n\t\t\tNumericBinding.prototype.setFromNode = function setFromNode( node ) {\n\t\t\t\tvar value = parseFloat( node.value );\n\t\t\t\tif ( !isNaN( value ) ) this.model.set( value );\n\t\t\t};\n\t\n\t\t\treturn NumericBinding;\n\t\t}(GenericBinding));\n\t\n\t\tvar siblings = {};\n\t\n\t\tfunction getSiblings ( hash ) {\n\t\t\treturn siblings[ hash ] || ( siblings[ hash ] = [] );\n\t\t}\n\t\n\t\tvar RadioBinding = (function (Binding) {\n\t\t\tfunction RadioBinding ( element ) {\n\t\t\t\tBinding.call( this, element, 'checked' );\n\t\n\t\t\t\tthis.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );\n\t\t\t\tthis.siblings.push( this );\n\t\t\t}\n\t\n\t\t\tRadioBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tRadioBinding.prototype.constructor = RadioBinding;\n\t\n\t\t\tRadioBinding.prototype.getValue = function getValue () {\n\t\t\t\treturn this.node.checked;\n\t\t\t};\n\t\n\t\t\tRadioBinding.prototype.handleChange = function handleChange () {\n\t\t\t\trunloop.start( this.root );\n\t\n\t\t\t\tthis.siblings.forEach( function ( binding ) {\n\t\t\t\t\tbinding.model.set( binding.getValue() );\n\t\t\t\t});\n\t\n\t\t\t\trunloop.end();\n\t\t\t};\n\t\n\t\t\tRadioBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\n\t\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\n\t\t\t\tif ( this.node.attachEvent ) {\n\t\t\t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tRadioBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tthis.model.set( node.checked );\n\t\t\t};\n\t\n\t\t\tRadioBinding.prototype.unbind = function unbind () {\n\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t};\n\t\n\t\t\tRadioBinding.prototype.unrender = function unrender () {\n\t\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\treturn RadioBinding;\n\t\t}(Binding));\n\t\n\t\tfunction getValue$1() {\n\t\t\tvar checked = this.bindings.filter( function ( b ) { return b.node.checked; } );\n\t\t\tif ( checked.length > 0 ) {\n\t\t\t\treturn checked[0].element.getAttribute( 'value' );\n\t\t\t}\n\t\t}\n\t\n\t\tvar RadioNameBinding = (function (Binding) {\n\t\t\tfunction RadioNameBinding ( element ) {\n\t\t\t\tBinding.call( this, element, 'name' );\n\t\n\t\t\t\tthis.group = getBindingGroup( 'radioname', this.model, getValue$1 );\n\t\t\t\tthis.group.add( this );\n\t\n\t\t\t\tif ( element.checked ) {\n\t\t\t\t\tthis.group.value = this.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tRadioNameBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tRadioNameBinding.prototype.constructor = RadioNameBinding;\n\t\n\t\t\tRadioNameBinding.prototype.bind = function bind () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.group.bound ) {\n\t\t\t\t\tthis.group.bind();\n\t\t\t\t}\n\t\n\t\t\t\t// update name keypath when necessary\n\t\t\t\tthis.nameAttributeBinding = {\n\t\t\t\t\thandleChange: function () { return this$1.node.name = \"{{\" + (this$1.model.getKeypath()) + \"}}\"; }\n\t\t\t\t};\n\t\n\t\t\t\tthis.model.getKeypathModel().register( this.nameAttributeBinding );\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\t\t\treturn this.element.getAttribute( 'value' );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.getValue = function getValue$1 () {\n\t\t\t\treturn this.element.getAttribute( 'value' );\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.handleChange = function handleChange () {\n\t\t\t\t// If this <input> is the one that's checked, then the value of its\n\t\t\t\t// `name` model gets set to its value\n\t\t\t\tif ( this.node.checked ) {\n\t\t\t\t\tthis.group.value = this.getValue();\n\t\t\t\t\tBinding.prototype.handleChange.call(this);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.lastVal = function lastVal ( setting, value ) {\n\t\t\t\tif ( !this.group ) return;\n\t\t\t\tif ( setting ) this.group.lastValue = value;\n\t\t\t\telse return this.group.lastValue;\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tnode.name = \"{{\" + (this.model.getKeypath()) + \"}}\";\n\t\t\t\tnode.checked = this.model.get() == this.element.getAttribute( 'value' );\n\t\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tif ( node.checked ) {\n\t\t\t\t\tthis.group.model.set( this.element.getAttribute( 'value' ) );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.unbind = function unbind () {\n\t\t\t\tthis.group.remove( this );\n\t\n\t\t\t\tthis.model.getKeypathModel().unregister( this.nameAttributeBinding );\n\t\t\t};\n\t\n\t\t\tRadioNameBinding.prototype.unrender = function unrender () {\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\treturn RadioNameBinding;\n\t\t}(Binding));\n\t\n\t\tvar SingleSelectBinding = (function (Binding) {\n\t\t\tfunction SingleSelectBinding () {\n\t\t\t\tBinding.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tSingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\t\tSingleSelectBinding.prototype.constructor = SingleSelectBinding;\n\t\n\t\t\tSingleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar value = this.getValue();\n\t\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t\t\t\t\tthis.model.set( value );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSingleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar options = this.element.options;\n\t\t\t\tvar len = options.length;\n\t\n\t\t\t\tif ( !len ) return;\n\t\n\t\t\t\tvar value;\n\t\t\t\tvar optionWasSelected;\n\t\t\t\tvar i = len;\n\t\n\t\t\t\t// take the final selected option...\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar option = options[i];\n\t\n\t\t\t\t\tif ( option.getAttribute( 'selected' ) ) {\n\t\t\t\t\t\tif ( !option.getAttribute( 'disabled' ) ) {\n\t\t\t\t\t\t\tvalue = option.getAttribute( 'value' );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// or the first non-disabled option, if none are selected\n\t\t\t\tif ( !optionWasSelected ) {\n\t\t\t\t\twhile ( ++i < len ) {\n\t\t\t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t\t\t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t\t\t// other more expensive work\n\t\t\t\t// TODO does it still work? seems at odds with new architecture\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.element.attributeByName.value.value = value;\n\t\t\t\t}\n\t\n\t\t\t\treturn value;\n\t\t\t};\n\t\n\t\t\tSingleSelectBinding.prototype.getValue = function getValue () {\n\t\t\t\tvar options = this.node.options;\n\t\t\t\tvar len = options.length;\n\t\n\t\t\t\tvar i;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvar option = options[i];\n\t\n\t\t\t\t\tif ( options[i].selected && !options[i].disabled ) {\n\t\t\t\t\t\treturn option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSingleSelectBinding.prototype.render = function render () {\n\t\t\t\tBinding.prototype.render.call(this);\n\t\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\tSingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\t\tvar option = getSelectedOptions( node )[0];\n\t\t\t\tthis.model.set( option._ractive ? option._ractive.value : option.value );\n\t\t\t};\n\t\n\t\t\t// TODO this method is an anomaly... is it necessary?\n\t\t\tSingleSelectBinding.prototype.setValue = function setValue ( value ) {\n\t\t\t\tthis.model.set( value );\n\t\t\t};\n\t\n\t\t\tSingleSelectBinding.prototype.unrender = function unrender () {\n\t\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t};\n\t\n\t\t\treturn SingleSelectBinding;\n\t\t}(Binding));\n\t\n\t\tfunction isBindable ( attribute ) {\n\t\t\treturn attribute &&\n\t\t\t\t   attribute.template.f &&\n\t\t\t       attribute.template.f.length === 1 &&\n\t\t\t       attribute.template.f[0].t === INTERPOLATOR &&\n\t\t\t       !attribute.template.f[0].s;\n\t\t}\n\t\n\t\tfunction selectBinding ( element ) {\n\t\t\tvar attributes = element.attributeByName;\n\t\n\t\t\t// contenteditable - bind if the contenteditable attribute is true\n\t\t\t// or is bindable and may thus become true...\n\t\t\tif ( element.getAttribute( 'contenteditable' ) || isBindable( attributes.contenteditable ) ) {\n\t\t\t\t// ...and this element also has a value attribute to bind\n\t\t\t\treturn isBindable( attributes.value ) ? ContentEditableBinding : null;\n\t\t\t}\n\t\n\t\t\t// <input>\n\t\t\tif ( element.name === 'input' ) {\n\t\t\t\tvar type = element.getAttribute( 'type' );\n\t\n\t\t\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\t\t\tvar bindName = isBindable( attributes.name );\n\t\t\t\t\tvar bindChecked = isBindable( attributes.checked );\n\t\n\t\t\t\t\t// for radios we can either bind the name attribute, or the checked attribute - not both\n\t\t\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\t\t\tif ( type === 'radio' ) {\n\t\t\t\t\t\t\twarnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// A checkbox with bindings for both name and checked - see https://github.com/ractivejs/ractive/issues/1749\n\t\t\t\t\t\t\treturn CheckboxBinding;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( bindName ) {\n\t\t\t\t\t\treturn type === 'radio' ? RadioNameBinding : CheckboxNameBinding;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( bindChecked ) {\n\t\t\t\t\t\treturn type === 'radio' ? RadioBinding : CheckboxBinding;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\t\t\treturn FileBinding;\n\t\t\t\t}\n\t\n\t\t\t\tif ( isBindable( attributes.value ) ) {\n\t\t\t\t\treturn ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// <select>\n\t\t\tif ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\t\t\treturn element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;\n\t\t\t}\n\t\n\t\t\t// <textarea>\n\t\t\tif ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\t\t\treturn GenericBinding;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction makeDirty$1 ( query ) {\n\t\t\tquery.makeDirty();\n\t\t}\n\t\n\t\tvar endsWithSemi = /;\\s*$/;\n\t\n\t\tvar Element = (function (Item) {\n\t\t\tfunction Element ( options ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.liveQueries = []; // TODO rare case. can we handle differently?\n\t\n\t\t\t\tthis.name = options.template.e.toLowerCase();\n\t\t\t\tthis.isVoid = voidElementNames.test( this.name );\n\t\n\t\t\t\t// find parent element\n\t\t\t\tthis.parent = findElement( this.parentFragment, false );\n\t\n\t\t\t\tif ( this.parent && this.parent.name === 'option' ) {\n\t\t\t\t\tthrow new Error( (\"An <option> element cannot contain other elements (encountered <\" + (this.name) + \">)\") );\n\t\t\t\t}\n\t\n\t\t\t\tthis.decorators = [];\n\t\n\t\t\t\t// create attributes\n\t\t\t\tthis.attributeByName = {};\n\t\n\t\t\t\tthis.attributes = [];\n\t\t\t\tvar leftovers = [];\n\t\t\t\t( this.template.m || [] ).forEach( function ( template ) {\n\t\t\t\t\tswitch ( template.t ) {\n\t\t\t\t\t\tcase ATTRIBUTE:\n\t\t\t\t\t\tcase BINDING_FLAG:\n\t\t\t\t\t\tcase DECORATOR:\n\t\t\t\t\t\tcase EVENT:\n\t\t\t\t\t\tcase TRANSITION:\n\t\t\t\t\t\t\tthis$1.attributes.push( createItem({\n\t\t\t\t\t\t\t\towner: this$1,\n\t\t\t\t\t\t\t\tparentFragment: this$1.parentFragment,\n\t\t\t\t\t\t\t\ttemplate: template\n\t\t\t\t\t\t\t}) );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tleftovers.push( template );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tif ( leftovers.length ) {\n\t\t\t\t\tthis.attributes.push( new ConditionalAttribute({\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\tparentFragment: this.parentFragment,\n\t\t\t\t\t\ttemplate: leftovers\n\t\t\t\t\t}) );\n\t\t\t\t}\n\t\n\t\t\t\tvar i = this.attributes.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar attr = this$1.attributes[ i ];\n\t\t\t\t\tif ( attr.name === 'type' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\t\telse if ( attr.name === 'max' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\t\telse if ( attr.name === 'min' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\t\telse if ( attr.name === 'class' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\t\telse if ( attr.name === 'value' ) {\n\t\t\t\t\t\tthis$1.attributes.push( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// create children\n\t\t\t\tif ( options.template.f && !options.deferContent ) {\n\t\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\t\ttemplate: options.template.f,\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\tcssIds: null\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tthis.binding = null; // filled in later\n\t\t\t}\n\t\n\t\t\tElement.prototype = Object.create( Item && Item.prototype );\n\t\t\tElement.prototype.constructor = Element;\n\t\n\t\t\tElement.prototype.bind = function bind$1$$ () {\n\t\t\t\tthis.attributes.binding = true;\n\t\t\t\tthis.attributes.forEach( bind$1 );\n\t\t\t\tthis.attributes.binding = false;\n\t\n\t\t\t\tif ( this.fragment ) this.fragment.bind();\n\t\n\t\t\t\t// create two-way binding if necessary\n\t\t\t\tif ( !this.binding ) this.recreateTwowayBinding();\n\t\t\t};\n\t\n\t\t\tElement.prototype.createTwowayBinding = function createTwowayBinding () {\n\t\t\t\tvar shouldBind = 'twoway' in this ? this.twoway : this.ractive.twoway;\n\t\n\t\t\t\tif ( !shouldBind ) return null;\n\t\n\t\t\t\tvar Binding = selectBinding( this );\n\t\n\t\t\t\tif ( !Binding ) return null;\n\t\n\t\t\t\tvar binding = new Binding( this );\n\t\n\t\t\t\treturn binding && binding.model ?\n\t\t\t\t\tbinding :\n\t\t\t\t\tnull;\n\t\t\t};\n\t\n\t\t\tElement.prototype.destroyed = function destroyed () {\n\t\t\t\tthis.attributes.forEach( function ( a ) { return a.destroyed(); } );\n\t\t\t\tif ( this.fragment ) this.fragment.destroyed();\n\t\t\t};\n\t\n\t\t\tElement.prototype.detach = function detach () {\n\t\t\t\t// if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n\t\t\t\tif ( !this.rendered ) this.destroyed();\n\t\n\t\t\t\treturn detachNode( this.node );\n\t\t\t};\n\t\n\t\t\tElement.prototype.find = function find ( selector ) {\n\t\t\t\tif ( this.node && matches( this.node, selector ) ) return this.node;\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\treturn this.fragment.find( selector );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tElement.prototype.findAll = function findAll ( selector, query ) {\n\t\t\t\t// Add this node to the query, if applicable, and register the\n\t\t\t\t// query on this element\n\t\t\t\tvar matches = query.test( this.node );\n\t\t\t\tif ( matches ) {\n\t\t\t\t\tquery.add( this.node );\n\t\t\t\t\tif ( query.live ) this.liveQueries.push( query );\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tElement.prototype.findComponent = function findComponent ( name ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tElement.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tElement.prototype.findNextNode = function findNextNode () {\n\t\t\t\treturn null;\n\t\t\t};\n\t\n\t\t\tElement.prototype.firstNode = function firstNode () {\n\t\t\t\treturn this.node;\n\t\t\t};\n\t\n\t\t\tElement.prototype.getAttribute = function getAttribute ( name ) {\n\t\t\t\tvar attribute = this.attributeByName[ name ];\n\t\t\t\treturn attribute ? attribute.getValue() : undefined;\n\t\t\t};\n\t\n\t\t\tElement.prototype.recreateTwowayBinding = function recreateTwowayBinding () {\n\t\t\t\tif ( this.binding ) {\n\t\t\t\t\tthis.binding.unbind();\n\t\t\t\t\tthis.binding.unrender();\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.binding = this.createTwowayBinding() ) {\n\t\t\t\t\tthis.binding.bind();\n\t\t\t\t\tif ( this.rendered ) this.binding.render();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tElement.prototype.render = function render$1 ( target, occupants ) {\n\t\t\t\t// TODO determine correct namespace\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.namespace = getNamespace( this );\n\t\n\t\t\t\tvar node;\n\t\t\t\tvar existing = false;\n\t\n\t\t\t\tif ( occupants ) {\n\t\t\t\t\tvar n;\n\t\t\t\t\twhile ( ( n = occupants.shift() ) ) {\n\t\t\t\t\t\tif ( n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() && n.namespaceURI === this$1.namespace ) {\n\t\t\t\t\t\t\tthis$1.node = node = n;\n\t\t\t\t\t\t\texisting = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdetachNode( n );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( !node ) {\n\t\t\t\t\tnode = createElement( this.template.e, this.namespace, this.getAttribute( 'is' ) );\n\t\t\t\t\tthis.node = node;\n\t\t\t\t}\n\t\n\t\t\t\tdefineProperty( node, '_ractive', {\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tproxy: this\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// Is this a top-level node of a component? If so, we may need to add\n\t\t\t\t// a data-ractive-css attribute, for CSS encapsulation\n\t\t\t\tif ( this.parentFragment.cssIds ) {\n\t\t\t\t\tnode.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function ( x ) { return (\"{\" + x + \"}\"); } ).join( ' ' ) );\n\t\t\t\t}\n\t\n\t\t\t\tif ( existing && this.foundNode ) this.foundNode( node );\n\t\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tvar children = existing ? toArray( node.childNodes ) : undefined;\n\t\n\t\t\t\t\tthis.fragment.render( node, children );\n\t\n\t\t\t\t\t// clean up leftover children\n\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\tchildren.forEach( detachNode );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( existing ) {\n\t\t\t\t\t// store initial values for two-way binding\n\t\t\t\t\tif ( this.binding && this.binding.wasUndefined ) this.binding.setFromNode( node );\n\t\t\t\t\t// remove unused attributes\n\t\t\t\t\tvar i = node.attributes.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvar name = node.attributes[i].name;\n\t\t\t\t\t\tif ( !( name in this$1.attributeByName ) ) node.removeAttribute( name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.attributes.forEach( render );\n\t\n\t\t\t\tif ( this.binding ) this.binding.render();\n\t\n\t\t\t\tupdateLiveQueries$1( this );\n\t\n\t\t\t\tif ( this._introTransition && this.ractive.transitionsEnabled ) {\n\t\t\t\t\tthis._introTransition.isIntro = true;\n\t\t\t\t\trunloop.registerTransition( this._introTransition );\n\t\t\t\t}\n\t\n\t\t\t\tif ( !existing ) {\n\t\t\t\t\ttarget.appendChild( node );\n\t\t\t\t}\n\t\n\t\t\t\tthis.rendered = true;\n\t\t\t};\n\t\n\t\t\tElement.prototype.shuffled = function shuffled () {\n\t\t\t\tthis.liveQueries.forEach( makeDirty$1 );\n\t\t\t\tItem.prototype.shuffled.call(this);\n\t\t\t};\n\t\n\t\t\tElement.prototype.toString = function toString () {\n\t\t\t\tvar tagName = this.template.e;\n\t\n\t\t\t\tvar attrs = this.attributes.map( stringifyAttribute ).join( '' );\n\t\n\t\t\t\t// Special case - selected options\n\t\t\t\tif ( this.name === 'option' && this.isSelected() ) {\n\t\t\t\t\tattrs += ' selected';\n\t\t\t\t}\n\t\n\t\t\t\t// Special case - two-way radio name bindings\n\t\t\t\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\t\t\t\tattrs += ' checked';\n\t\t\t\t}\n\t\n\t\t\t\t// Special case style and class attributes and directives\n\t\t\t\tvar style, cls;\n\t\t\t\tthis.attributes.forEach( function ( attr ) {\n\t\t\t\t\tif ( attr.name === 'class' ) {\n\t\t\t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + safeAttributeString( attr.getString() );\n\t\t\t\t\t} else if ( attr.name === 'style' ) {\n\t\t\t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) + safeAttributeString( attr.getString() );\n\t\t\t\t\t\tif ( style && !endsWithSemi.test( style ) ) style += ';';\n\t\t\t\t\t} else if ( attr.style ) {\n\t\t\t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) +  \"\" + (attr.style) + \": \" + (safeAttributeString( attr.getString() )) + \";\";\n\t\t\t\t\t} else if ( attr.inlineClass && attr.getValue() ) {\n\t\t\t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + attr.inlineClass;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// put classes first, then inline style\n\t\t\t\tif ( style !== undefined ) attrs = ' style' + ( style ? (\"=\\\"\" + style + \"\\\"\") : '' ) + attrs;\n\t\t\t\tif ( cls !== undefined ) attrs = ' class' + (cls ? (\"=\\\"\" + cls + \"\\\"\") : '') + attrs;\n\t\n\t\t\t\tvar str = \"<\" + tagName + \"\" + attrs + \">\";\n\t\n\t\t\t\tif ( this.isVoid ) return str;\n\t\n\t\t\t\t// Special case - textarea\n\t\t\t\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t\t\t\t}\n\t\n\t\t\t\t// Special case - contenteditable\n\t\t\t\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tstr += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style\n\t\t\t\t}\n\t\n\t\t\t\tstr += \"</\" + tagName + \">\";\n\t\t\t\treturn str;\n\t\t\t};\n\t\n\t\t\tElement.prototype.unbind = function unbind$1 () {\n\t\t\t\tthis.attributes.unbinding = true;\n\t\t\t\tthis.attributes.forEach( unbind );\n\t\t\t\tthis.attributes.unbinding = false;\n\t\n\t\t\t\tif ( this.binding ) this.binding.unbind();\n\t\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t\t};\n\t\n\t\t\tElement.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tif ( !this.rendered ) return;\n\t\t\t\tthis.rendered = false;\n\t\n\t\t\t\t// unrendering before intro completed? complete it now\n\t\t\t\t// TODO should be an API for aborting transitions\n\t\t\t\tvar transition = this._introTransition;\n\t\t\t\tif ( transition && transition.complete ) transition.complete();\n\t\n\t\t\t\t// Detach as soon as we can\n\t\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t\t// <option> elements detach immediately, so that\n\t\t\t\t\t// their parent <select> element syncs correctly, and\n\t\t\t\t\t// since option elements can't have transitions anyway\n\t\t\t\t\tthis.detach();\n\t\t\t\t} else if ( shouldDestroy ) {\n\t\t\t\t\trunloop.detachWhenReady( this );\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.fragment ) this.fragment.unrender();\n\t\n\t\t\t\tif ( this.binding ) this.binding.unrender();\n\t\n\t\t\t\t// outro transition\n\t\t\t\tif ( this._outroTransition && this.ractive.transitionsEnabled ) {\n\t\t\t\t\tthis._outroTransition.isIntro = false;\n\t\t\t\t\trunloop.registerTransition( this._outroTransition );\n\t\t\t\t}\n\t\n\t\t\t\tremoveFromLiveQueries( this );\n\t\t\t\t// TODO forms are a special case\n\t\t\t};\n\t\n\t\t\tElement.prototype.update = function update$1 () {\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\n\t\t\t\t\tthis.attributes.forEach( update );\n\t\n\t\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Element;\n\t\t}(Item));\n\t\n\t\tfunction inputIsCheckedRadio ( element ) {\n\t\t\tvar attributes = element.attributeByName;\n\t\n\t\t\tvar typeAttribute  = attributes.type;\n\t\t\tvar valueAttribute = attributes.value;\n\t\t\tvar nameAttribute  = attributes.name;\n\t\n\t\t\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( valueAttribute.getValue() === nameAttribute.interpolator.model.get() ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction stringifyAttribute ( attribute ) {\n\t\t\tvar str = attribute.toString();\n\t\t\treturn str ? ' ' + str : '';\n\t\t}\n\t\n\t\tfunction removeFromLiveQueries ( element ) {\n\t\t\tvar i = element.liveQueries.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar query = element.liveQueries[i];\n\t\t\t\tquery.remove( element.node );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getNamespace ( element ) {\n\t\t\t// Use specified namespace...\n\t\t\tvar xmlns = element.getAttribute( 'xmlns' );\n\t\t\tif ( xmlns ) return xmlns;\n\t\n\t\t\t// ...or SVG namespace, if this is an <svg> element\n\t\t\tif ( element.name === 'svg' ) return svg$1;\n\t\n\t\t\tvar parent = element.parent;\n\t\n\t\t\tif ( parent ) {\n\t\t\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\t\t\tif ( parent.name === 'foreignobject' ) return html;\n\t\n\t\t\t\t// ...or inherit from the parent node\n\t\t\t\treturn parent.node.namespaceURI;\n\t\t\t}\n\t\n\t\t\treturn element.ractive.el.namespaceURI;\n\t\t}\n\t\n\t\tvar Form = (function (Element) {\n\t\t\tfunction Form ( options ) {\n\t\t\t\tElement.call( this, options );\n\t\t\t\tthis.formBindings = [];\n\t\t\t}\n\t\n\t\t\tForm.prototype = Object.create( Element && Element.prototype );\n\t\t\tForm.prototype.constructor = Form;\n\t\n\t\t\tForm.prototype.render = function render ( target, occupants ) {\n\t\t\t\tElement.prototype.render.call( this, target, occupants );\n\t\t\t\tthis.node.addEventListener( 'reset', handleReset, false );\n\t\t\t};\n\t\n\t\t\tForm.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tthis.node.removeEventListener( 'reset', handleReset, false );\n\t\t\t\tElement.prototype.unrender.call( this, shouldDestroy );\n\t\t\t};\n\t\n\t\t\treturn Form;\n\t\t}(Element));\n\t\n\t\tfunction handleReset () {\n\t\t\tvar element = this._ractive.proxy;\n\t\n\t\t\trunloop.start();\n\t\t\telement.formBindings.forEach( updateModel$1 );\n\t\t\trunloop.end();\n\t\t}\n\t\n\t\tfunction updateModel$1 ( binding ) {\n\t\t\tbinding.model.set( binding.resetValue );\n\t\t}\n\t\n\t\tvar Mustache = (function (Item) {\n\t\t\tfunction Mustache ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.parentFragment = options.parentFragment;\n\t\t\t\tthis.template = options.template;\n\t\t\t\tthis.index = options.index;\n\t\t\t\tif ( options.owner ) this.parent = options.owner;\n\t\n\t\t\t\tthis.isStatic = !!options.template.s;\n\t\n\t\t\t\tthis.model = null;\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\t\n\t\t\tMustache.prototype = Object.create( Item && Item.prototype );\n\t\t\tMustache.prototype.constructor = Mustache;\n\t\n\t\t\tMustache.prototype.bind = function bind () {\n\t\t\t\t// try to find a model for this view\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar model = resolve$2( this.parentFragment, this.template );\n\t\t\t\tvar value = model ? model.get() : undefined;\n\t\n\t\t\t\tif ( this.isStatic ) {\n\t\t\t\t\tthis.model = { get: function () { return value; } };\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( model ) {\n\t\t\t\t\tmodel.register( this );\n\t\t\t\t\tthis.model = model;\n\t\t\t\t} else {\n\t\t\t\t\tthis.resolver = this.parentFragment.resolve( this.template.r, function ( model ) {\n\t\t\t\t\t\tthis$1.model = model;\n\t\t\t\t\t\tmodel.register( this$1 );\n\t\n\t\t\t\t\t\tthis$1.handleChange();\n\t\t\t\t\t\tthis$1.resolver = null;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tMustache.prototype.handleChange = function handleChange () {\n\t\t\t\tthis.bubble();\n\t\t\t};\n\t\n\t\t\tMustache.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\t\tnext = rebindMatch( this.template, next, previous );\n\t\t\t\tif ( this['static'] ) return false;\n\t\t\t\tif ( next === this.model ) return false;\n\t\n\t\t\t\tif ( this.model ) {\n\t\t\t\t\tthis.model.unregister( this );\n\t\t\t\t}\n\t\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t\t\t\tthis.model = next;\n\t\t\t\tif ( !safe ) this.handleChange();\n\t\t\t\treturn true;\n\t\t\t};\n\t\n\t\t\tMustache.prototype.unbind = function unbind () {\n\t\t\t\tif ( !this.isStatic ) {\n\t\t\t\t\tthis.model && this.model.unregister( this );\n\t\t\t\t\tthis.model = undefined;\n\t\t\t\t\tthis.resolver && this.resolver.unbind();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Mustache;\n\t\t}(Item));\n\t\n\t\tvar Interpolator = (function (Mustache) {\n\t\t\tfunction Interpolator () {\n\t\t\t\tMustache.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tInterpolator.prototype = Object.create( Mustache && Mustache.prototype );\n\t\t\tInterpolator.prototype.constructor = Interpolator;\n\t\n\t\t\tInterpolator.prototype.bubble = function bubble () {\n\t\t\t\tif ( this.owner ) this.owner.bubble();\n\t\t\t\tMustache.prototype.bubble.call(this);\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.detach = function detach () {\n\t\t\t\treturn detachNode( this.node );\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.firstNode = function firstNode () {\n\t\t\t\treturn this.node;\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.getString = function getString () {\n\t\t\t\treturn this.model ? safeToStringValue( this.model.get() ) : '';\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.render = function render ( target, occupants ) {\n\t\t\t\tif ( inAttributes() ) return;\n\t\t\t\tvar value = this.getString();\n\t\n\t\t\t\tthis.rendered = true;\n\t\n\t\t\t\tif ( occupants ) {\n\t\t\t\t\tvar n = occupants[0];\n\t\t\t\t\tif ( n && n.nodeType === 3 ) {\n\t\t\t\t\t\toccupants.shift();\n\t\t\t\t\t\tif ( n.nodeValue !== value ) {\n\t\t\t\t\t\t\tn.nodeValue = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tn = this.node = doc.createTextNode( value );\n\t\t\t\t\t\tif ( occupants[0] ) {\n\t\t\t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.appendChild( n );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.node = n;\n\t\t\t\t} else {\n\t\t\t\t\tthis.node = doc.createTextNode( value );\n\t\t\t\t\ttarget.appendChild( this.node );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.toString = function toString ( escape ) {\n\t\t\t\tvar string = this.getString();\n\t\t\t\treturn escape ? escapeHtml( string ) : string;\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tif ( shouldDestroy ) this.detach();\n\t\t\t\tthis.rendered = false;\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.update = function update () {\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\tthis.node.data = this.getString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tInterpolator.prototype.valueOf = function valueOf () {\n\t\t\t\treturn this.model ? this.model.get() : undefined;\n\t\t\t};\n\t\n\t\t\treturn Interpolator;\n\t\t}(Mustache));\n\t\n\t\tvar Input = (function (Element) {\n\t\t\tfunction Input () {\n\t\t\t\tElement.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tInput.prototype = Object.create( Element && Element.prototype );\n\t\t\tInput.prototype.constructor = Input;\n\t\n\t\t\tInput.prototype.render = function render ( target, occupants ) {\n\t\t\t\tElement.prototype.render.call( this, target, occupants );\n\t\t\t\tthis.node.defaultValue = this.node.value;\n\t\t\t};\n\t\n\t\t\treturn Input;\n\t\t}(Element));\n\t\n\t\tvar Mapping = (function (Item) {\n\t\t\tfunction Mapping ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.name = options.template.n;\n\t\n\t\t\t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n\t\t\t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n\t\t\t\tthis.parentFragment = this.element.parentFragment; // shared\n\t\t\t\tthis.ractive = this.parentFragment.ractive;\n\t\n\t\t\t\tthis.fragment = null;\n\t\n\t\t\t\tthis.element.attributeByName[ this.name ] = this;\n\t\n\t\t\t\tthis.value = options.template.f;\n\t\t\t}\n\t\n\t\t\tMapping.prototype = Object.create( Item && Item.prototype );\n\t\t\tMapping.prototype.constructor = Mapping;\n\t\n\t\t\tMapping.prototype.bind = function bind () {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.bind();\n\t\t\t\t}\n\t\n\t\t\t\tvar template = this.template.f;\n\t\t\t\tvar viewmodel = this.element.instance.viewmodel;\n\t\n\t\t\t\tif ( template === 0 ) {\n\t\t\t\t\t// empty attributes are `true`\n\t\t\t\t\tviewmodel.joinKey( this.name ).set( true );\n\t\t\t\t}\n\t\n\t\t\t\telse if ( typeof template === 'string' ) {\n\t\t\t\t\tvar parsed = parseJSON( template );\n\t\t\t\t\tviewmodel.joinKey( this.name ).set( parsed ? parsed.value : template );\n\t\t\t\t}\n\t\n\t\t\t\telse if ( isArray( template ) ) {\n\t\t\t\t\tcreateMapping( this, true );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tMapping.prototype.render = function render () {};\n\t\n\t\t\tMapping.prototype.unbind = function unbind () {\n\t\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t\t\tif ( this.boundFragment ) this.boundFragment.unbind();\n\t\n\t\t\t\tif ( this.element.bound ) {\n\t\t\t\t\tif ( this.link.target === this.model ) this.link.owner.unlink();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tMapping.prototype.unrender = function unrender () {};\n\t\n\t\t\tMapping.prototype.update = function update () {\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t\t\tif ( this.boundFragment ) this.boundFragment.update();\n\t\t\t\t\tif ( this.rendered ) this.updateDelegate();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Mapping;\n\t\t}(Item));\n\t\n\t\tfunction createMapping ( item ) {\n\t\t\tvar template = item.template.f;\n\t\t\tvar viewmodel = item.element.instance.viewmodel;\n\t\t\tvar childData = viewmodel.value;\n\t\n\t\t\tif ( template.length === 1 && template[0].t === INTERPOLATOR ) {\n\t\t\t\titem.model = resolve$2( item.parentFragment, template[0] );\n\t\n\t\t\t\tif ( !item.model ) {\n\t\t\t\t\twarnOnceIfDebug( (\"The \" + (item.name) + \"='{{\" + (template[0].r) + \"}}' mapping is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: item.element.instance }); // TODO add docs page explaining item\n\t\t\t\t\titem.parentFragment.ractive.get( item.name ); // side-effect: create mappings as necessary\n\t\t\t\t\titem.model = item.parentFragment.findContext().joinKey( item.name );\n\t\t\t\t}\n\t\n\t\t\t\titem.link = viewmodel.createLink( item.name, item.model, template[0].r );\n\t\n\t\t\t\tif ( item.model.get() === undefined && item.name in childData ) {\n\t\t\t\t\titem.model.set( childData[ item.name ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\titem.boundFragment = new Fragment({\n\t\t\t\t\towner: item,\n\t\t\t\t\ttemplate: template\n\t\t\t\t}).bind();\n\t\n\t\t\t\titem.model = viewmodel.joinKey( item.name );\n\t\t\t\titem.model.set( item.boundFragment.valueOf() );\n\t\n\t\t\t\t// item is a *bit* of a hack\n\t\t\t\titem.boundFragment.bubble = function () {\n\t\t\t\t\tFragment.prototype.bubble.call( item.boundFragment );\n\t\t\t\t\t// defer this to avoid mucking around model deps if there happens to be an expression involved\n\t\t\t\t\trunloop.scheduleTask(function () {\n\t\t\t\t\t\titem.boundFragment.update();\n\t\t\t\t\t\titem.model.set( item.boundFragment.valueOf() );\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\n\t\tvar Option = (function (Element) {\n\t\t\tfunction Option ( options ) {\n\t\t\t\tvar template = options.template;\n\t\t\t\tif ( !template.a ) template.a = {};\n\t\n\t\t\t\t// If the value attribute is missing, use the element's content,\n\t\t\t\t// as long as it isn't disabled\n\t\t\t\tif ( template.a.value === undefined && !( 'disabled' in template.a ) ) {\n\t\t\t\t\ttemplate.a.value = template.f || '';\n\t\t\t\t}\n\t\n\t\t\t\tElement.call( this, options );\n\t\n\t\t\t\tthis.select = findElement( this.parent || this.parentFragment, false, 'select' );\n\t\t\t}\n\t\n\t\t\tOption.prototype = Object.create( Element && Element.prototype );\n\t\t\tOption.prototype.constructor = Option;\n\t\n\t\t\tOption.prototype.bind = function bind () {\n\t\t\t\tif ( !this.select ) {\n\t\t\t\t\tElement.prototype.bind.call(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// If the select has a value, it overrides the `selected` attribute on\n\t\t\t\t// this option - so we delete the attribute\n\t\t\t\tvar selectedAttribute = this.attributeByName.selected;\n\t\t\t\tif ( selectedAttribute && this.select.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\tvar index = this.attributes.indexOf( selectedAttribute );\n\t\t\t\t\tthis.attributes.splice( index, 1 );\n\t\t\t\t\tdelete this.attributeByName.selected;\n\t\t\t\t}\n\t\n\t\t\t\tElement.prototype.bind.call(this);\n\t\t\t\tthis.select.options.push( this );\n\t\t\t};\n\t\n\t\t\tOption.prototype.bubble = function bubble () {\n\t\t\t\t// if we're using content as value, may need to update here\n\t\t\t\tvar value = this.getAttribute( 'value' );\n\t\t\t\tif ( this.node && this.node.value !== value ) {\n\t\t\t\t\tthis.node._ractive.value = value;\n\t\t\t\t}\n\t\t\t\tElement.prototype.bubble.call(this);\n\t\t\t};\n\t\n\t\t\tOption.prototype.getAttribute = function getAttribute ( name ) {\n\t\t\t\tvar attribute = this.attributeByName[ name ];\n\t\t\t\treturn attribute ? attribute.getValue() : name === 'value' && this.fragment ? this.fragment.valueOf() : undefined;\n\t\t\t};\n\t\n\t\t\tOption.prototype.isSelected = function isSelected () {\n\t\t\t\tvar optionValue = this.getAttribute( 'value' );\n\t\n\t\t\t\tif ( optionValue === undefined || !this.select ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\tvar selectValue = this.select.getAttribute( 'value' );\n\t\n\t\t\t\tif ( selectValue == optionValue ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\t\t\t\tvar i = selectValue.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tOption.prototype.render = function render ( target, occupants ) {\n\t\t\t\tElement.prototype.render.call( this, target, occupants );\n\t\n\t\t\t\tif ( !this.attributeByName.value ) {\n\t\t\t\t\tthis.node._ractive.value = this.getAttribute( 'value' );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tOption.prototype.unbind = function unbind () {\n\t\t\t\tElement.prototype.unbind.call(this);\n\t\n\t\t\t\tif ( this.select ) {\n\t\t\t\t\tremoveFromArray( this.select.options, this );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Option;\n\t\t}(Element));\n\t\n\t\tfunction getPartialTemplate ( ractive, name, parentFragment ) {\n\t\t\t// If the partial in instance or view heirarchy instances, great\n\t\t\tvar partial = getPartialFromRegistry( ractive, name, parentFragment || {} );\n\t\t\tif ( partial ) return partial;\n\t\n\t\t\t// Does it exist on the page as a script tag?\n\t\t\tpartial = parser.fromId( name, { noThrow: true } );\n\t\t\tif ( partial ) {\n\t\t\t\t// parse and register to this ractive instance\n\t\t\t\tvar parsed = parser.parseFor( partial, ractive );\n\t\n\t\t\t\t// register extra partials on the ractive instance if they don't already exist\n\t\t\t\tif ( parsed.p ) fillGaps( ractive.partials, parsed.p );\n\t\n\t\t\t\t// register (and return main partial if there are others in the template)\n\t\t\t\treturn ractive.partials[ name ] = parsed.t;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getPartialFromRegistry ( ractive, name, parentFragment ) {\n\t\t\t// if there was an instance up-hierarchy, cool\n\t\t\tvar partial = findParentPartial( name, parentFragment.owner );\n\t\t\tif ( partial ) return partial;\n\t\n\t\t\t// find first instance in the ractive or view hierarchy that has this partial\n\t\t\tvar instance = findInstance( 'partials', ractive, name );\n\t\n\t\t\tif ( !instance ) { return; }\n\t\n\t\t\tpartial = instance.partials[ name ];\n\t\n\t\t\t// partial is a function?\n\t\t\tvar fn;\n\t\t\tif ( typeof partial === 'function' ) {\n\t\t\t\tfn = partial.bind( instance );\n\t\t\t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n\t\t\t\tpartial = fn.call( ractive, parser );\n\t\t\t}\n\t\n\t\t\tif ( !partial && partial !== '' ) {\n\t\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// If this was added manually to the registry,\n\t\t\t// but hasn't been parsed, parse it now\n\t\t\tif ( !parser.isParsed( partial ) ) {\n\t\t\t\t// use the parseOptions of the ractive instance on which it was found\n\t\t\t\tvar parsed = parser.parseFor( partial, instance );\n\t\n\t\t\t\t// Partials cannot contain nested partials!\n\t\t\t\t// TODO add a test for this\n\t\t\t\tif ( parsed.p ) {\n\t\t\t\t\twarnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });\n\t\t\t\t}\n\t\n\t\t\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t\t\t// in the correct point in prototype chain on instance or constructor\n\t\t\t\tvar target = fn ? instance : findOwner( instance, name );\n\t\n\t\t\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\t\t\ttarget.partials[ name ] = partial = parsed.t;\n\t\t\t}\n\t\n\t\t\t// store for reset\n\t\t\tif ( fn ) partial._fn = fn;\n\t\n\t\t\treturn partial.v ? partial.t : partial;\n\t\t}\n\t\n\t\tfunction findOwner ( ractive, key ) {\n\t\t\treturn ractive.partials.hasOwnProperty( key )\n\t\t\t\t? ractive\n\t\t\t\t: findConstructor( ractive.constructor, key);\n\t\t}\n\t\n\t\tfunction findConstructor ( constructor, key ) {\n\t\t\tif ( !constructor ) { return; }\n\t\t\treturn constructor.partials.hasOwnProperty( key )\n\t\t\t\t? constructor\n\t\t\t\t: findConstructor( constructor._Parent, key );\n\t\t}\n\t\n\t\tfunction findParentPartial( name, parent ) {\n\t\t\tif ( parent ) {\n\t\t\t\tif ( parent.template && parent.template.p && parent.template.p[name] ) {\n\t\t\t\t\treturn parent.template.p[name];\n\t\t\t\t} else if ( parent.parentFragment && parent.parentFragment.owner ) {\n\t\t\t\t\treturn findParentPartial( name, parent.parentFragment.owner );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar Partial = (function (Mustache) {\n\t\t\tfunction Partial () {\n\t\t\t\tMustache.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tPartial.prototype = Object.create( Mustache && Mustache.prototype );\n\t\t\tPartial.prototype.constructor = Partial;\n\t\n\t\t\tPartial.prototype.bind = function bind () {\n\t\t\t\t// keep track of the reference name for future resets\n\t\t\t\tthis.refName = this.template.r;\n\t\n\t\t\t\t// name matches take priority over expressions\n\t\t\t\tvar template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;\n\t\t\t\tvar templateObj;\n\t\n\t\t\t\tif ( template ) {\n\t\t\t\t\tthis.named = true;\n\t\t\t\t\tthis.setTemplate( this.template.r, template );\n\t\t\t\t}\n\t\n\t\t\t\tif ( !template ) {\n\t\t\t\t\tMustache.prototype.bind.call(this);\n\t\t\t\t\tif ( this.model && ( templateObj = this.model.get() ) && typeof templateObj === 'object' && ( typeof templateObj.template === 'string' || isArray( templateObj.t ) ) ) {\n\t\t\t\t\t\tif ( templateObj.template ) {\n\t\t\t\t\t\t\tthis.source = templateObj.template;\n\t\t\t\t\t\t\ttemplateObj = parsePartial( this.template.r, templateObj.template, this.ractive );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.source = templateObj.t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.setTemplate( this.template.r, templateObj.t );\n\t\t\t\t\t} else if ( ( !this.model || typeof this.model.get() !== 'string' ) && this.refName ) {\n\t\t\t\t\t\tthis.setTemplate( this.refName, template );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setTemplate( this.model.get() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: this.partialTemplate\n\t\t\t\t}).bind();\n\t\t\t};\n\t\n\t\t\tPartial.prototype.detach = function detach () {\n\t\t\t\treturn this.fragment.detach();\n\t\t\t};\n\t\n\t\t\tPartial.prototype.find = function find ( selector ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.findAll = function findAll ( selector, query ) {\n\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.findComponent = function findComponent ( name ) {\n\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\t\treturn this.fragment.firstNode( skipParent );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.forceResetTemplate = function forceResetTemplate () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.partialTemplate = undefined;\n\t\n\t\t\t\t// on reset, check for the reference name first\n\t\t\t\tif ( this.refName ) {\n\t\t\t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );\n\t\t\t\t}\n\t\n\t\t\t\t// then look for the resolved name\n\t\t\t\tif ( !this.partialTemplate ) {\n\t\t\t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );\n\t\t\t\t}\n\t\n\t\t\t\tif ( !this.partialTemplate ) {\n\t\t\t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + (this.name) + \"'\") );\n\t\t\t\t\tthis.partialTemplate = [];\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.inAttribute ) {\n\t\t\t\t\tdoInAttributes( function () { return this$1.fragment.resetTemplate( this$1.partialTemplate ); } );\n\t\t\t\t} else {\n\t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t\t\t\t}\n\t\n\t\t\t\tthis.bubble();\n\t\t\t};\n\t\n\t\t\tPartial.prototype.render = function render ( target, occupants ) {\n\t\t\t\tthis.fragment.render( target, occupants );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.setTemplate = function setTemplate ( name, template ) {\n\t\t\t\tthis.name = name;\n\t\n\t\t\t\tif ( !template && template !== null ) template = getPartialTemplate( this.ractive, name, this.parentFragment );\n\t\n\t\t\t\tif ( !template ) {\n\t\t\t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + name + \"'\") );\n\t\t\t\t}\n\t\n\t\t\t\tthis.partialTemplate = template || [];\n\t\t\t};\n\t\n\t\t\tPartial.prototype.toString = function toString ( escape ) {\n\t\t\t\treturn this.fragment.toString( escape );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.unbind = function unbind () {\n\t\t\t\tMustache.prototype.unbind.call(this);\n\t\t\t\tthis.fragment.unbind();\n\t\t\t};\n\t\n\t\t\tPartial.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t};\n\t\n\t\t\tPartial.prototype.update = function update () {\n\t\t\t\tvar template;\n\t\n\t\t\t\tif ( this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\n\t\t\t\t\tif ( !this.named ) {\n\t\t\t\t\t\tif ( this.model ) {\n\t\t\t\t\t\t\ttemplate = this.model.get();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( template && typeof template === 'string' && template !== this.name ) {\n\t\t\t\t\t\t\tthis.setTemplate( template );\n\t\t\t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t\t\t\t\t\t} else if ( template && typeof template === 'object' && ( typeof template.template === 'string' || isArray( template.t ) ) ) {\n\t\t\t\t\t\t\tif ( template.t !== this.source && template.template !== this.source ) {\n\t\t\t\t\t\t\t\tif ( template.template ) {\n\t\t\t\t\t\t\t\t\tthis.source = template.template;\n\t\t\t\t\t\t\t\t\ttemplate = parsePartial( this.name, template.template, this.ractive );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.source = template.t;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.setTemplate( this.name, template.t );\n\t\t\t\t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.fragment.update();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Partial;\n\t\t}(Mustache));\n\t\n\t\tfunction parsePartial( name, partial, ractive ) {\n\t\t\tvar parsed;\n\t\n\t\t\ttry {\n\t\t\t\tparsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\t\t\t} catch (e) {\n\t\t\t\twarnIfDebug( (\"Could not parse partial from expression '\" + name + \"'\\n\" + (e.message)) );\n\t\t\t}\n\t\n\t\t\treturn parsed || { t: [] };\n\t\t}\n\t\n\t\tvar RepeatedFragment = function RepeatedFragment ( options ) {\n\t\t\tthis.parent = options.owner.parentFragment;\n\t\n\t\t\t// bit of a hack, so reference resolution works without another\n\t\t\t// layer of indirection\n\t\t\tthis.parentFragment = this;\n\t\t\tthis.owner = options.owner;\n\t\t\tthis.ractive = this.parent.ractive;\n\t\n\t\t\t// encapsulated styles should be inherited until they get applied by an element\n\t\t\tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\t\n\t\t\tthis.context = null;\n\t\t\tthis.rendered = false;\n\t\t\tthis.iterations = [];\n\t\n\t\t\tthis.template = options.template;\n\t\n\t\t\tthis.indexRef = options.indexRef;\n\t\t\tthis.keyRef = options.keyRef;\n\t\n\t\t\tthis.pendingNewIndices = null;\n\t\t\tthis.previousIterations = null;\n\t\n\t\t\t// track array versus object so updates of type rest\n\t\t\tthis.isArray = false;\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.bind = function bind ( context ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.context = context;\n\t\t\tvar value = context.get();\n\t\n\t\t\t// {{#each array}}...\n\t\t\tif ( this.isArray = isArray( value ) ) {\n\t\t\t\t// we can't use map, because of sparse arrays\n\t\t\t\tthis.iterations = [];\n\t\t\t\tvar max = value.length;\n\t\t\t\tfor ( var i = 0; i < max; i += 1 ) {\n\t\t\t\t\tthis$1.iterations[i] = this$1.createIteration( i, i );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// {{#each object}}...\n\t\t\telse if ( isObject( value ) ) {\n\t\t\t\tthis.isArray = false;\n\t\n\t\t\t\t// TODO this is a dreadful hack. There must be a neater way\n\t\t\t\tif ( this.indexRef ) {\n\t\t\t\t\tvar refs = this.indexRef.split( ',' );\n\t\t\t\t\tthis.keyRef = refs[0];\n\t\t\t\t\tthis.indexRef = refs[1];\n\t\t\t\t}\n\t\n\t\t\t\tthis.iterations = Object.keys( value ).map( function ( key, index ) {\n\t\t\t\t\treturn this$1.createIteration( key, index );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.bubble = function bubble () {\n\t\t\tthis.owner.bubble();\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {\n\t\t\tvar fragment = new Fragment({\n\t\t\t\towner: this,\n\t\t\t\ttemplate: this.template\n\t\t\t});\n\t\n\t\t\t// TODO this is a bit hacky\n\t\t\tfragment.key = key;\n\t\t\tfragment.index = index;\n\t\t\tfragment.isIteration = true;\n\t\n\t\t\tvar model = this.context.joinKey( key );\n\t\n\t\t\t// set up an iteration alias if there is one\n\t\t\tif ( this.owner.template.z ) {\n\t\t\t\tfragment.aliases = {};\n\t\t\t\tfragment.aliases[ this.owner.template.z[0].n ] = model;\n\t\t\t}\n\t\n\t\t\treturn fragment.bind( model );\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.destroyed = function destroyed () {\n\t\t\tthis.iterations.forEach( function ( i ) { return i.destroyed(); } );\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.detach = function detach () {\n\t\t\tvar docFrag = createDocumentFragment();\n\t\t\tthis.iterations.forEach( function ( fragment ) { return docFrag.appendChild( fragment.detach() ); } );\n\t\t\treturn docFrag;\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.find = function find ( selector ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.iterations.length;\n\t\t\tvar i;\n\t\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar found = this$1.iterations[i].find( selector );\n\t\t\t\tif ( found ) return found;\n\t\t\t}\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.findAll = function findAll ( selector, query ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.iterations.length;\n\t\t\tvar i;\n\t\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tthis$1.iterations[i].findAll( selector, query );\n\t\t\t}\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.findComponent = function findComponent ( name ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.iterations.length;\n\t\t\tvar i;\n\t\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar found = this$1.iterations[i].findComponent( name );\n\t\t\t\tif ( found ) return found;\n\t\t\t}\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.iterations.length;\n\t\t\tvar i;\n\t\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tthis$1.iterations[i].findAllComponents( name, query );\n\t\t\t}\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( iteration.index < this.iterations.length - 1 ) {\n\t\t\t\tfor ( var i = iteration.index + 1; i < this$1.iterations.length; i++ ) {\n\t\t\t\t\tvar node = this$1.iterations[ i ].firstNode( true );\n\t\t\t\t\tif ( node ) return node;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.owner.findNextNode();\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\treturn this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null;\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.rebinding = function rebinding ( next ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tthis.context = next;\n\t\t\tthis.iterations.forEach( function ( fragment ) {\n\t\t\t\tvar model = next ? next.joinKey( fragment.key || fragment.index ) : undefined;\n\t\t\t\tfragment.context = model;\n\t\t\t\tif ( this$1.owner.template.z ) {\n\t\t\t\t\tfragment.aliases = {};\n\t\t\t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.render = function render ( target, occupants ) {\n\t\t\t// TODO use docFrag.cloneNode...\n\t\n\t\t\tif ( this.iterations ) {\n\t\t\t\tthis.iterations.forEach( function ( fragment ) { return fragment.render( target, occupants ); } );\n\t\t\t}\n\t\n\t\t\tthis.rendered = true;\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.pendingNewIndices ) this.previousIterations = this.iterations.slice();\n\t\n\t\t\tif ( !this.pendingNewIndices ) this.pendingNewIndices = [];\n\t\n\t\t\tthis.pendingNewIndices.push( newIndices );\n\t\n\t\t\tvar iterations = [];\n\t\n\t\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\t\tif ( newIndex === -1 ) return;\n\t\n\t\t\t\tvar fragment = this$1.iterations[ oldIndex ];\n\t\t\t\titerations[ newIndex ] = fragment;\n\t\n\t\t\t\tif ( newIndex !== oldIndex && fragment ) fragment.dirty = true;\n\t\t\t});\n\t\n\t\t\tthis.iterations = iterations;\n\t\n\t\t\tthis.bubble();\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.shuffled = function shuffled () {\n\t\t\tthis.iterations.forEach( function ( i ) { return i.shuffled(); } );\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.toString = function toString$1$$ ( escape ) {\n\t\t\treturn this.iterations ?\n\t\t\t\tthis.iterations.map( escape ? toEscapedString : toString$1 ).join( '' ) :\n\t\t\t\t'';\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.unbind = function unbind$1 () {\n\t\t\tthis.iterations.forEach( unbind );\n\t\t\treturn this;\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t\t\tthis.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\t\t\tif ( this.pendingNewIndices && this.previousIterations ) {\n\t\t\t\tthis.previousIterations.forEach( function ( fragment ) {\n\t\t\t\t\tif ( fragment.rendered ) shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment );\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.rendered = false;\n\t\t};\n\t\n\t\t// TODO smart update\n\t\tRepeatedFragment.prototype.update = function update$1 () {\n\t\t\t// skip dirty check, since this is basically just a facade\n\t\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.pendingNewIndices ) {\n\t\t\t\tthis.updatePostShuffle();\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( this.updating ) return;\n\t\t\tthis.updating = true;\n\t\n\t\t\tvar value = this.context.get(),\n\t\t\t\t\t  wasArray = this.isArray;\n\t\n\t\t\tvar toRemove;\n\t\t\tvar oldKeys;\n\t\t\tvar reset = true;\n\t\t\tvar i;\n\t\n\t\t\tif ( this.isArray = isArray( value ) ) {\n\t\t\t\tif ( wasArray ) {\n\t\t\t\t\treset = false;\n\t\t\t\t\tif ( this.iterations.length > value.length ) {\n\t\t\t\t\t\ttoRemove = this.iterations.splice( value.length );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( isObject( value ) && !wasArray ) {\n\t\t\t\treset = false;\n\t\t\t\ttoRemove = [];\n\t\t\t\toldKeys = {};\n\t\t\t\ti = this.iterations.length;\n\t\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar fragment$1 = this$1.iterations[i];\n\t\t\t\t\tif ( fragment$1.key in value ) {\n\t\t\t\t\t\toldKeys[ fragment$1.key ] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis$1.iterations.splice( i, 1 );\n\t\t\t\t\t\ttoRemove.push( fragment$1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( reset ) {\n\t\t\t\ttoRemove = this.iterations;\n\t\t\t\tthis.iterations = [];\n\t\t\t}\n\t\n\t\t\tif ( toRemove ) {\n\t\t\t\ttoRemove.forEach( function ( fragment ) {\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t\tfragment.unrender( true );\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// update the remaining ones\n\t\t\tthis.iterations.forEach( update );\n\t\n\t\t\t// add new iterations\n\t\t\tvar newLength = isArray( value ) ?\n\t\t\t\tvalue.length :\n\t\t\t\tisObject( value ) ?\n\t\t\t\t\tObject.keys( value ).length :\n\t\t\t\t\t0;\n\t\n\t\t\tvar docFrag;\n\t\t\tvar fragment;\n\t\n\t\t\tif ( newLength > this.iterations.length ) {\n\t\t\t\tdocFrag = this.rendered ? createDocumentFragment() : null;\n\t\t\t\ti = this.iterations.length;\n\t\n\t\t\t\tif ( isArray( value ) ) {\n\t\t\t\t\twhile ( i < value.length ) {\n\t\t\t\t\t\tfragment = this$1.createIteration( i, i );\n\t\n\t\t\t\t\t\tthis$1.iterations.push( fragment );\n\t\t\t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\t\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\telse if ( isObject( value ) ) {\n\t\t\t\t\t// TODO this is a dreadful hack. There must be a neater way\n\t\t\t\t\tif ( this.indexRef && !this.keyRef ) {\n\t\t\t\t\t\tvar refs = this.indexRef.split( ',' );\n\t\t\t\t\t\tthis.keyRef = refs[0];\n\t\t\t\t\t\tthis.indexRef = refs[1];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tObject.keys( value ).forEach( function ( key ) {\n\t\t\t\t\t\tif ( !oldKeys || !( key in oldKeys ) ) {\n\t\t\t\t\t\t\tfragment = this$1.createIteration( key, i );\n\t\n\t\t\t\t\t\t\tthis$1.iterations.push( fragment );\n\t\t\t\t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\t\n\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\tvar parentNode = this.parent.findParentNode();\n\t\t\t\t\tvar anchor = this.parent.findNextNode( this.owner );\n\t\n\t\t\t\t\tparentNode.insertBefore( docFrag, anchor );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.updating = false;\n\t\t};\n\t\n\t\tRepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar newIndices = this.pendingNewIndices[ 0 ];\n\t\n\t\t\t// map first shuffle through\n\t\t\tthis.pendingNewIndices.slice( 1 ).forEach( function ( indices ) {\n\t\t\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\t\t\tnewIndices[ oldIndex ] = indices[ newIndex ];\n\t\t\t\t});\n\t\t\t});\n\t\n\t\t\t// This algorithm (for detaching incorrectly-ordered fragments from the DOM and\n\t\t\t// storing them in a document fragment for later reinsertion) seems a bit hokey,\n\t\t\t// but it seems to work for now\n\t\t\tvar len = this.context.get().length, oldLen = this.previousIterations.length;\n\t\t\tvar i;\n\t\t\tvar removed = {};\n\t\n\t\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\t\tvar fragment = this$1.previousIterations[ oldIndex ];\n\t\t\t\tthis$1.previousIterations[ oldIndex ] = null;\n\t\n\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\tremoved[ oldIndex ] = fragment;\n\t\t\t\t} else if ( fragment.index !== newIndex ) {\n\t\t\t\t\tvar model = this$1.context.joinKey( newIndex );\n\t\t\t\t\tfragment.index = newIndex;\n\t\t\t\t\tfragment.context = model;\n\t\t\t\t\tif ( this$1.owner.template.z ) {\n\t\t\t\t\t\tfragment.aliases = {};\n\t\t\t\t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t// if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices\n\t\t\tthis.previousIterations.forEach( function ( frag, i ) {\n\t\t\t\tif ( frag ) removed[ i ] = frag;\n\t\t\t});\n\t\n\t\t\t// create new/move existing iterations\n\t\t\tvar docFrag = this.rendered ? createDocumentFragment() : null;\n\t\t\tvar parentNode = this.rendered ? this.parent.findParentNode() : null;\n\t\n\t\t\tvar contiguous = 'startIndex' in newIndices;\n\t\t\ti = contiguous ? newIndices.startIndex : 0;\n\t\n\t\t\tfor ( i; i < len; i++ ) {\n\t\t\t\tvar frag = this$1.iterations[i];\n\t\n\t\t\t\tif ( frag && contiguous ) {\n\t\t\t\t\t// attach any built-up iterations\n\t\t\t\t\tif ( this$1.rendered ) {\n\t\t\t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t\t\t\t\t\tif ( docFrag.childNodes.length  ) parentNode.insertBefore( docFrag, frag.firstNode() );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tif ( !frag ) this$1.iterations[i] = this$1.createIteration( i, i );\n\t\n\t\t\t\tif ( this$1.rendered ) {\n\t\t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t\n\t\t\t\t\tif ( frag ) docFrag.appendChild( frag.detach() );\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis$1.iterations[i].render( docFrag );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// append any leftovers\n\t\t\tif ( this.rendered ) {\n\t\t\t\tfor ( i = len; i < oldLen; i++ ) {\n\t\t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t\t\t\t}\n\t\n\t\t\t\tif ( docFrag.childNodes.length ) {\n\t\t\t\t\tparentNode.insertBefore( docFrag, this.owner.findNextNode() );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// trigger removal on old nodes\n\t\t\tObject.keys( removed ).forEach( function ( k ) { return removed[k].unbind().unrender( true ); } );\n\t\n\t\t\tthis.iterations.forEach( update );\n\t\n\t\t\tthis.pendingNewIndices = null;\n\t\n\t\t\tthis.shuffled();\n\t\t};\n\t\n\t\tfunction isEmpty ( value ) {\n\t\t\treturn !value ||\n\t\t\t       ( isArray( value ) && value.length === 0 ) ||\n\t\t\t\t   ( isObject( value ) && Object.keys( value ).length === 0 );\n\t\t}\n\t\n\t\tfunction getType ( value, hasIndexRef ) {\n\t\t\tif ( hasIndexRef || isArray( value ) ) return SECTION_EACH;\n\t\t\tif ( isObject( value ) || typeof value === 'function' ) return SECTION_IF_WITH;\n\t\t\tif ( value === undefined ) return null;\n\t\t\treturn SECTION_IF;\n\t\t}\n\t\n\t\tvar Section = (function (Mustache) {\n\t\t\tfunction Section ( options ) {\n\t\t\t\tMustache.call( this, options );\n\t\n\t\t\t\tthis.sectionType = options.template.n || null;\n\t\t\t\tthis.templateSectionType = this.sectionType;\n\t\t\t\tthis.subordinate = options.template.l === 1;\n\t\t\t\tthis.fragment = null;\n\t\t\t}\n\t\n\t\t\tSection.prototype = Object.create( Mustache && Mustache.prototype );\n\t\t\tSection.prototype.constructor = Section;\n\t\n\t\t\tSection.prototype.bind = function bind () {\n\t\t\t\tMustache.prototype.bind.call(this);\n\t\n\t\t\t\tif ( this.subordinate ) {\n\t\t\t\t\tthis.sibling = this.parentFragment.items[ this.parentFragment.items.indexOf( this ) - 1 ];\n\t\t\t\t\tthis.sibling.nextSibling = this;\n\t\t\t\t}\n\t\n\t\t\t\t// if we managed to bind, we need to create children\n\t\t\t\tif ( this.model ) {\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\tthis.update();\n\t\t\t\t} else if ( this.sectionType && this.sectionType === SECTION_UNLESS && ( !this.sibling || !this.sibling.isTruthy() ) ) {\n\t\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\ttemplate: this.template.f\n\t\t\t\t\t}).bind();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSection.prototype.detach = function detach () {\n\t\t\t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n\t\t\t};\n\t\n\t\t\tSection.prototype.find = function find ( selector ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\treturn this.fragment.find( selector );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSection.prototype.findAll = function findAll ( selector, query ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSection.prototype.findComponent = function findComponent ( name ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSection.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSection.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\t\treturn this.fragment && this.fragment.firstNode( skipParent );\n\t\t\t};\n\t\n\t\t\tSection.prototype.isTruthy = function isTruthy () {\n\t\t\t\tif ( this.subordinate && this.sibling.isTruthy() ) return true;\n\t\t\t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n\t\t\t\treturn !!value && ( this.templateSectionType === SECTION_IF_WITH || !isEmpty( value ) );\n\t\t\t};\n\t\n\t\t\tSection.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\t\tif ( Mustache.prototype.rebinding.call( this, next, previous, safe ) ) {\n\t\t\t\t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n\t\t\t\t\t\tthis.fragment.rebinding( next, previous );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSection.prototype.render = function render ( target, occupants ) {\n\t\t\t\tthis.rendered = true;\n\t\t\t\tif ( this.fragment ) this.fragment.render( target, occupants );\n\t\t\t};\n\t\n\t\t\tSection.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\t\tif ( this.fragment && this.sectionType === SECTION_EACH ) {\n\t\t\t\t\tthis.fragment.shuffle( newIndices );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSection.prototype.toString = function toString ( escape ) {\n\t\t\t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n\t\t\t};\n\t\n\t\t\tSection.prototype.unbind = function unbind () {\n\t\t\t\tMustache.prototype.unbind.call(this);\n\t\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t\t};\n\t\n\t\t\tSection.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n\t\t\t\tthis.rendered = false;\n\t\t\t};\n\t\n\t\t\tSection.prototype.update = function update () {\n\t\t\t\tif ( !this.dirty ) return;\n\t\n\t\t\t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n\t\t\t\t\tthis.fragment.context = this.model;\n\t\t\t\t}\n\t\n\t\t\t\tif ( !this.model && this.sectionType !== SECTION_UNLESS ) return;\n\t\n\t\t\t\tthis.dirty = false;\n\t\n\t\t\t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n\t\t\t\tvar siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n\t\t\t\tvar lastType = this.sectionType;\n\t\n\t\t\t\t// watch for switching section types\n\t\t\t\tif ( this.sectionType === null || this.templateSectionType === null ) this.sectionType = getType( value, this.template.i );\n\t\t\t\tif ( lastType && lastType !== this.sectionType && this.fragment ) {\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\tthis.fragment.unbind().unrender( true );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.fragment = null;\n\t\t\t\t}\n\t\n\t\t\t\tvar newFragment;\n\t\n\t\t\t\tvar fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n\t\t\t\t                            this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n\t\t\t\t                            ( siblingFalsey && ( this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy() ) ); // if, unless, and if-with depend on siblings and the condition\n\t\n\t\t\t\tif ( fragmentShouldExist ) {\n\t\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t\tthis.fragment.update();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( this.sectionType === SECTION_EACH ) {\n\t\t\t\t\t\t\tnewFragment = new RepeatedFragment({\n\t\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\t\ttemplate: this.template.f,\n\t\t\t\t\t\t\t\tindexRef: this.template.i\n\t\t\t\t\t\t\t}).bind( this.model );\n\t\t\t\t\t\t} else {\n\t\t\t \t\t\t\t// only with and if-with provide context - if and unless do not\n\t\t\t\t\t\t\tvar context = this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ? this.model : null;\n\t\t\t\t\t\t\tnewFragment = new Fragment({\n\t\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\t\ttemplate: this.template.f\n\t\t\t\t\t\t\t}).bind( context );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( this.fragment && this.rendered ) {\n\t\t\t\t\t\tthis.fragment.unbind().unrender( true );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.fragment = null;\n\t\t\t\t}\n\t\n\t\t\t\tif ( newFragment ) {\n\t\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\t\tvar parentNode = this.parentFragment.findParentNode();\n\t\t\t\t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\t\n\t\t\t\t\t\tif ( anchor ) {\n\t\t\t\t\t\t\tvar docFrag = createDocumentFragment();\n\t\t\t\t\t\t\tnewFragment.render( docFrag );\n\t\n\t\t\t\t\t\t\t// we use anchor.parentNode, not parentNode, because the sibling\n\t\t\t\t\t\t\t// may be temporarily detached as a result of a shuffle\n\t\t\t\t\t\t\tanchor.parentNode.insertBefore( docFrag, anchor );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewFragment.render( parentNode );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.fragment = newFragment;\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.nextSibling ) {\n\t\t\t\t\tthis.nextSibling.dirty = true;\n\t\t\t\t\tthis.nextSibling.update();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Section;\n\t\t}(Mustache));\n\t\n\t\tfunction valueContains ( selectValue, optionValue ) {\n\t\t\tvar i = selectValue.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( selectValue[i] == optionValue ) return true;\n\t\t\t}\n\t\t}\n\t\n\t\tvar Select = (function (Element) {\n\t\t\tfunction Select ( options ) {\n\t\t\t\tElement.call( this, options );\n\t\t\t\tthis.options = [];\n\t\t\t}\n\t\n\t\t\tSelect.prototype = Object.create( Element && Element.prototype );\n\t\t\tSelect.prototype.constructor = Select;\n\t\n\t\t\tSelect.prototype.foundNode = function foundNode ( node ) {\n\t\t\t\tif ( this.binding ) {\n\t\t\t\t\tvar selectedOptions = getSelectedOptions( node );\n\t\n\t\t\t\t\tif ( selectedOptions.length > 0 ) {\n\t\t\t\t\t\tthis.selectedOptions = selectedOptions;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSelect.prototype.render = function render ( target, occupants ) {\n\t\t\t\tElement.prototype.render.call( this, target, occupants );\n\t\t\t\tthis.sync();\n\t\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tvar i = node.options.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tnode.options[i].defaultSelected = node.options[i].selected;\n\t\t\t\t}\n\t\n\t\t\t\tthis.rendered = true;\n\t\t\t};\n\t\n\t\t\tSelect.prototype.sync = function sync () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar selectNode = this.node;\n\t\n\t\t\t\tif ( !selectNode ) return;\n\t\n\t\t\t\tvar options = toArray( selectNode.options );\n\t\n\t\t\t\tif ( this.selectedOptions ) {\n\t\t\t\t\toptions.forEach( function ( o ) {\n\t\t\t\t\t\tif ( this$1.selectedOptions.indexOf( o ) >= 0 ) o.selected = true;\n\t\t\t\t\t\telse o.selected = false;\n\t\t\t\t\t});\n\t\t\t\t\tthis.binding.setFromNode( selectNode );\n\t\t\t\t\tdelete this.selectedOptions;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar selectValue = this.getAttribute( 'value' );\n\t\t\t\tvar isMultiple = this.getAttribute( 'multiple' );\n\t\n\t\t\t\t// If the <select> has a specified value, that should override\n\t\t\t\t// these options\n\t\t\t\tif ( selectValue !== undefined ) {\n\t\t\t\t\tvar optionWasSelected;\n\t\n\t\t\t\t\toptions.forEach( function ( o ) {\n\t\t\t\t\t\tvar optionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\t\t\t\tvar shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\t\n\t\t\t\t\t\tif ( shouldSelect ) {\n\t\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\to.selected = shouldSelect;\n\t\t\t\t\t});\n\t\n\t\t\t\t\tif ( !optionWasSelected && !isMultiple ) {\n\t\t\t\t\t\tif ( this.binding ) {\n\t\t\t\t\t\t\tthis.binding.forceUpdate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Otherwise the value should be initialised according to which\n\t\t\t\t// <option> element is selected, if twoway binding is in effect\n\t\t\t\telse if ( this.binding ) {\n\t\t\t\t\tthis.binding.forceUpdate();\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tSelect.prototype.update = function update () {\n\t\t\t\tElement.prototype.update.call(this);\n\t\t\t\tthis.sync();\n\t\t\t};\n\t\n\t\t\treturn Select;\n\t\t}(Element));\n\t\n\t\tvar Textarea = (function (Input) {\n\t\t\tfunction Textarea( options ) {\n\t\t\t\tvar template = options.template;\n\t\n\t\t\t\toptions.deferContent = true;\n\t\n\t\t\t\tInput.call( this, options );\n\t\n\t\t\t\t// check for single interpolator binding\n\t\t\t\tif ( !this.attributeByName.value ) {\n\t\t\t\t\tif ( template.f && isBindable( { template: template } ) ) {\n\t\t\t\t\t\tthis.attributes.push( createItem( {\n\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\ttemplate: { t: ATTRIBUTE, f: template.f, n: 'value' },\n\t\t\t\t\t\t\tparentFragment: this.parentFragment\n\t\t\t\t\t\t} ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.fragment = new Fragment({ owner: this, cssIds: null, template: template.f });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tTextarea.prototype = Object.create( Input && Input.prototype );\n\t\t\tTextarea.prototype.constructor = Textarea;\n\t\n\t\t\tTextarea.prototype.bubble = function bubble () {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\t\tif ( this.rendered && !this.binding && this.fragment ) {\n\t\t\t\t\t\trunloop.scheduleTask( function () {\n\t\t\t\t\t\t\tthis$1.dirty = false;\n\t\t\t\t\t\t\tthis$1.node.value = this$1.fragment.toString();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.parentFragment.bubble(); // default behaviour\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Textarea;\n\t\t}(Input));\n\t\n\t\tvar Text = (function (Item) {\n\t\t\tfunction Text ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\t\t\tthis.type = TEXT;\n\t\t\t}\n\t\n\t\t\tText.prototype = Object.create( Item && Item.prototype );\n\t\t\tText.prototype.constructor = Text;\n\t\n\t\t\tText.prototype.bind = function bind () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tText.prototype.detach = function detach () {\n\t\t\t\treturn detachNode( this.node );\n\t\t\t};\n\t\n\t\t\tText.prototype.firstNode = function firstNode () {\n\t\t\t\treturn this.node;\n\t\t\t};\n\t\n\t\t\tText.prototype.render = function render ( target, occupants ) {\n\t\t\t\tif ( inAttributes() ) return;\n\t\t\t\tthis.rendered = true;\n\t\n\t\t\t\tif ( occupants ) {\n\t\t\t\t\tvar n = occupants[0];\n\t\t\t\t\tif ( n && n.nodeType === 3 ) {\n\t\t\t\t\t\toccupants.shift();\n\t\t\t\t\t\tif ( n.nodeValue !== this.template ) {\n\t\t\t\t\t\t\tn.nodeValue = this.template;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tn = this.node = doc.createTextNode( this.template );\n\t\t\t\t\t\tif ( occupants[0] ) {\n\t\t\t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.appendChild( n );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.node = n;\n\t\t\t\t} else {\n\t\t\t\t\tthis.node = doc.createTextNode( this.template );\n\t\t\t\t\ttarget.appendChild( this.node );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tText.prototype.toString = function toString ( escape ) {\n\t\t\t\treturn escape ? escapeHtml( this.template ) : this.template;\n\t\t\t};\n\t\n\t\t\tText.prototype.unbind = function unbind () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tText.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tif ( this.rendered && shouldDestroy ) this.detach();\n\t\t\t\tthis.rendered = false;\n\t\t\t};\n\t\n\t\t\tText.prototype.update = function update () {\n\t\t\t\t// noop\n\t\t\t};\n\t\n\t\t\tText.prototype.valueOf = function valueOf () {\n\t\t\t\treturn this.template;\n\t\t\t};\n\t\n\t\t\treturn Text;\n\t\t}(Item));\n\t\n\t\tfunction camelCase ( hyphenatedStr ) {\n\t\t\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t\t\t\treturn $1.toUpperCase();\n\t\t\t});\n\t\t}\n\t\n\t\tvar prefix;\n\t\n\t\tif ( !isClient ) {\n\t\t\tprefix = null;\n\t\t} else {\n\t\t\tvar prefixCache = {};\n\t\t\tvar testStyle = createElement( 'div' ).style;\n\t\n\t\t\tprefix = function ( prop ) {\n\t\t\t\tprop = camelCase( prop );\n\t\n\t\t\t\tif ( !prefixCache[ prop ] ) {\n\t\t\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t\t\t}\n\t\n\t\t\t\t\telse {\n\t\t\t\t\t\t// test vendors...\n\t\t\t\t\t\tvar capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\t\n\t\t\t\t\t\tvar i = vendors.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tvar vendor = vendors[i];\n\t\t\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn prefixCache[ prop ];\n\t\t\t};\n\t\t}\n\t\n\t\tvar prefix$1 = prefix;\n\t\n\t\tvar visible;\n\t\tvar hidden = 'hidden';\n\t\n\t\tif ( doc ) {\n\t\t\tvar prefix$2;\n\t\n\t\t\tif ( hidden in doc ) {\n\t\t\t\tprefix$2 = '';\n\t\t\t} else {\n\t\t\t\tvar i$1 = vendors.length;\n\t\t\t\twhile ( i$1-- ) {\n\t\t\t\t\tvar vendor = vendors[i$1];\n\t\t\t\t\thidden = vendor + 'Hidden';\n\t\n\t\t\t\t\tif ( hidden in doc ) {\n\t\t\t\t\t\tprefix$2 = vendor;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( prefix$2 !== undefined ) {\n\t\t\t\tdoc.addEventListener( prefix$2 + 'visibilitychange', onChange );\n\t\t\t\tonChange();\n\t\t\t} else {\n\t\t\t\t// gah, we're in an old browser\n\t\t\t\tif ( 'onfocusout' in doc ) {\n\t\t\t\t\tdoc.addEventListener( 'focusout', onHide );\n\t\t\t\t\tdoc.addEventListener( 'focusin', onShow );\n\t\t\t\t}\n\t\n\t\t\t\telse {\n\t\t\t\t\twin.addEventListener( 'pagehide', onHide );\n\t\t\t\t\twin.addEventListener( 'blur', onHide );\n\t\n\t\t\t\t\twin.addEventListener( 'pageshow', onShow );\n\t\t\t\t\twin.addEventListener( 'focus', onShow );\n\t\t\t\t}\n\t\n\t\t\t\tvisible = true; // until proven otherwise. Not ideal but hey\n\t\t\t}\n\t\t}\n\t\n\t\tfunction onChange () {\n\t\t\tvisible = !doc[ hidden ];\n\t\t}\n\t\n\t\tfunction onHide () {\n\t\t\tvisible = false;\n\t\t}\n\t\n\t\tfunction onShow () {\n\t\t\tvisible = true;\n\t\t}\n\t\n\t\tvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\t\n\t\tfunction unprefix ( prop ) {\n\t\t\treturn prop.replace( unprefixPattern, '' );\n\t\t}\n\t\n\t\tvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\t\n\t\tfunction hyphenate ( str ) {\n\t\t\tif ( !str ) return ''; // edge case\n\t\n\t\t\tif ( vendorPattern.test( str ) ) str = '-' + str;\n\t\n\t\t\treturn str.replace( /[A-Z]/g, function ( match ) { return '-' + match.toLowerCase(); } );\n\t\t}\n\t\n\t\tvar createTransitions;\n\t\n\t\tif ( !isClient ) {\n\t\t\tcreateTransitions = null;\n\t\t} else {\n\t\t\tvar testStyle$1 = createElement( 'div' ).style;\n\t\t\tvar linear$1 = function ( x ) { return x; };\n\t\n\t\t\tvar canUseCssTransitions = {};\n\t\t\tvar cannotUseCssTransitions = {};\n\t\n\t\t\t// determine some facts about our environment\n\t\t\tvar TRANSITION$1;\n\t\t\tvar TRANSITIONEND;\n\t\t\tvar CSS_TRANSITIONS_ENABLED;\n\t\t\tvar TRANSITION_DURATION;\n\t\t\tvar TRANSITION_PROPERTY;\n\t\t\tvar TRANSITION_TIMING_FUNCTION;\n\t\n\t\t\tif ( testStyle$1.transition !== undefined ) {\n\t\t\t\tTRANSITION$1 = 'transition';\n\t\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t} else if ( testStyle$1.webkitTransition !== undefined ) {\n\t\t\t\tTRANSITION$1 = 'webkitTransition';\n\t\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t} else {\n\t\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t\t}\n\t\n\t\t\tif ( TRANSITION$1 ) {\n\t\t\t\tTRANSITION_DURATION = TRANSITION$1 + 'Duration';\n\t\t\t\tTRANSITION_PROPERTY = TRANSITION$1 + 'Property';\n\t\t\t\tTRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';\n\t\t\t}\n\t\n\t\t\tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\t\n\t\t\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t\t\t// TODO use a fastdom-style mechanism?\n\t\t\t\tsetTimeout( function () {\n\t\t\t\t\tvar jsTransitionsComplete;\n\t\t\t\t\tvar cssTransitionsComplete;\n\t\t\t\t\tvar cssTimeout;\n\t\n\t\t\t\t\tfunction transitionDone () { clearTimeout( cssTimeout ); }\n\t\n\t\t\t\t\tfunction checkComplete () {\n\t\t\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t\t\tt.unregisterCompleteHandler( transitionDone );\n\t\t\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\t\t\tt.ractive.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t\t\t// which properties\n\t\t\t\t\tvar hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\t\n\t\t\t\t\t// need to reset transition properties\n\t\t\t\t\tvar style = t.node.style;\n\t\t\t\t\tvar previous = {\n\t\t\t\t\t\tproperty: style[ TRANSITION_PROPERTY ],\n\t\t\t\t\t\ttiming: style[ TRANSITION_TIMING_FUNCTION ],\n\t\t\t\t\t\tduration: style[ TRANSITION_DURATION ]\n\t\t\t\t\t};\n\t\n\t\t\t\t\tstyle[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );\n\t\t\t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\t\t\tstyle[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\t\n\t\t\t\t\tfunction transitionEndHandler ( event ) {\n\t\t\t\t\t\tvar index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t\t\t// still transitioning...\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tclearTimeout( cssTimeout );\n\t\t\t\t\t\tcssTransitionsDone();\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfunction cssTransitionsDone () {\n\t\t\t\t\t\tstyle[ TRANSITION_PROPERTY ] = previous.property;\n\t\t\t\t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = previous.duration;\n\t\t\t\t\t\tstyle[ TRANSITION_DURATION ] = previous.timing;\n\t\n\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\n\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\n\t\t\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\n\t\t\t\t\t// safety net in case transitionend never fires\n\t\t\t\t\tcssTimeout = setTimeout( function () {\n\t\t\t\t\t\tchangedProperties = [];\n\t\t\t\t\t\tcssTransitionsDone();\n\t\t\t\t\t}, options.duration + ( options.delay || 0 ) + 50 );\n\t\t\t\t\tt.registerCompleteHandler( transitionDone );\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\t\t\t\t\tvar i = changedProperties.length;\n\t\t\t\t\t\tvar hash;\n\t\t\t\t\t\tvar originalValue;\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\tvar propertiesToTransitionInJs = [];\n\t\t\t\t\t\tvar prop;\n\t\t\t\t\t\tvar suffix;\n\t\t\t\t\t\tvar interpolator;\n\t\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tprop = changedProperties[i];\n\t\t\t\t\t\t\thash = hashPrefix + prop;\n\t\n\t\t\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tstyle[ prefix$1( prop ) ] = to[ prop ];\n\t\n\t\t\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\n\t\t\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t\t\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\t\n\t\t\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\t\tstyle[ prefix$1( prop ) ] = originalValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\t\n\t\t\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\t\t\t\t\t\t\t\tinterpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );\n\t\n\t\t\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t\t\t\t\t\t\t\t\tname: prefix$1( prop ),\n\t\t\t\t\t\t\t\t\tinterpolator: interpolator,\n\t\t\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// javascript transitions\n\t\t\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\t\t\tvar easing;\n\t\n\t\t\t\t\t\t\tif ( typeof options.easing === 'string' ) {\n\t\t\t\t\t\t\t\teasing = t.ractive.easing[ options.easing ];\n\t\n\t\t\t\t\t\t\t\tif ( !easing ) {\n\t\t\t\t\t\t\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n\t\t\t\t\t\t\t\t\teasing = linear$1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( typeof options.easing === 'function' ) {\n\t\t\t\t\t\t\t\teasing = options.easing;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\teasing = linear$1;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tnew Ticker({\n\t\t\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\t\t\teasing: easing,\n\t\t\t\t\t\t\t\tstep: function ( pos ) {\n\t\t\t\t\t\t\t\t\tvar i = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\t\t\tvar prop = propertiesToTransitionInJs[i];\n\t\t\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0 );\n\t\t\t\t}, options.delay || 0 );\n\t\t\t};\n\t\t}\n\t\n\t\tvar createTransitions$1 = createTransitions;\n\t\n\t\tfunction resetStyle ( node, style ) {\n\t\t\tif ( style ) {\n\t\t\t\tnode.setAttribute( 'style', style );\n\t\t\t} else {\n\t\t\t\t// Next line is necessary, to remove empty style attribute!\n\t\t\t\t// See http://stackoverflow.com/a/7167553\n\t\t\t\tnode.getAttribute( 'style' );\n\t\t\t\tnode.removeAttribute( 'style' );\n\t\t\t}\n\t\t}\n\t\n\t\tvar getComputedStyle = win && ( win.getComputedStyle || legacy.getComputedStyle );\n\t\tvar resolved = Promise$1.resolve();\n\t\n\t\tvar names = {\n\t\t\tt0: 'intro-outro',\n\t\t\tt1: 'intro',\n\t\t\tt2: 'outro'\n\t\t};\n\t\n\t\tvar Transition = function Transition ( options ) {\n\t\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\t\tthis.ractive = this.owner.ractive;\n\t\t\tthis.template = options.template;\n\t\t\tthis.parentFragment = options.parentFragment;\n\t\t\tthis.options = options;\n\t\t\tthis.onComplete = [];\n\t\t};\n\t\n\t\tTransition.prototype.animateStyle = function animateStyle ( style, value, options ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( arguments.length === 4 ) {\n\t\t\t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t\t\t}\n\t\n\t\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t\t// that way you'll never get CSS transitionend events\n\t\t\tif ( !visible ) {\n\t\t\t\tthis.setStyle( style, value );\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\n\t\t\tvar to;\n\t\n\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\tto = {};\n\t\t\t\tto[ style ] = value;\n\t\t\t} else {\n\t\t\t\tto = style;\n\t\n\t\t\t\t// shuffle arguments\n\t\t\t\toptions = value;\n\t\t\t}\n\t\n\t\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t\t// callback function that gets called after the animation completes\n\t\n\t\t\t// TODO remove this check in a future version\n\t\t\tif ( !options ) {\n\t\t\t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t\t\t\toptions = this;\n\t\t\t}\n\t\n\t\t\treturn new Promise$1( function ( fulfil ) {\n\t\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\t\tif ( !options.duration ) {\n\t\t\t\t\tthis$1.setStyle( to );\n\t\t\t\t\tfulfil();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Get a list of the properties we're animating\n\t\t\t\tvar propertyNames = Object.keys( to );\n\t\t\t\tvar changedProperties = [];\n\t\n\t\t\t\t// Store the current styles\n\t\t\t\tvar computedStyle = getComputedStyle( this$1.node );\n\t\n\t\t\t\tvar i = propertyNames.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar prop = propertyNames[i];\n\t\t\t\t\tvar current = computedStyle[ prefix$1( prop ) ];\n\t\n\t\t\t\t\tif ( current === '0px' ) current = 0;\n\t\n\t\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\t\tchangedProperties.push( prop );\n\t\n\t\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\t\tthis$1.node.style[ prefix$1( prop ) ] = current;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t\t// will never fire! So we complete early\n\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\tfulfil();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tcreateTransitions$1( this$1, to, options, changedProperties, fulfil );\n\t\t\t});\n\t\t};\n\t\n\t\tTransition.prototype.bind = function bind () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar options = this.options;\n\t\t\tvar type = options.template && options.template.v;\n\t\t\tif ( type ) {\n\t\t\t\tif ( type === 't0' || type === 't1' ) this.element._introTransition = this;\n\t\t\t\tif ( type === 't0' || type === 't2' ) this.element._outroTransition = this;\n\t\t\t\tthis.eventName = names[ type ];\n\t\t\t}\n\t\n\t\t\tvar ractive = this.owner.ractive;\n\t\n\t\t\tif ( options.name ) {\n\t\t\t\tthis.name = options.name;\n\t\t\t} else {\n\t\t\t\tvar name = options.template.f;\n\t\t\t\tif ( typeof name.n === 'string' ) name = name.n;\n\t\n\t\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\t\tvar fragment = new Fragment({\n\t\t\t\t\t\towner: this.owner,\n\t\t\t\t\t\ttemplate: name.n\n\t\t\t\t\t}).bind(); // TODO need a way to capture values without bind()\n\t\n\t\t\t\t\tname = fragment.toString();\n\t\t\t\t\tfragment.unbind();\n\t\n\t\t\t\t\tif ( name === '' ) {\n\t\t\t\t\t\t// empty string okay, just no transition\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.name = name;\n\t\t\t}\n\t\n\t\t\tif ( options.params ) {\n\t\t\t\tthis.params = options.params;\n\t\t\t} else {\n\t\t\t\tif ( options.template.f.a && !options.template.f.a.s ) {\n\t\t\t\t\tthis.params = options.template.f.a;\n\t\t\t\t}\n\t\n\t\t\t\telse if ( options.template.f.d ) {\n\t\t\t\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t\t\t\t// 'dependency thrashing'?\n\t\t\t\t\tvar fragment$1 = new Fragment({\n\t\t\t\t\t\towner: this.owner,\n\t\t\t\t\t\ttemplate: options.template.f.d\n\t\t\t\t\t}).bind();\n\t\n\t\t\t\t\tthis.params = fragment$1.getArgsList();\n\t\t\t\t\tfragment$1.unbind();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( typeof this.name === 'function' ) {\n\t\t\t\tthis._fn = this.name;\n\t\t\t\tthis.name = this._fn.name;\n\t\t\t} else {\n\t\t\t\tthis._fn = findInViewHierarchy( 'transitions', ractive, this.name );\n\t\t\t}\n\t\n\t\t\tif ( !this._fn ) {\n\t\t\t\twarnOnceIfDebug( missingPlugin( this.name, 'transition' ), { ractive: ractive });\n\t\t\t}\n\t\n\t\t\t// TODO: dry up after deprecation is done\n\t\t\tif ( options.template && this.template.f.a && this.template.f.a.s ) {\n\t\t\t\tthis.resolvers = [];\n\t\t\t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n\t\t\t\t\tvar resolver;\n\t\t\t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t\t\t\t\tif ( !model ) {\n\t\t\t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t\t\t\t\t\t\tthis$1.models[i] = model;\n\t\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\t\tmodel.register( this$1 );\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t\t} else model.register( this$1 );\n\t\n\t\t\t\t\treturn model;\n\t\t\t\t});\n\t\t\t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n\t\t\t}\n\t\t};\n\t\n\t\tTransition.prototype.destroyed = function destroyed () {};\n\t\n\t\tTransition.prototype.getStyle = function getStyle ( props ) {\n\t\t\tvar computedStyle = getComputedStyle( this.node );\n\t\n\t\t\tif ( typeof props === 'string' ) {\n\t\t\t\tvar value = computedStyle[ prefix$1( props ) ];\n\t\t\t\treturn value === '0px' ? 0 : value;\n\t\t\t}\n\t\n\t\t\tif ( !isArray( props ) ) {\n\t\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t\t}\n\t\n\t\t\tvar styles = {};\n\t\n\t\t\tvar i = props.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar prop = props[i];\n\t\t\t\tvar value$1 = computedStyle[ prefix$1( prop ) ];\n\t\n\t\t\t\tif ( value$1 === '0px' ) value$1 = 0;\n\t\t\t\tstyles[ prop ] = value$1;\n\t\t\t}\n\t\n\t\t\treturn styles;\n\t\t};\n\t\n\t\tTransition.prototype.processParams = function processParams ( params, defaults ) {\n\t\t\tif ( typeof params === 'number' ) {\n\t\t\t\tparams = { duration: params };\n\t\t\t}\n\t\n\t\t\telse if ( typeof params === 'string' ) {\n\t\t\t\tif ( params === 'slow' ) {\n\t\t\t\t\tparams = { duration: 600 };\n\t\t\t\t} else if ( params === 'fast' ) {\n\t\t\t\t\tparams = { duration: 200 };\n\t\t\t\t} else {\n\t\t\t\t\tparams = { duration: 400 };\n\t\t\t\t}\n\t\t\t} else if ( !params ) {\n\t\t\t\tparams = {};\n\t\t\t}\n\t\n\t\t\treturn extendObj( {}, defaults, params );\n\t\t};\n\t\n\t\tTransition.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\tvar idx = this.models.indexOf( previous );\n\t\t\tif ( !~idx ) return;\n\t\n\t\t\tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n\t\t\tif ( next === previous ) return;\n\t\n\t\t\tprevious.unregister( this );\n\t\t\tthis.models.splice( idx, 1, next );\n\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t\t};\n\t\n\t\tTransition.prototype.registerCompleteHandler = function registerCompleteHandler ( fn ) {\n\t\t\taddToArray( this.onComplete, fn );\n\t\t};\n\t\n\t\tTransition.prototype.render = function render () {};\n\t\n\t\tTransition.prototype.setStyle = function setStyle ( style, value ) {\n\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\tthis.node.style[ prefix$1( style ) ] = value;\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\tvar prop;\n\t\t\t\tfor ( prop in style ) {\n\t\t\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\tthis.node.style[ prefix$1( prop ) ] = style[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tTransition.prototype.start = function start () {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar node = this.node = this.element.node;\n\t\t\tvar originalStyle = node.getAttribute( 'style' );\n\t\n\t\t\tvar completed;\n\t\t\tvar args = this.params;\n\t\n\t\t\t// create t.complete() - we don't want this on the prototype,\n\t\t\t// because we don't want `this` silliness when passing it as\n\t\t\t// an argument\n\t\t\tthis.complete = function ( noReset ) {\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tthis$1.onComplete.forEach( function ( fn ) { return fn(); } );\n\t\t\t\tif ( !noReset && this$1.isIntro ) {\n\t\t\t\t\tresetStyle( node, originalStyle);\n\t\t\t\t}\n\t\n\t\t\t\tthis$1._manager.remove( this$1 );\n\t\n\t\t\t\tcompleted = true;\n\t\t\t};\n\t\n\t\t\t// If the transition function doesn't exist, abort\n\t\t\tif ( !this._fn ) {\n\t\t\t\tthis.complete();\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// get expression args if supplied\n\t\t\tif ( this.argsFn ) {\n\t\t\t\tvar values = this.models.map( function ( model ) {\n\t\t\t\t\tif ( !model ) return undefined;\n\t\n\t\t\t\t\treturn model.get();\n\t\t\t\t});\n\t\t\t\targs = this.argsFn.apply( this.ractive, values );\n\t\t\t}\n\t\n\t\t\tvar promise = this._fn.apply( this.ractive, [ this ].concat( args ) );\n\t\t\tif ( promise ) promise.then( this.complete );\n\t\t};\n\t\n\t\tTransition.prototype.toString = function toString () { return ''; };\n\t\n\t\tTransition.prototype.unbind = function unbind$1 () {\n\t\t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t\t\tif ( !this.element.attributes.unbinding ) {\n\t\t\t\tvar type = this.options && this.options.template && this.options.template.v;\n\t\t\t\tif ( type === 't0' || type === 't1' ) this.element._introTransition = null;\n\t\t\t\tif ( type === 't0' || type === 't2' ) this.element._outroTransition = null;\n\t\t\t}\n\t\t};\n\t\n\t\tTransition.prototype.unregisterCompleteHandler = function unregisterCompleteHandler ( fn ) {\n\t\t\tremoveFromArray( this.onComplete, fn );\n\t\t};\n\t\n\t\tTransition.prototype.unrender = function unrender () {};\n\t\n\t\tTransition.prototype.update = function update () {};\n\t\n\t\tvar elementCache = {};\n\t\n\t\tvar ieBug;\n\t\tvar ieBlacklist;\n\t\n\t\ttry {\n\t\t\tcreateElement( 'table' ).innerHTML = 'foo';\n\t\t} catch ( err ) {\n\t\t\tieBug = true;\n\t\n\t\t\tieBlacklist = {\n\t\t\t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n\t\t\t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n\t\t\t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n\t\t\t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n\t\t\t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n\t\t\t};\n\t\t}\n\t\n\t\tfunction insertHtml ( html, node, docFrag ) {\n\t\t\tvar nodes = [];\n\t\n\t\t\t// render 0 and false\n\t\t\tif ( html == null || html === '' ) return nodes;\n\t\n\t\t\tvar container;\n\t\t\tvar wrapper;\n\t\t\tvar selectedOption;\n\t\n\t\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\n\t\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\telse if ( node.namespaceURI === svg$1 ) {\n\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\t\t}\n\t\n\t\t\telse if ( node.tagName === 'TEXTAREA' ) {\n\t\t\t\tcontainer = createElement( 'div' );\n\t\n\t\t\t\tif ( typeof container.textContent !== 'undefined' ) {\n\t\t\t\t\tcontainer.textContent = html;\n\t\t\t\t} else {\n\t\t\t\t\tcontainer.innerHTML = html;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\tcontainer = element( node.tagName );\n\t\t\t\tcontainer.innerHTML = html;\n\t\n\t\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar child;\n\t\t\twhile ( child = container.firstChild ) {\n\t\t\t\tnodes.push( child );\n\t\t\t\tdocFrag.appendChild( child );\n\t\t\t}\n\t\n\t\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t\t// temporary container <select> causes the remaining ones to\n\t\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t\t// amaze me. You really do\n\t\t\t// ...and now Chrome too\n\t\t\tvar i;\n\t\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\t\ti = nodes.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( nodes[i] !== selectedOption ) {\n\t\t\t\t\t\tnodes[i].selected = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn nodes;\n\t\t}\n\t\n\t\tfunction element ( tagName ) {\n\t\t\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n\t\t}\n\t\n\t\tvar Triple = (function (Mustache) {\n\t\t\tfunction Triple ( options ) {\n\t\t\t\tMustache.call( this, options );\n\t\t\t}\n\t\n\t\t\tTriple.prototype = Object.create( Mustache && Mustache.prototype );\n\t\t\tTriple.prototype.constructor = Triple;\n\t\n\t\t\tTriple.prototype.detach = function detach () {\n\t\t\t\tvar docFrag = createDocumentFragment();\n\t\t\t\tthis.nodes.forEach( function ( node ) { return docFrag.appendChild( node ); } );\n\t\t\t\treturn docFrag;\n\t\t\t};\n\t\n\t\t\tTriple.prototype.find = function find ( selector ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.nodes.length;\n\t\t\t\tvar i;\n\t\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvar node = this$1.nodes[i];\n\t\n\t\t\t\t\tif ( node.nodeType !== 1 ) continue;\n\t\n\t\t\t\t\tif ( matches( node, selector ) ) return node;\n\t\n\t\t\t\t\tvar queryResult = node.querySelector( selector );\n\t\t\t\t\tif ( queryResult ) return queryResult;\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\t\t};\n\t\n\t\t\tTriple.prototype.findAll = function findAll ( selector, query ) {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.nodes.length;\n\t\t\t\tvar i;\n\t\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvar node = this$1.nodes[i];\n\t\n\t\t\t\t\tif ( node.nodeType !== 1 ) continue;\n\t\n\t\t\t\t\tif ( query.test( node ) ) query.add( node );\n\t\n\t\t\t\t\tvar queryAllResult = node.querySelectorAll( selector );\n\t\t\t\t\tif ( queryAllResult ) {\n\t\t\t\t\t\tvar numNodes = queryAllResult.length;\n\t\t\t\t\t\tvar j;\n\t\n\t\t\t\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\t\t\t\tquery.add( queryAllResult[j] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tTriple.prototype.findComponent = function findComponent () {\n\t\t\t\treturn null;\n\t\t\t};\n\t\n\t\t\tTriple.prototype.firstNode = function firstNode () {\n\t\t\t\treturn this.nodes[0];\n\t\t\t};\n\t\n\t\t\tTriple.prototype.render = function render ( target ) {\n\t\t\t\tvar html = this.model ? this.model.get() : '';\n\t\t\t\tthis.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );\n\t\t\t\tthis.rendered = true;\n\t\t\t};\n\t\n\t\t\tTriple.prototype.toString = function toString () {\n\t\t\t\treturn this.model && this.model.get() != null ? decodeCharacterReferences( '' + this.model.get() ) : '';\n\t\t\t};\n\t\n\t\t\tTriple.prototype.unrender = function unrender () {\n\t\t\t\tif ( this.nodes ) this.nodes.forEach( function ( node ) { return detachNode( node ); } );\n\t\t\t\tthis.rendered = false;\n\t\t\t};\n\t\n\t\t\tTriple.prototype.update = function update () {\n\t\t\t\tif ( this.rendered && this.dirty ) {\n\t\t\t\t\tthis.dirty = false;\n\t\n\t\t\t\t\tthis.unrender();\n\t\t\t\t\tvar docFrag = createDocumentFragment();\n\t\t\t\t\tthis.render( docFrag );\n\t\n\t\t\t\t\tvar parentNode = this.parentFragment.findParentNode();\n\t\t\t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\t\n\t\t\t\t\tparentNode.insertBefore( docFrag, anchor );\n\t\t\t\t} else {\n\t\t\t\t\t// make sure to reset the dirty flag even if not rendered\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn Triple;\n\t\t}(Mustache));\n\t\n\t\tvar Yielder = (function (Item) {\n\t\t\tfunction Yielder ( options ) {\n\t\t\t\tItem.call( this, options );\n\t\n\t\t\t\tthis.container = options.parentFragment.ractive;\n\t\t\t\tthis.component = this.container.component;\n\t\n\t\t\t\tthis.containerFragment = options.parentFragment;\n\t\t\t\tthis.parentFragment = this.component.parentFragment;\n\t\n\t\t\t\t// {{yield}} is equivalent to {{yield content}}\n\t\t\t\tthis.name = options.template.n || '';\n\t\t\t}\n\t\n\t\t\tYielder.prototype = Object.create( Item && Item.prototype );\n\t\t\tYielder.prototype.constructor = Yielder;\n\t\n\t\t\tYielder.prototype.bind = function bind () {\n\t\t\t\tvar name = this.name;\n\t\n\t\t\t\t( this.component.yielders[ name ] || ( this.component.yielders[ name ] = [] ) ).push( this );\n\t\n\t\t\t\t// TODO don't parse here\n\t\t\t\tvar template = this.container._inlinePartials[ name || 'content' ];\n\t\n\t\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t\ttemplate = parse( template ).t;\n\t\t\t\t}\n\t\n\t\t\t\tif ( !template ) {\n\t\t\t\t\twarnIfDebug( (\"Could not find template for partial \\\"\" + name + \"\\\"\"), { ractive: this.ractive });\n\t\t\t\t\ttemplate = [];\n\t\t\t\t}\n\t\n\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\towner: this,\n\t\t\t\t\tractive: this.container.parent,\n\t\t\t\t\ttemplate: template\n\t\t\t\t}).bind();\n\t\t\t};\n\t\n\t\t\tYielder.prototype.bubble = function bubble () {\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.containerFragment.bubble();\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tYielder.prototype.detach = function detach () {\n\t\t\t\treturn this.fragment.detach();\n\t\t\t};\n\t\n\t\t\tYielder.prototype.find = function find ( selector ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.findAll = function findAll ( selector, queryResult ) {\n\t\t\t\tthis.fragment.findAll( selector, queryResult );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.findComponent = function findComponent ( name ) {\n\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.findAllComponents = function findAllComponents ( name, queryResult ) {\n\t\t\t\tthis.fragment.findAllComponents( name, queryResult );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.findNextNode = function findNextNode() {\n\t\t\t\treturn this.containerFragment.findNextNode( this );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\t\treturn this.fragment.firstNode( skipParent );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.render = function render ( target, occupants ) {\n\t\t\t\treturn this.fragment.render( target, occupants );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.setTemplate = function setTemplate ( name ) {\n\t\t\t\tvar template = this.parentFragment.ractive.partials[ name ];\n\t\n\t\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t\ttemplate = parse( template ).t;\n\t\t\t\t}\n\t\n\t\t\t\tthis.partialTemplate = template || []; // TODO warn on missing partial\n\t\t\t};\n\t\n\t\t\tYielder.prototype.toString = function toString ( escape ) {\n\t\t\t\treturn this.fragment.toString( escape );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.unbind = function unbind () {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t};\n\t\n\t\t\tYielder.prototype.update = function update () {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.fragment.update();\n\t\t\t};\n\t\n\t\t\treturn Yielder;\n\t\t}(Item));\n\t\n\t\t// finds the component constructor in the registry or view hierarchy registries\n\t\tfunction getComponentConstructor ( ractive, name ) {\n\t\t\tvar instance = findInstance( 'components', ractive, name );\n\t\t\tvar Component;\n\t\n\t\t\tif ( instance ) {\n\t\t\t\tComponent = instance.components[ name ];\n\t\n\t\t\t\t// best test we have for not Ractive.extend\n\t\t\t\tif ( !Component._Parent ) {\n\t\t\t\t\t// function option, execute and store for reset\n\t\t\t\t\tvar fn = Component.bind( instance );\n\t\t\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\t\t\tComponent = fn();\n\t\n\t\t\t\t\tif ( !Component ) {\n\t\t\t\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( typeof Component === 'string' ) {\n\t\t\t\t\t\t// allow string lookup\n\t\t\t\t\t\tComponent = getComponentConstructor( ractive, Component );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tComponent._fn = fn;\n\t\t\t\t\tinstance.components[ name ] = Component;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn Component;\n\t\t}\n\t\n\t\tvar constructors = {};\n\t\tconstructors[ ALIAS ] = Alias;\n\t\tconstructors[ DOCTYPE ] = Doctype;\n\t\tconstructors[ INTERPOLATOR ] = Interpolator;\n\t\tconstructors[ PARTIAL ] = Partial;\n\t\tconstructors[ SECTION ] = Section;\n\t\tconstructors[ TRIPLE ] = Triple;\n\t\tconstructors[ YIELDER ] = Yielder;\n\t\n\t\tconstructors[ ATTRIBUTE ] = Attribute;\n\t\tconstructors[ BINDING_FLAG ] = BindingFlag;\n\t\tconstructors[ DECORATOR ] = Decorator;\n\t\tconstructors[ EVENT ] = EventDirective;\n\t\tconstructors[ TRANSITION ] = Transition;\n\t\n\t\tvar specialElements = {\n\t\t\tdoctype: Doctype,\n\t\t\tform: Form,\n\t\t\tinput: Input,\n\t\t\toption: Option,\n\t\t\tselect: Select,\n\t\t\ttextarea: Textarea\n\t\t};\n\t\n\t\tfunction createItem ( options ) {\n\t\t\tif ( typeof options.template === 'string' ) {\n\t\t\t\treturn new Text( options );\n\t\t\t}\n\t\n\t\t\tif ( options.template.t === ELEMENT ) {\n\t\t\t\t// could be component or element\n\t\t\t\tvar ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );\n\t\t\t\tif ( ComponentConstructor ) {\n\t\t\t\t\treturn new Component( options, ComponentConstructor );\n\t\t\t\t}\n\t\n\t\t\t\tvar tagName = options.template.e.toLowerCase();\n\t\n\t\t\t\tvar ElementConstructor = specialElements[ tagName ] || Element;\n\t\t\t\treturn new ElementConstructor( options );\n\t\t\t}\n\t\n\t\t\tvar Item;\n\t\n\t\t\t// component mappings are a special case of attribute\n\t\t\tif ( options.template.t === ATTRIBUTE ) {\n\t\t\t\tvar el = options.owner;\n\t\t\t\tif ( !el || ( el.type !== COMPONENT && el.type !== ELEMENT ) ) {\n\t\t\t\t\tel = findElement( options.parentFragment );\n\t\t\t\t}\n\t\t\t\toptions.element = el;\n\t\n\t\t\t\tItem = el.type === COMPONENT ? Mapping : Attribute;\n\t\t\t} else {\n\t\t\t\tItem = constructors[ options.template.t ];\n\t\t\t}\n\t\n\t\t\tif ( !Item ) throw new Error( (\"Unrecognised item type \" + (options.template.t)) );\n\t\n\t\t\treturn new Item( options );\n\t\t}\n\t\n\t\t// TODO all this code needs to die\n\t\tfunction processItems ( items, values, guid, counter ) {\n\t\t\tif ( counter === void 0 ) counter = 0;\n\t\n\t\t\treturn items.map( function ( item ) {\n\t\t\t\tif ( item.type === TEXT ) {\n\t\t\t\t\treturn item.template;\n\t\t\t\t}\n\t\n\t\t\t\tif ( item.fragment ) {\n\t\t\t\t\tif ( item.fragment.iterations ) {\n\t\t\t\t\t\treturn item.fragment.iterations.map( function ( fragment ) {\n\t\t\t\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t\t\t\t\t\t}).join( '' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn processItems( item.fragment.items, values, guid, counter );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar placeholderId = \"\" + guid + \"-\" + (counter++);\n\t\t\t\tvar model = item.model || item.newModel;\n\t\n\t\t\t\tvalues[ placeholderId ] = model ?\n\t\t\t\t\tmodel.wrapper ?\n\t\t\t\t\t\tmodel.wrapperValue :\n\t\t\t\t\t\tmodel.get() :\n\t\t\t\t\tundefined;\n\t\n\t\t\t\treturn '${' + placeholderId + '}';\n\t\t\t}).join( '' );\n\t\t}\n\t\n\t\tfunction unrenderAndDestroy$1 ( item ) {\n\t\t\titem.unrender( true );\n\t\t}\n\t\n\t\tvar Fragment = function Fragment ( options ) {\n\t\t\tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\t\n\t\t\tthis.isRoot = !options.owner.parentFragment;\n\t\t\tthis.parent = this.isRoot ? null : this.owner.parentFragment;\n\t\t\tthis.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );\n\t\n\t\t\tthis.componentParent = ( this.isRoot && this.ractive.component ) ? this.ractive.component.parentFragment : null;\n\t\n\t\t\tthis.context = null;\n\t\t\tthis.rendered = false;\n\t\n\t\t\t// encapsulated styles should be inherited until they get applied by an element\n\t\t\tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\t\n\t\t\tthis.resolvers = [];\n\t\n\t\t\tthis.dirty = false;\n\t\t\tthis.dirtyArgs = this.dirtyValue = true; // TODO getArgsList is nonsense - should deprecate legacy directives style\n\t\n\t\t\tthis.template = options.template || [];\n\t\t\tthis.createItems();\n\t\t};\n\t\n\t\tFragment.prototype.bind = function bind$1$$ ( context ) {\n\t\t\tthis.context = context;\n\t\t\tthis.items.forEach( bind$1 );\n\t\t\tthis.bound = true;\n\t\n\t\t\t// in rare cases, a forced resolution (or similar) will cause the\n\t\t\t// fragment to be dirty before it's even finished binding. In those\n\t\t\t// cases we update immediately\n\t\t\tif ( this.dirty ) this.update();\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tFragment.prototype.bubble = function bubble () {\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\n\t\t\t\tif ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?\n\t\t\t\t\tif ( this.ractive.component ) {\n\t\t\t\t\t\tthis.ractive.component.bubble();\n\t\t\t\t\t} else if ( this.bound ) {\n\t\t\t\t\t\trunloop.addFragment( this );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.owner.bubble();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tFragment.prototype.createItems = function createItems () {\n\t\t\t// this is a hot code path\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar max = this.template.length;\n\t\t\tthis.items = [];\n\t\t\tfor ( var i = 0; i < max; i++ ) {\n\t\t\t\tthis$1.items[i] = createItem({ parentFragment: this$1, template: this$1.template[i], index: i });\n\t\t\t}\n\t\t};\n\t\n\t\tFragment.prototype.destroyed = function destroyed () {\n\t\t\tthis.items.forEach( function ( i ) { return i.destroyed(); } );\n\t\t};\n\t\n\t\tFragment.prototype.detach = function detach () {\n\t\t\tvar docFrag = createDocumentFragment();\n\t\t\tthis.items.forEach( function ( item ) { return docFrag.appendChild( item.detach() ); } );\n\t\t\treturn docFrag;\n\t\t};\n\t\n\t\tFragment.prototype.find = function find ( selector ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.items.length;\n\t\t\tvar i;\n\t\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar found = this$1.items[i].find( selector );\n\t\t\t\tif ( found ) return found;\n\t\t\t}\n\t\t};\n\t\n\t\tFragment.prototype.findAll = function findAll ( selector, query ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.items ) {\n\t\t\t\tvar len = this.items.length;\n\t\t\t\tvar i;\n\t\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvar item = this$1.items[i];\n\t\n\t\t\t\t\tif ( item.findAll ) {\n\t\t\t\t\t\titem.findAll( selector, query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn query;\n\t\t};\n\t\n\t\tFragment.prototype.findComponent = function findComponent ( name ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar len = this.items.length;\n\t\t\tvar i;\n\t\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar found = this$1.items[i].findComponent( name );\n\t\t\t\tif ( found ) return found;\n\t\t\t}\n\t\t};\n\t\n\t\tFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( this.items ) {\n\t\t\t\tvar len = this.items.length;\n\t\t\t\tvar i;\n\t\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvar item = this$1.items[i];\n\t\n\t\t\t\t\tif ( item.findAllComponents ) {\n\t\t\t\t\t\titem.findAllComponents( name, query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn query;\n\t\t};\n\t\n\t\tFragment.prototype.findContext = function findContext () {\n\t\t\tvar fragment = this;\n\t\t\twhile ( fragment && !fragment.context ) fragment = fragment.parent;\n\t\t\tif ( !fragment ) return this.ractive.viewmodel;\n\t\t\telse return fragment.context;\n\t\t};\n\t\n\t\tFragment.prototype.findNextNode = function findNextNode ( item ) {\n\t\t\t// search for the next node going forward\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tif ( item ) {\n\t\t\t\tfor ( var i = item.index + 1; i < this$1.items.length; i++ ) {\n\t\t\t\t\tif ( !this$1.items[ i ] ) continue;\n\t\n\t\t\t\t\tvar node = this$1.items[ i ].firstNode( true );\n\t\t\t\t\tif ( node ) return node;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// if this is the root fragment, and there are no more items,\n\t\t\t// it means we're at the end...\n\t\t\tif ( this.isRoot ) {\n\t\t\t\tif ( this.ractive.component ) {\n\t\t\t\t\treturn this.ractive.component.parentFragment.findNextNode( this.ractive.component );\n\t\t\t\t}\n\t\n\t\t\t\t// TODO possible edge case with other content\n\t\t\t\t// appended to this.ractive.el?\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tif ( this.parent ) return this.owner.findNextNode( this ); // the argument is in case the parent is a RepeatedFragment\n\t\t};\n\t\n\t\tFragment.prototype.findParentNode = function findParentNode () {\n\t\t\tvar fragment = this;\n\t\n\t\t\tdo {\n\t\t\t\tif ( fragment.owner.type === ELEMENT ) {\n\t\t\t\t\treturn fragment.owner.node;\n\t\t\t\t}\n\t\n\t\t\t\tif ( fragment.isRoot && !fragment.ractive.component ) { // TODO encapsulate check\n\t\t\t\t\treturn fragment.ractive.el;\n\t\t\t\t}\n\t\n\t\t\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\t\t\tfragment = fragment.owner.containerFragment;\n\t\t\t\t} else {\n\t\t\t\t\tfragment = fragment.componentParent || fragment.parent; // TODO ugh\n\t\t\t\t}\n\t\t\t} while ( fragment );\n\t\n\t\t\tthrow new Error( 'Could not find parent node' ); // TODO link to issue tracker\n\t\t};\n\t\n\t\tFragment.prototype.findRepeatingFragment = function findRepeatingFragment () {\n\t\t\tvar fragment = this;\n\t\t\t// TODO better check than fragment.parent.iterations\n\t\t\twhile ( ( fragment.parent || fragment.componentParent ) && !fragment.isIteration ) {\n\t\t\t\tfragment = fragment.parent || fragment.componentParent;\n\t\t\t}\n\t\n\t\t\treturn fragment;\n\t\t};\n\t\n\t\tFragment.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\tvar this$1 = this;\n\t\n\t\t\t\tvar node;\n\t\t\tfor ( var i = 0; i < this$1.items.length; i++ ) {\n\t\t\t\tnode = this$1.items[i].firstNode( true );\n\t\n\t\t\t\tif ( node ) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( skipParent ) return null;\n\t\n\t\t\treturn this.parent.findNextNode( this.owner );\n\t\t};\n\t\n\t\t// TODO ideally, this would be deprecated in favour of an\n\t\t// expression-like approach\n\t\tFragment.prototype.getArgsList = function getArgsList () {\n\t\t\tif ( this.dirtyArgs ) {\n\t\t\t\tvar values = {};\n\t\t\t\tvar source = processItems( this.items, values, this.ractive._guid );\n\t\t\t\tvar parsed = parseJSON( '[' + source + ']', values );\n\t\n\t\t\t\tthis.argsList = parsed ?\n\t\t\t\t\tparsed.value :\n\t\t\t\t\t[ this.toString() ];\n\t\n\t\t\t\tthis.dirtyArgs = false;\n\t\t\t}\n\t\n\t\t\treturn this.argsList;\n\t\t};\n\t\n\t\tFragment.prototype.rebinding = function rebinding ( next ) {\n\t\t\tthis.context = next;\n\t\t};\n\t\n\t\tFragment.prototype.render = function render ( target, occupants ) {\n\t\t\tif ( this.rendered ) throw new Error( 'Fragment is already rendered!' );\n\t\t\tthis.rendered = true;\n\t\n\t\t\tthis.items.forEach( function ( item ) { return item.render( target, occupants ); } );\n\t\t};\n\t\n\t\tFragment.prototype.resetTemplate = function resetTemplate ( template ) {\n\t\t\tvar wasBound = this.bound;\n\t\t\tvar wasRendered = this.rendered;\n\t\n\t\t\t// TODO ensure transitions are disabled globally during reset\n\t\n\t\t\tif ( wasBound ) {\n\t\t\t\tif ( wasRendered ) this.unrender( true );\n\t\t\t\tthis.unbind();\n\t\t\t}\n\t\n\t\t\tthis.template = template;\n\t\t\tthis.createItems();\n\t\n\t\t\tif ( wasBound ) {\n\t\t\t\tthis.bind( this.context );\n\t\n\t\t\t\tif ( wasRendered ) {\n\t\t\t\t\tvar parentNode = this.findParentNode();\n\t\t\t\t\tvar anchor = this.findNextNode();\n\t\n\t\t\t\t\tif ( anchor ) {\n\t\t\t\t\t\tvar docFrag = createDocumentFragment();\n\t\t\t\t\t\tthis.render( docFrag );\n\t\t\t\t\t\tparentNode.insertBefore( docFrag, anchor );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.render( parentNode );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tFragment.prototype.resolve = function resolve ( template, callback ) {\n\t\t\tif ( !this.context && this.parent.resolve ) {\n\t\t\t\treturn this.parent.resolve( template, callback );\n\t\t\t}\n\t\n\t\t\tvar resolver = new ReferenceResolver( this, template, callback );\n\t\t\tthis.resolvers.push( resolver );\n\t\n\t\t\treturn resolver; // so we can e.g. force resolution\n\t\t};\n\t\n\t\tFragment.prototype.shuffled = function shuffled () {\n\t\t\tthis.items.forEach( function ( i ) { return i.shuffled(); } );\n\t\t};\n\t\n\t\tFragment.prototype.toHtml = function toHtml () {\n\t\t\treturn this.toString();\n\t\t};\n\t\n\t\tFragment.prototype.toString = function toString$1$$ ( escape ) {\n\t\t\treturn this.items.map( escape ? toEscapedString : toString$1 ).join( '' );\n\t\t};\n\t\n\t\tFragment.prototype.unbind = function unbind$1 () {\n\t\t\tthis.items.forEach( unbind );\n\t\t\tthis.bound = false;\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\tFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t\t\tthis.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );\n\t\t\tthis.rendered = false;\n\t\t};\n\t\n\t\tFragment.prototype.update = function update$1 () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tif ( !this.updating ) {\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tthis.updating = true;\n\t\t\t\t\tthis.items.forEach( update );\n\t\t\t\t\tthis.updating = false;\n\t\t\t\t} else if ( this.isRoot ) {\n\t\t\t\t\trunloop.addFragmentToRoot( this );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tFragment.prototype.valueOf = function valueOf () {\n\t\t\tif ( this.items.length === 1 ) {\n\t\t\t\treturn this.items[0].valueOf();\n\t\t\t}\n\t\n\t\t\tif ( this.dirtyValue ) {\n\t\t\t\tvar values = {};\n\t\t\t\tvar source = processItems( this.items, values, this.ractive._guid );\n\t\t\t\tvar parsed = parseJSON( source, values );\n\t\n\t\t\t\tthis.value = parsed ?\n\t\t\t\t\tparsed.value :\n\t\t\t\t\tthis.toString();\n\t\n\t\t\t\tthis.dirtyValue = false;\n\t\t\t}\n\t\n\t\t\treturn this.value;\n\t\t};\n\t\n\t\t// TODO should resetTemplate be asynchronous? i.e. should it be a case\n\t\t// of outro, update template, intro? I reckon probably not, since that\n\t\t// could be achieved with unrender-resetTemplate-render. Also, it should\n\t\t// conceptually be similar to resetPartial, which couldn't be async\n\t\n\t\tfunction Ractive$resetTemplate ( template ) {\n\t\t\ttemplateConfigurator.init( null, this, { template: template });\n\t\n\t\t\tvar transitionsEnabled = this.transitionsEnabled;\n\t\t\tthis.transitionsEnabled = false;\n\t\n\t\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t\t// flag, otherwise it will assume by default that a parent node\n\t\t\t// will be detached, and therefore it doesn't need to bother\n\t\t\t// detaching its own nodes\n\t\t\tvar component = this.component;\n\t\t\tif ( component ) component.shouldDestroy = true;\n\t\t\tthis.unrender();\n\t\t\tif ( component ) component.shouldDestroy = false;\n\t\n\t\t\t// remove existing fragment and create new one\n\t\t\tthis.fragment.unbind().unrender( true );\n\t\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t});\n\t\n\t\t\tvar docFrag = createDocumentFragment();\n\t\t\tthis.fragment.bind( this.viewmodel ).render( docFrag );\n\t\n\t\t\t// if this is a component, its el may not be valid, so find a\n\t\t\t// target based on the component container\n\t\t\tif ( component ) {\n\t\t\t\tthis.fragment.findParentNode().insertBefore( docFrag, component.findNextNode() );\n\t\t\t} else {\n\t\t\t\tthis.el.insertBefore( docFrag, this.anchor );\n\t\t\t}\n\t\n\t\t\tthis.transitionsEnabled = transitionsEnabled;\n\t\t}\n\t\n\t\tvar reverse$1 = makeArrayMethod( 'reverse' ).path;\n\t\n\t\tfunction Ractive$set ( keypath, value ) {\n\t\t\tvar ractive = this;\n\t\n\t\t\treturn set( ractive, build( ractive, keypath, value ) );\n\t\t}\n\t\n\t\tvar shift$1 = makeArrayMethod( 'shift' ).path;\n\t\n\t\tvar sort$1 = makeArrayMethod( 'sort' ).path;\n\t\n\t\tvar splice$1 = makeArrayMethod( 'splice' ).path;\n\t\n\t\tfunction Ractive$subtract ( keypath, d ) {\n\t\t\treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n\t\t}\n\t\n\t\tvar teardownHook$1 = new Hook( 'teardown' );\n\t\n\t\t// Teardown. This goes through the root fragment and all its children, removing observers\n\t\t// and generally cleaning up after itself\n\t\n\t\tfunction Ractive$teardown () {\n\t\t\tif ( this.torndown ) {\n\t\t\t\twarnIfDebug( 'ractive.teardown() was called on a Ractive instance that was already torn down' );\n\t\t\t\treturn Promise$1.resolve();\n\t\t\t}\n\t\n\t\t\tthis.torndown = true;\n\t\t\tthis.fragment.unbind();\n\t\t\tthis.viewmodel.teardown();\n\t\n\t\t\tthis._observers.forEach( cancel );\n\t\n\t\t\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t}\n\t\n\t\t\tthis.shouldDestroy = true;\n\t\t\tvar promise = ( this.fragment.rendered ? this.unrender() : Promise$1.resolve() );\n\t\n\t\t\tteardownHook$1.fire( this );\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tfunction Ractive$toggle ( keypath ) {\n\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\tthrow new TypeError( badArguments );\n\t\t\t}\n\t\n\t\t\treturn set( this, gather( this, keypath ).map( function ( m ) { return [ m, !m.get() ]; } ) );\n\t\t}\n\t\n\t\tfunction Ractive$toCSS() {\n\t\t\tvar cssIds = [ this.cssId ].concat( this.findAllComponents().map( function ( c ) { return c.cssId; } ) );\n\t\t\tvar uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));\n\t\t\treturn getCSS( uniqueCssIds );\n\t\t}\n\t\n\t\tfunction Ractive$toHTML () {\n\t\t\treturn this.fragment.toString( true );\n\t\t}\n\t\n\t\tfunction toText () {\n\t\t\treturn this.fragment.toString( false );\n\t\t}\n\t\n\t\tfunction Ractive$transition ( name, node, params ) {\n\t\n\t\t\tif ( node instanceof HTMLElement ) {\n\t\t\t\t// good to go\n\t\t\t}\n\t\t\telse if ( isObject( node ) ) {\n\t\t\t\t// omitted, use event node\n\t\t\t\tparams = node;\n\t\t\t}\n\t\n\t\t\t// if we allow query selector, then it won't work\n\t\t\t// simple params like \"fast\"\n\t\n\t\t\t// else if ( typeof node === 'string' ) {\n\t\t\t// \t// query selector\n\t\t\t// \tnode = this.find( node )\n\t\t\t// }\n\t\n\t\t\tnode = node || this.event.node;\n\t\n\t\t\tif ( !node || !node._ractive ) {\n\t\t\t\tfatal( (\"No node was supplied for transition \" + name) );\n\t\t\t}\n\t\n\t\t\tparams = params || {};\n\t\t\tvar owner = node._ractive.proxy;\n\t\t\tvar transition = new Transition({ owner: owner, parentFragment: owner.parentFragment, name: name, params: params });\n\t\t\ttransition.bind();\n\t\n\t\t\tvar promise = runloop.start( this, true );\n\t\t\trunloop.registerTransition( transition );\n\t\t\trunloop.end();\n\t\n\t\t\tpromise.then( function () { return transition.unbind(); } );\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tfunction unlink$1( here ) {\n\t\t\tvar promise = runloop.start();\n\t\t\tthis.viewmodel.joinAll( splitKeypathI( here ), { lastLink: false } ).unlink();\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tvar unrenderHook$1 = new Hook( 'unrender' );\n\t\n\t\tfunction Ractive$unrender () {\n\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t\t\t\treturn Promise$1.resolve();\n\t\t\t}\n\t\n\t\t\tvar promise = runloop.start( this, true );\n\t\n\t\t\t// If this is a component, and the component isn't marked for destruction,\n\t\t\t// don't detach nodes from the DOM unnecessarily\n\t\t\tvar shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\n\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\n\t\t\tunrenderHook$1.fire( this );\n\t\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tvar unshift$1 = makeArrayMethod( 'unshift' ).path;\n\t\n\t\tfunction Ractive$updateModel ( keypath, cascade ) {\n\t\t\tvar promise = runloop.start( this, true );\n\t\n\t\t\tif ( !keypath ) {\n\t\t\t\tthis.viewmodel.updateFromBindings( true );\n\t\t\t} else {\n\t\t\t\tthis.viewmodel.joinAll( splitKeypathI( keypath ) ).updateFromBindings( cascade !== false );\n\t\t\t}\n\t\n\t\t\trunloop.end();\n\t\n\t\t\treturn promise;\n\t\t}\n\t\n\t\tvar proto = {\n\t\t\tadd: Ractive$add,\n\t\t\tanimate: Ractive$animate,\n\t\t\tdetach: Ractive$detach,\n\t\t\tfind: Ractive$find,\n\t\t\tfindAll: Ractive$findAll,\n\t\t\tfindAllComponents: Ractive$findAllComponents,\n\t\t\tfindComponent: Ractive$findComponent,\n\t\t\tfindContainer: Ractive$findContainer,\n\t\t\tfindParent: Ractive$findParent,\n\t\t\tfire: Ractive$fire,\n\t\t\tget: Ractive$get,\n\t\t\tgetNodeInfo: getNodeInfo,\n\t\t\tinsert: Ractive$insert,\n\t\t\tlink: link$1,\n\t\t\tmerge: thisRactive$merge,\n\t\t\tobserve: observe,\n\t\t\tobserveList: observeList,\n\t\t\tobserveOnce: observeOnce,\n\t\t\t// TODO reinstate these\n\t\t\t// observeListOnce,\n\t\t\toff: Ractive$off,\n\t\t\ton: Ractive$on,\n\t\t\tonce: Ractive$once,\n\t\t\tpop: pop$1,\n\t\t\tpush: push$1,\n\t\t\trender: Ractive$render,\n\t\t\treset: Ractive$reset,\n\t\t\tresetPartial: resetPartial,\n\t\t\tresetTemplate: Ractive$resetTemplate,\n\t\t\treverse: reverse$1,\n\t\t\tset: Ractive$set,\n\t\t\tshift: shift$1,\n\t\t\tsort: sort$1,\n\t\t\tsplice: splice$1,\n\t\t\tsubtract: Ractive$subtract,\n\t\t\tteardown: Ractive$teardown,\n\t\t\ttoggle: Ractive$toggle,\n\t\t\ttoCSS: Ractive$toCSS,\n\t\t\ttoCss: Ractive$toCSS,\n\t\t\ttoHTML: Ractive$toHTML,\n\t\t\ttoHtml: Ractive$toHTML,\n\t\t\ttoText: toText,\n\t\t\ttransition: Ractive$transition,\n\t\t\tunlink: unlink$1,\n\t\t\tunrender: Ractive$unrender,\n\t\t\tunshift: unshift$1,\n\t\t\tupdate: Ractive$update,\n\t\t\tupdateModel: Ractive$updateModel\n\t\t};\n\t\n\t\tfunction wrap$1 ( method, superMethod, force ) {\n\t\n\t\t\tif ( force || needsSuper( method, superMethod ) )  {\n\t\n\t\t\t\treturn function () {\n\t\n\t\t\t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\t\n\t\t\t\t\tthis._super = superMethod;\n\t\n\t\t\t\t\tresult = method.apply( this, arguments );\n\t\n\t\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\t\tthis._super = _super;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\telse {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction needsSuper ( method, superMethod ) {\n\t\t\treturn typeof superMethod === 'function' && /_super/.test( method );\n\t\t}\n\t\n\t\tfunction unwrap ( Child ) {\n\t\t\tvar options = {};\n\t\n\t\t\twhile ( Child ) {\n\t\t\t\taddRegistries( Child, options );\n\t\t\t\taddOtherOptions( Child, options );\n\t\n\t\t\t\tif ( Child._Parent !== Ractive ) {\n\t\t\t\t\tChild = Child._Parent;\n\t\t\t\t} else {\n\t\t\t\t\tChild = false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn options;\n\t\t}\n\t\n\t\tfunction addRegistries ( Child, options ) {\n\t\t\tregistries.forEach( function ( r ) {\n\t\t\t\taddRegistry(\n\t\t\t\t\tr.useDefaults ? Child.prototype : Child,\n\t\t\t\t\toptions, r.name );\n\t\t\t});\n\t\t}\n\t\n\t\tfunction addRegistry ( target, options, name ) {\n\t\t\tvar registry, keys = Object.keys( target[ name ] );\n\t\n\t\t\tif ( !keys.length ) { return; }\n\t\n\t\t\tif ( !( registry = options[ name ] ) ) {\n\t\t\t\tregistry = options[ name ] = {};\n\t\t\t}\n\t\n\t\t\tkeys\n\t\t\t\t.filter( function ( key ) { return !( key in registry ); } )\n\t\t\t\t.forEach( function ( key ) { return registry[ key ] = target[ name ][ key ]; } );\n\t\t}\n\t\n\t\tfunction addOtherOptions ( Child, options ) {\n\t\t\tObject.keys( Child.prototype ).forEach( function ( key ) {\n\t\t\t\tif ( key === 'computed' ) { return; }\n\t\n\t\t\t\tvar value = Child.prototype[ key ];\n\t\n\t\t\t\tif ( !( key in options ) ) {\n\t\t\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t\t\t}\n\t\n\t\t\t\t// is it a wrapped function?\n\t\t\t\telse if ( typeof options[ key ] === 'function'\n\t\t\t\t\t\t&& typeof value === 'function'\n\t\t\t\t\t\t&& options[ key ]._method ) {\n\t\n\t\t\t\t\tvar result, needsSuper = value._method;\n\t\n\t\t\t\t\tif ( needsSuper ) { value = value._method; }\n\t\n\t\t\t\t\t// rewrap bound directly to parent fn\n\t\t\t\t\tresult = wrap$1( options[ key ]._method, value );\n\t\n\t\t\t\t\tif ( needsSuper ) { result._method = result; }\n\t\n\t\t\t\t\toptions[ key ] = result;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction extend () {\n\t\t\tvar options = [], len = arguments.length;\n\t\t\twhile ( len-- ) options[ len ] = arguments[ len ];\n\t\n\t\t\tif( !options.length ) {\n\t\t\t\treturn extendOne( this );\n\t\t\t} else {\n\t\t\t\treturn options.reduce( extendOne, this );\n\t\t\t}\n\t\t}\n\t\n\t\tfunction extendOne ( Parent, options ) {\n\t\t\tif ( options === void 0 ) options = {};\n\t\n\t\t\tvar Child, proto;\n\t\n\t\t\t// if we're extending with another Ractive instance...\n\t\t\t//\n\t\t\t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t\t\t//   var Spiderman = Human.extend( Spider );\n\t\t\t//\n\t\t\t// ...inherit prototype methods and default options as well\n\t\t\tif ( options.prototype instanceof Ractive ) {\n\t\t\t\toptions = unwrap( options );\n\t\t\t}\n\t\n\t\t\tChild = function ( options ) {\n\t\t\t\tif ( !( this instanceof Child ) ) return new Child( options );\n\t\n\t\t\t\tconstruct( this, options || {} );\n\t\t\t\tinitialise( this, options || {}, {} );\n\t\t\t};\n\t\n\t\t\tproto = create( Parent.prototype );\n\t\t\tproto.constructor = Child;\n\t\n\t\t\t// Static properties\n\t\t\tdefineProperties( Child, {\n\t\t\t\t// alias prototype as defaults\n\t\t\t\tdefaults: { value: proto },\n\t\n\t\t\t\t// extendable\n\t\t\t\textend: { value: extend, writable: true, configurable: true },\n\t\n\t\t\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t\t\t_Parent: { value: Parent }\n\t\t\t});\n\t\n\t\t\t// extend configuration\n\t\t\tconfig.extend( Parent, proto, options );\n\t\n\t\t\tdataConfigurator.extend( Parent, proto, options );\n\t\n\t\t\tif ( options.computed ) {\n\t\t\t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n\t\t\t}\n\t\n\t\t\tChild.prototype = proto;\n\t\n\t\t\treturn Child;\n\t\t}\n\t\n\t\tfunction joinKeys () {\n\t\t\tvar keys = [], len = arguments.length;\n\t\t\twhile ( len-- ) keys[ len ] = arguments[ len ];\n\t\n\t\t\treturn keys.map( escapeKey ).join( '.' );\n\t\t}\n\t\n\t\tfunction splitKeypath ( keypath ) {\n\t\t\treturn splitKeypathI( keypath ).map( unescapeKey );\n\t\t}\n\t\n\t\t// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n\t\t// older browsers, these are made available via a shim - here, we do a quick\n\t\t// pre-flight check to make sure that either a) we're not in a shit browser,\n\t\t// or b) we're using a Ractive-legacy.js build\n\t\tvar FUNCTION = 'function';\n\t\n\t\tif (\n\t\t\ttypeof Date.now !== FUNCTION                 ||\n\t\t\ttypeof String.prototype.trim !== FUNCTION    ||\n\t\t\ttypeof Object.keys !== FUNCTION              ||\n\t\t\ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\t\t\ttypeof Array.prototype.forEach !== FUNCTION  ||\n\t\t\ttypeof Array.prototype.map !== FUNCTION      ||\n\t\t\ttypeof Array.prototype.filter !== FUNCTION   ||\n\t\t\t( win && typeof win.addEventListener !== FUNCTION )\n\t\t) {\n\t\t\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n\t\t}\n\t\n\t\tfunction Ractive ( options ) {\n\t\t\tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\t\n\t\t\tconstruct( this, options || {} );\n\t\t\tinitialise( this, options || {}, {} );\n\t\t}\n\t\n\t\textendObj( Ractive.prototype, proto, defaults );\n\t\tRactive.prototype.constructor = Ractive;\n\t\n\t\t// alias prototype as `defaults`\n\t\tRactive.defaults = Ractive.prototype;\n\t\n\t\t// static properties\n\t\tdefineProperties( Ractive, {\n\t\n\t\t\t// debug flag\n\t\t\tDEBUG:          { writable: true, value: true },\n\t\t\tDEBUG_PROMISES: { writable: true, value: true },\n\t\n\t\t\t// static methods:\n\t\t\textend:         { value: extend },\n\t\t\tescapeKey:      { value: escapeKey },\n\t\t\tgetNodeInfo:    { value: staticInfo },\n\t\t\tjoinKeys:       { value: joinKeys },\n\t\t\tparse:          { value: parse },\n\t\t\tsplitKeypath:   { value: splitKeypath },\n\t\t\tunescapeKey:    { value: unescapeKey },\n\t\t\tgetCSS:         { value: getCSS },\n\t\n\t\t\t// namespaced constructors\n\t\t\tPromise:        { value: Promise$1 },\n\t\n\t\t\t// support\n\t\t\tenhance:        { writable: true, value: false },\n\t\t\tsvg:            { value: svg },\n\t\t\tmagic:          { value: magicSupported },\n\t\n\t\t\t// version\n\t\t\tVERSION:        { value: '0.8.9' },\n\t\n\t\t\t// plugins\n\t\t\tadaptors:       { writable: true, value: {} },\n\t\t\tcomponents:     { writable: true, value: {} },\n\t\t\tdecorators:     { writable: true, value: {} },\n\t\t\teasing:         { writable: true, value: easing },\n\t\t\tevents:         { writable: true, value: {} },\n\t\t\tinterpolators:  { writable: true, value: interpolators },\n\t\t\tpartials:       { writable: true, value: {} },\n\t\t\ttransitions:    { writable: true, value: {} }\n\t\t});\n\t\n\t\treturn Ractive;\n\t\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(9);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../node_modules/sass-loader/index.js!./main.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../node_modules/sass-loader/index.js!./main.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _jquery = __webpack_require__(12);\n\t\n\tvar _jquery2 = _interopRequireDefault(_jquery);\n\t\n\tvar _ractive = __webpack_require__(1);\n\t\n\tvar _ractive2 = _interopRequireDefault(_ractive);\n\t\n\tvar _main = __webpack_require__(4);\n\t\n\tvar _main2 = _interopRequireDefault(_main);\n\t\n\tvar _main3 = __webpack_require__(13);\n\t\n\tvar _main4 = _interopRequireDefault(_main3);\n\t\n\tvar _sortableDragList = __webpack_require__(7);\n\t\n\tvar _sortableDragList2 = _interopRequireDefault(_sortableDragList);\n\t\n\tvar _sortableDragItem = __webpack_require__(6);\n\t\n\tvar _sortableDragItem2 = _interopRequireDefault(_sortableDragItem);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Main = _ractive2.default.extend({\n\t    template: _main4.default,\n\t    modifyArrays: true,\n\t    components: {\n\t        SortableDragList: _sortableDragList2.default,\n\t        SortableDragItem: _sortableDragItem2.default\n\t    },\n\t    data: function data() {\n\t        return {\n\t            css: _main2.default,\n\t            list1: [{ key: 0, value: 'One' }, { key: 1, value: 'Two' }, { key: 2, value: 'Three' }, { key: 3, value: 'Four' }, { key: 4, value: 'Five' }, { key: 5, value: 'Six' }, { key: 6, value: 'Seven' }, { key: 7, value: 'Eight' }, { key: 8, value: 'Nine' }, { key: 9, value: 'Ten' }],\n\t            list2: [],\n\t            currentDrag: null,\n\t            currentDrop: null,\n\t            currentHolder: null,\n\t            currentPos: null,\n\t            currentInsertPoint: null\n\t        };\n\t    },\n\t\n\t    oninit: function oninit() {\n\t        this.on('SortableDragItem.dragStart', this.handleSortableDragStart);\n\t        this.on('SortableDragItem.dragEnd', this.handleSortableDragEnd);\n\t        this.on('SortableDragList.dragEnter', this.handleSortableDragEnter);\n\t        this.on('SortableDragList.dragOver', this.handleSortableDragOver);\n\t        this.on('SortableDragList.dragLeave', this.handleSortableDragLeave);\n\t        this.on('SortableDragList.dragDrop', this.handleSortableDragDrop);\n\t    },\n\t\n\t    handleSortableDragStart: function handleSortableDragStart(ev) {\n\t        this.set('currentDrag', ev.component);\n\t    },\n\t\n\t    handleSortableDragEnd: function handleSortableDragEnd(ev) {\n\t        this.set('currentDrag', null);\n\t        this.set('currentHolder', null);\n\t        this.set('currentInsertPoint', null);\n\t    },\n\t\n\t    handleSortableDragEnter: function handleSortableDragEnter(ev) {\n\t        var _this = this;\n\t\n\t        window.setTimeout(function () {\n\t            _this.set('currentDrop', ev.component);\n\t            if (!_this.get('currentHolder')) _this.set('currentHolder', ev.component);\n\t        }.bind(this), 1);\n\t    },\n\t\n\t    handleSortableDragOver: function handleSortableDragOver(ev) {\n\t        var pos = { x: ev.original.pageX, y: ev.original.pageY };\n\t        this.set('currentPos', pos);\n\t\n\t        if (!this.get('currentDrop')) {\n\t            this.set('currentInsertionPoint', null);\n\t            return;\n\t        }\n\t        var destComp = this.getDropBeforeComp();\n\t        this.set('currentInsertPoint', destComp ? destComp.get('key') : this.get('currentDrop').get('key'));\n\t    },\n\t\n\t    handleSortableDragLeave: function handleSortableDragLeave(ev) {\n\t        this.set('currentDrop', null);\n\t    },\n\t\n\t    handleSortableDragDrop: function handleSortableDragDrop(ev) {\n\t        var _this2 = this;\n\t\n\t        ev.original.stopPropagation();\n\t        this.set('currentDrop', ev.component);\n\t\n\t        var srcComp = this.get('currentDrag');\n\t        var destComp = this.getDropBeforeComp();\n\t\n\t        if (srcComp != destComp) {\n\t            (function () {\n\t                var srcKey = srcComp.get('key');\n\t                var srcData = _this2.get(_this2.get('currentHolder').get('key'));\n\t                var srcObj = srcData.filter(function (obj) {\n\t                    return obj.key == srcKey;\n\t                })[0];\n\t                srcData.splice(srcData.indexOf(srcObj), 1);\n\t                var destData = _this2.get(_this2.get('currentDrop').get('key'));\n\t                var destKey = destComp ? destComp.get('key') : null;\n\t                var dest = destData.filter(function (obj) {\n\t                    return obj.key === destKey;\n\t                });\n\t                var destInd = dest.length ? destData.indexOf(dest[0]) : destData.length;\n\t                destData.splice(destInd, 0, srcObj);\n\t            })();\n\t        }\n\t        this.set('currentHolder', null);\n\t        this.set('currentInsertPoint', null);\n\t    },\n\t\n\t    getDropBeforeComp: function getDropBeforeComp() {\n\t        var dropPos = this.get('currentPos');\n\t        if (!this.get('currentDrop')) return null;\n\t\n\t        return this.get('currentDrop').findAllComponents('SortableDragItem').reduce(function (aggr, comp) {\n\t            var el = (0, _jquery2.default)(comp.find('*'));\n\t            return !aggr && el.offset().top + el.outerHeight() * 0.75 > dropPos.y ? comp : aggr;\n\t        }, null);\n\t    }\n\t});\n\t\n\texports.default = Main;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _ractive = __webpack_require__(1);\n\t\n\tvar _ractive2 = _interopRequireDefault(_ractive);\n\t\n\tvar _sortableDragItem = __webpack_require__(16);\n\t\n\tvar _sortableDragItem2 = _interopRequireDefault(_sortableDragItem);\n\t\n\tvar _sortableDragItem3 = __webpack_require__(14);\n\t\n\tvar _sortableDragItem4 = _interopRequireDefault(_sortableDragItem3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar SortableDragItem = _ractive2.default.extend({\n\t    template: _sortableDragItem4.default,\n\t    data: function data() {\n\t        return {\n\t            css: _sortableDragItem2.default,\n\t            isDragging: false\n\t        };\n\t    },\n\t\n\t    oninit: function oninit() {\n\t        this.on('dragStart', this.handleDragStart);\n\t        this.on('dragEnd', this.handleDragEnd);\n\t    },\n\t\n\t    handleDragStart: function handleDragStart(ev) {\n\t        this.set('isDragging', true);\n\t    },\n\t\n\t    handleDragEnd: function handleDragEnd(ev) {\n\t        this.set('isDragging', false);\n\t    },\n\t\n\t    onDragOver: function onDragOver(inst, ev) {\n\t        ev.preventDefault();\n\t        ev.dataTransfer.dropEffect = 'move';\n\t    }\n\t});\n\t\n\texports.default = SortableDragItem;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _ractive = __webpack_require__(1);\n\t\n\tvar _ractive2 = _interopRequireDefault(_ractive);\n\t\n\tvar _sortableDragList = __webpack_require__(17);\n\t\n\tvar _sortableDragList2 = _interopRequireDefault(_sortableDragList);\n\t\n\tvar _sortableDragList3 = __webpack_require__(15);\n\t\n\tvar _sortableDragList4 = _interopRequireDefault(_sortableDragList3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar SortableDragList = _ractive2.default.extend({\n\t    template: _sortableDragList4.default,\n\t    data: function data() {\n\t        return {\n\t            css: _sortableDragList2.default,\n\t            isDropping: false\n\t        };\n\t    },\n\t\n\t    oninit: function oninit() {\n\t        this.on('dragEnter', this.handleDragEnter);\n\t        this.on('dragOver', this.handleDragOver);\n\t        this.on('dragLeave', this.handleDragLeave);\n\t    },\n\t\n\t    handleDragEnter: function handleDragEnter(ev) {\n\t        this.set('isDropping', true);\n\t    },\n\t\n\t    handleDragOver: function handleDragOver(ev) {\n\t        ev.original.preventDefault();\n\t        ev.original.dataTransfer.dropEffect = 'move';\n\t    },\n\t\n\t    handleDragLeave: function handleDragLeave(ev) {\n\t        this.set('isDropping', false);\n\t    }\n\t});\n\t\n\texports.default = SortableDragList;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ractive = __webpack_require__(1);\n\t\n\tvar _ractive2 = _interopRequireDefault(_ractive);\n\t\n\tvar _main = __webpack_require__(5);\n\t\n\tvar _main2 = _interopRequireDefault(_main);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t//import Store from './store/store.js';\n\t\n\t_ractive2.default.defaults.twoWay = false;\n\t\n\tif (['complete', 'loaded', 'interactive'].includes(document.readyState) && document.body) run();else window.addEventListener('DOMContentLoaded', run, false);\n\t\n\tfunction run() {\n\t    var ractive = new _ractive2.default({\n\t        twoWay: false,\n\t        el: '#main',\n\t        template: '<Main />',\n\t        components: { Main: _main2.default }\n\t    });\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".main--x41Ty{width:800px}.main--x41Ty ul{float:left;margin-right:20px}.insertAfter--2pLYf li:last-child{border-bottom:1px dotted #000!important}.insertBefore--3ajF-{border-top:1px dotted #000!important}\", \"\", {\"version\":3,\"sources\":[\"/./src/ractivePOC/components/main/main.scss\"],\"names\":[],\"mappings\":\"AAAA,aAAc,WAAW,CAAC,gBAAiB,WAAW,iBAAiB,CAAC,kCAAmC,uCAAwC,CAAC,qBAAsB,oCAAqC,CAAC\",\"file\":\"main.scss\",\"sourcesContent\":[\":local(.main){width:800px}:local(.main) ul{float:left;margin-right:20px}:local(.insertAfter) li:last-child{border-bottom:1px dotted #000 !important}:local(.insertBefore){border-top:1px dotted #000 !important}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"main\": \"main--x41Ty\",\n\t\t\"insertAfter\": \"insertAfter--2pLYf\",\n\t\t\"insertBefore\": \"insertBefore--3ajF-\"\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".sortableDragItem--YNU05{padding:4px 5px;display:block;border-top:1px solid transparent;border-bottom:1px solid transparent;background-color:transparent}.sortableDragItem--YNU05 a{background-color:#ddd;display:block;padding:5px 10px;cursor:pointer}.sortableDragItem--YNU05 a:hover{background-color:#afa}\", \"\", {\"version\":3,\"sources\":[\"/./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.scss\"],\"names\":[],\"mappings\":\"AAAA,yBAA0B,gBAAgB,cAAc,iCAAiC,oCAAoC,4BAA4B,CAAC,2BAA4B,sBAAsB,cAAc,iBAAiB,cAAc,CAAC,iCAAkC,qBAAqB,CAAC\",\"file\":\"sortableDragItem.scss\",\"sourcesContent\":[\":local(.sortableDragItem){padding:4px 5px;display:block;border-top:1px solid transparent;border-bottom:1px solid transparent;background-color:transparent}:local(.sortableDragItem) a{background-color:#ddd;display:block;padding:5px 10px;cursor:pointer}:local(.sortableDragItem) a:hover{background-color:#afa}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"sortableDragItem\": \"sortableDragItem--YNU05\"\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".sortableDragList--3SFZ-{margin:20px;padding:5px;background-color:#eee;list-style:none;display:block;width:200px;min-height:400px}\", \"\", {\"version\":3,\"sources\":[\"/./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.scss\"],\"names\":[],\"mappings\":\"AAAA,yBAA0B,YAAY,YAAY,sBAAsB,gBAAgB,cAAc,YAAY,gBAAgB,CAAC\",\"file\":\"sortableDragList.scss\",\"sourcesContent\":[\":local(.sortableDragList){margin:20px;padding:5px;background-color:#eee;list-style:none;display:block;width:200px;min-height:400px}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"sortableDragList\": \"sortableDragList--3SFZ-\"\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * jQuery JavaScript Library v3.1.1\n\t * https://jquery.com/\n\t *\n\t * Includes Sizzle.js\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2016-09-22T22:30Z\n\t */\n\t( function( global, factory ) {\n\t\n\t\t\"use strict\";\n\t\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\n\t\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t\t// is present, execute the factory and get jQuery.\n\t\t\t// For environments that do not have a `window` with a `document`\n\t\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t\t// This accentuates the need for the creation of a real `window`.\n\t\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t\t// See ticket #14549 for more info.\n\t\t\tmodule.exports = global.document ?\n\t\t\t\tfactory( global, true ) :\n\t\t\t\tfunction( w ) {\n\t\t\t\t\tif ( !w.document ) {\n\t\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn factory( w );\n\t\t\t\t};\n\t\t} else {\n\t\t\tfactory( global );\n\t\t}\n\t\n\t// Pass this if window is not defined yet\n\t} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\t\n\t// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n\t// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n\t// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n\t// enough that all such attempts are guarded in a try block.\n\t\"use strict\";\n\t\n\tvar arr = [];\n\t\n\tvar document = window.document;\n\t\n\tvar getProto = Object.getPrototypeOf;\n\t\n\tvar slice = arr.slice;\n\t\n\tvar concat = arr.concat;\n\t\n\tvar push = arr.push;\n\t\n\tvar indexOf = arr.indexOf;\n\t\n\tvar class2type = {};\n\t\n\tvar toString = class2type.toString;\n\t\n\tvar hasOwn = class2type.hasOwnProperty;\n\t\n\tvar fnToString = hasOwn.toString;\n\t\n\tvar ObjectFunctionString = fnToString.call( Object );\n\t\n\tvar support = {};\n\t\n\t\n\t\n\t\tfunction DOMEval( code, doc ) {\n\t\t\tdoc = doc || document;\n\t\n\t\t\tvar script = doc.createElement( \"script\" );\n\t\n\t\t\tscript.text = code;\n\t\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t\t}\n\t/* global Symbol */\n\t// Defining this global in .eslintrc.json would create a danger of using the global\n\t// unguarded in another place, it seems safer to define global only for this module\n\t\n\t\n\t\n\tvar\n\t\tversion = \"3.1.1\",\n\t\n\t\t// Define a local copy of jQuery\n\t\tjQuery = function( selector, context ) {\n\t\n\t\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\t\treturn new jQuery.fn.init( selector, context );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\t// Make sure we trim BOM and NBSP\n\t\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\t\n\t\t// Matches dashed string for camelizing\n\t\trmsPrefix = /^-ms-/,\n\t\trdashAlpha = /-([a-z])/g,\n\t\n\t\t// Used by jQuery.camelCase as callback to replace()\n\t\tfcamelCase = function( all, letter ) {\n\t\t\treturn letter.toUpperCase();\n\t\t};\n\t\n\tjQuery.fn = jQuery.prototype = {\n\t\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\t\n\t\tconstructor: jQuery,\n\t\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\t\n\t\ttoArray: function() {\n\t\t\treturn slice.call( this );\n\t\t},\n\t\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function( num ) {\n\t\n\t\t\t// Return all the elements in a clean array\n\t\t\tif ( num == null ) {\n\t\t\t\treturn slice.call( this );\n\t\t\t}\n\t\n\t\t\t// Return just the one element from the set\n\t\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t\t},\n\t\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function( elems ) {\n\t\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\t\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\t\n\t\t// Execute a callback for every element in the matched set.\n\t\teach: function( callback ) {\n\t\t\treturn jQuery.each( this, callback );\n\t\t},\n\t\n\t\tmap: function( callback ) {\n\t\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\t\treturn callback.call( elem, i, elem );\n\t\t\t} ) );\n\t\t},\n\t\n\t\tslice: function() {\n\t\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t\t},\n\t\n\t\tfirst: function() {\n\t\t\treturn this.eq( 0 );\n\t\t},\n\t\n\t\tlast: function() {\n\t\t\treturn this.eq( -1 );\n\t\t},\n\t\n\t\teq: function( i ) {\n\t\t\tvar len = this.length,\n\t\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t\t},\n\t\n\t\tend: function() {\n\t\t\treturn this.prevObject || this.constructor();\n\t\t},\n\t\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\t\n\tjQuery.extend = jQuery.fn.extend = function() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[ 0 ] || {},\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif ( typeof target === \"boolean\" ) {\n\t\t\tdeep = target;\n\t\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[ i ] || {};\n\t\t\ti++;\n\t\t}\n\t\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif ( i === length ) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\t\n\t\tfor ( ; i < length; i++ ) {\n\t\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ( ( options = arguments[ i ] ) != null ) {\n\t\n\t\t\t\t// Extend the base object\n\t\t\t\tfor ( name in options ) {\n\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\tcopy = options[ name ];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\t\n\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\t\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\t\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\t\n\t\terror: function( msg ) {\n\t\t\tthrow new Error( msg );\n\t\t},\n\t\n\t\tnoop: function() {},\n\t\n\t\tisFunction: function( obj ) {\n\t\t\treturn jQuery.type( obj ) === \"function\";\n\t\t},\n\t\n\t\tisArray: Array.isArray,\n\t\n\t\tisWindow: function( obj ) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\t\n\t\tisNumeric: function( obj ) {\n\t\n\t\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t\t// strings and numbers (primitives or objects)\n\t\t\t// that can be coerced to finite numbers (gh-2662)\n\t\t\tvar type = jQuery.type( obj );\n\t\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\t\n\t\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t\t// subtraction forces infinities to NaN\n\t\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t\t},\n\t\n\t\tisPlainObject: function( obj ) {\n\t\t\tvar proto, Ctor;\n\t\n\t\t\t// Detect obvious negatives\n\t\t\t// Use toString instead of jQuery.type to catch host objects\n\t\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tproto = getProto( obj );\n\t\n\t\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\t\tif ( !proto ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t\t},\n\t\n\t\tisEmptyObject: function( obj ) {\n\t\n\t\t\t/* eslint-disable no-unused-vars */\n\t\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\t\tvar name;\n\t\n\t\t\tfor ( name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\ttype: function( obj ) {\n\t\t\tif ( obj == null ) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\n\t\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\t\ttypeof obj;\n\t\t},\n\t\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function( code ) {\n\t\t\tDOMEval( code );\n\t\t},\n\t\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function( string ) {\n\t\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t\t},\n\t\n\t\tnodeName: function( elem, name ) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\t\n\t\teach: function( obj, callback ) {\n\t\t\tvar length, i = 0;\n\t\n\t\t\tif ( isArrayLike( obj ) ) {\n\t\t\t\tlength = obj.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn obj;\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\ttrim: function( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\t\n\t\t// results is for internal usage only\n\t\tmakeArray: function( arr, results ) {\n\t\t\tvar ret = results || [];\n\t\n\t\t\tif ( arr != null ) {\n\t\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call( ret, arr );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn ret;\n\t\t},\n\t\n\t\tinArray: function( elem, arr, i ) {\n\t\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\tmerge: function( first, second ) {\n\t\t\tvar len = +second.length,\n\t\t\t\tj = 0,\n\t\t\t\ti = first.length;\n\t\n\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\n\t\t\tfirst.length = i;\n\t\n\t\t\treturn first;\n\t\t},\n\t\n\t\tgrep: function( elems, callback, invert ) {\n\t\t\tvar callbackInverse,\n\t\t\t\tmatches = [],\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tcallbackExpect = !invert;\n\t\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn matches;\n\t\t},\n\t\n\t\t// arg is for internal usage only\n\t\tmap: function( elems, callback, arg ) {\n\t\t\tvar length, value,\n\t\t\t\ti = 0,\n\t\t\t\tret = [];\n\t\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif ( isArrayLike( elems ) ) {\n\t\t\t\tlength = elems.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor ( i in elems ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply( [], ret );\n\t\t},\n\t\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\t\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function( fn, context ) {\n\t\t\tvar tmp, args, proxy;\n\t\n\t\t\tif ( typeof context === \"string\" ) {\n\t\t\t\ttmp = fn[ context ];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\t\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\n\t\t\t// Simulated bind\n\t\t\targs = slice.call( arguments, 2 );\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\t\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\t\n\t\t\treturn proxy;\n\t\t},\n\t\n\t\tnow: Date.now,\n\t\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t} );\n\t\n\tif ( typeof Symbol === \"function\" ) {\n\t\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n\t}\n\t\n\t// Populate the class2type map\n\tjQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n\tfunction( i, name ) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t} );\n\t\n\tfunction isArrayLike( obj ) {\n\t\n\t\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\t\ttype = jQuery.type( obj );\n\t\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n\t * Sizzle CSS Selector Engine v2.3.3\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2016-08-08\n\t */\n\t(function( window ) {\n\t\n\tvar i,\n\t\tsupport,\n\t\tExpr,\n\t\tgetText,\n\t\tisXML,\n\t\ttokenize,\n\t\tcompile,\n\t\tselect,\n\t\toutermostContext,\n\t\tsortInput,\n\t\thasDuplicate,\n\t\n\t\t// Local document vars\n\t\tsetDocument,\n\t\tdocument,\n\t\tdocElem,\n\t\tdocumentIsHTML,\n\t\trbuggyQSA,\n\t\trbuggyMatches,\n\t\tmatches,\n\t\tcontains,\n\t\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\tpreferredDoc = window.document,\n\t\tdirruns = 0,\n\t\tdone = 0,\n\t\tclassCache = createCache(),\n\t\ttokenCache = createCache(),\n\t\tcompilerCache = createCache(),\n\t\tsortOrder = function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\n\t\t// Instance methods\n\t\thasOwn = ({}).hasOwnProperty,\n\t\tarr = [],\n\t\tpop = arr.pop,\n\t\tpush_native = arr.push,\n\t\tpush = arr.push,\n\t\tslice = arr.slice,\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// https://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function( list, elem ) {\n\t\t\tvar i = 0,\n\t\t\t\tlen = list.length;\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tif ( list[i] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\n\t\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\t\n\t\t// Regular expressions\n\t\n\t\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\t\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t\t// Operator (capture 2)\n\t\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\t\"*\\\\]\",\n\t\n\t\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t\t// 2. simple (capture 6)\n\t\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t\t// 3. anything else (capture 2)\n\t\t\t\".*\" +\n\t\t\t\")\\\\)|)\",\n\t\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\t\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\t\n\t\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\t\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\t\n\t\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\t\n\t\trpseudo = new RegExp( pseudos ),\n\t\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\t\n\t\tmatchExpr = {\n\t\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t\t},\n\t\n\t\trinputs = /^(?:input|select|textarea|button)$/i,\n\t\trheader = /^h\\d$/i,\n\t\n\t\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\t\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\n\t\trsibling = /[+~]/,\n\t\n\t\t// CSS escapes\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\t\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ?\n\t\t\t\tescaped :\n\t\t\t\thigh < 0 ?\n\t\t\t\t\t// BMP codepoint\n\t\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t\t},\n\t\n\t\t// CSS string/identifier serialization\n\t\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\t\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t\tfcssescape = function( ch, asCodePoint ) {\n\t\t\tif ( asCodePoint ) {\n\t\n\t\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\t\treturn \"\\uFFFD\";\n\t\t\t\t}\n\t\n\t\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t\t}\n\t\n\t\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\t\treturn \"\\\\\" + ch;\n\t\t},\n\t\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function() {\n\t\t\tsetDocument();\n\t\t},\n\t\n\t\tdisabledAncestor = addCombinator(\n\t\t\tfunction( elem ) {\n\t\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t\t},\n\t\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t\t);\n\t\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(\n\t\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\t\tpreferredDoc.childNodes\n\t\t);\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\tarr[ preferredDoc.childNodes.length ].nodeType;\n\t} catch ( e ) {\n\t\tpush = { apply: arr.length ?\n\t\n\t\t\t// Leverage slice if possible\n\t\t\tfunction( target, els ) {\n\t\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t\t} :\n\t\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction( target, els ) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t\ti = 0;\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction Sizzle( selector, context, results, seed ) {\n\t\tvar m, i, elem, nid, match, groups, newSelector,\n\t\t\tnewContext = context && context.ownerDocument,\n\t\n\t\t\t// nodeType defaults to 9, since context defaults to document\n\t\t\tnodeType = context ? context.nodeType : 9;\n\t\n\t\tresults = results || [];\n\t\n\t\t// Return early from calls with invalid selector or context\n\t\tif ( typeof selector !== \"string\" || !selector ||\n\t\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\t\n\t\t\treturn results;\n\t\t}\n\t\n\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\tif ( !seed ) {\n\t\n\t\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\t\tsetDocument( context );\n\t\t\t}\n\t\t\tcontext = context || document;\n\t\n\t\t\tif ( documentIsHTML ) {\n\t\n\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\n\t\t\t\t\t// ID selector\n\t\t\t\t\tif ( (m = match[1]) ) {\n\t\n\t\t\t\t\t\t// Document context\n\t\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\t\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\t\telem.id === m ) {\n\t\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t// Type selector\n\t\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\t\treturn results;\n\t\n\t\t\t\t\t// Class selector\n\t\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\t\tcontext.getElementsByClassName ) {\n\t\n\t\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\tif ( support.qsa &&\n\t\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\n\t\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\t\tnewContext = context;\n\t\t\t\t\t\tnewSelector = selector;\n\t\n\t\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t// Exclude object elements\n\t\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\t\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\n\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\t\tcontext;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( newSelector ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// All others\n\t\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\t}\n\t\n\t/**\n\t * Create key-value caches of limited size\n\t * @returns {function(string, object)} Returns the Object data after storing it on itself with\n\t *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\t *\tdeleting the oldest entry\n\t */\n\tfunction createCache() {\n\t\tvar keys = [];\n\t\n\t\tfunction cache( key, value ) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[ keys.shift() ];\n\t\t\t}\n\t\t\treturn (cache[ key + \" \" ] = value);\n\t\t}\n\t\treturn cache;\n\t}\n\t\n\t/**\n\t * Mark a function for special use by Sizzle\n\t * @param {Function} fn The function to mark\n\t */\n\tfunction markFunction( fn ) {\n\t\tfn[ expando ] = true;\n\t\treturn fn;\n\t}\n\t\n\t/**\n\t * Support testing using an element\n\t * @param {Function} fn Passed the created element and returns a boolean result\n\t */\n\tfunction assert( fn ) {\n\t\tvar el = document.createElement(\"fieldset\");\n\t\n\t\ttry {\n\t\t\treturn !!fn( el );\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif ( el.parentNode ) {\n\t\t\t\tel.parentNode.removeChild( el );\n\t\t\t}\n\t\t\t// release memory in IE\n\t\t\tel = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the same handler for all of the specified attrs\n\t * @param {String} attrs Pipe-separated list of attributes\n\t * @param {Function} handler The method that will be applied\n\t */\n\tfunction addHandle( attrs, handler ) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t\ti = arr.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks document order of two siblings\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n\t */\n\tfunction siblingCheck( a, b ) {\n\t\tvar cur = b && a,\n\t\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t\ta.sourceIndex - b.sourceIndex;\n\t\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif ( diff ) {\n\t\t\treturn diff;\n\t\t}\n\t\n\t\t// Check if b follows a\n\t\tif ( cur ) {\n\t\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\t\tif ( cur === b ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a ? 1 : -1;\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for input types\n\t * @param {String} type\n\t */\n\tfunction createInputPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for buttons\n\t * @param {String} type\n\t */\n\tfunction createButtonPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for :enabled/:disabled\n\t * @param {Boolean} disabled true for :disabled; false for :enabled\n\t */\n\tfunction createDisabledPseudo( disabled ) {\n\t\n\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\treturn function( elem ) {\n\t\n\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\tif ( \"form\" in elem ) {\n\t\n\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t// All such elements have a \"form\" property.\n\t\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\t\n\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\treturn elem.isDisabled === disabled ||\n\t\n\t\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.disabled === disabled;\n\t\n\t\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t} else if ( \"label\" in elem ) {\n\t\t\t\treturn elem.disabled === disabled;\n\t\t\t}\n\t\n\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\treturn false;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for positionals\n\t * @param {Function} fn\n\t */\n\tfunction createPositionalPseudo( fn ) {\n\t\treturn markFunction(function( argument ) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function( seed, matches ) {\n\t\t\t\tvar j,\n\t\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\t\ti = matchIndexes.length;\n\t\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\t/**\n\t * Checks a node for validity as a Sizzle context\n\t * @param {Element|Object=} context\n\t * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n\t */\n\tfunction testContext( context ) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\t\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\t\n\t/**\n\t * Detects XML nodes\n\t * @param {Element|Object} elem An element or a document\n\t * @returns {Boolean} True iff elem is a non-HTML XML node\n\t */\n\tisXML = Sizzle.isXML = function( elem ) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t};\n\t\n\t/**\n\t * Sets document-related variables once based on the current document\n\t * @param {Element|Object} [doc] An element or document object to use to set the document\n\t * @returns {Object} Returns the current document\n\t */\n\tsetDocument = Sizzle.setDocument = function( node ) {\n\t\tvar hasCompare, subWindow,\n\t\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\t\n\t\t// Return early if doc is invalid or already selected\n\t\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\t\treturn document;\n\t\t}\n\t\n\t\t// Update global variables\n\t\tdocument = doc;\n\t\tdocElem = document.documentElement;\n\t\tdocumentIsHTML = !isXML( document );\n\t\n\t\t// Support: IE 9-11, Edge\n\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t\tif ( preferredDoc !== document &&\n\t\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\t\n\t\t\t// Support: IE 11, Edge\n\t\t\tif ( subWindow.addEventListener ) {\n\t\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\t\n\t\t\t// Support: IE 9 - 10 only\n\t\t\t} else if ( subWindow.attachEvent ) {\n\t\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t\t}\n\t\t}\n\t\n\t\t/* Attributes\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function( el ) {\n\t\t\tel.className = \"i\";\n\t\t\treturn !el.getAttribute(\"className\");\n\t\t});\n\t\n\t\t/* getElement(s)By*\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function( el ) {\n\t\t\tel.appendChild( document.createComment(\"\") );\n\t\t\treturn !el.getElementsByTagName(\"*\").length;\n\t\t});\n\t\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\t\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programmatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function( el ) {\n\t\t\tdocElem.appendChild( el ).id = expando;\n\t\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t\t});\n\t\n\t\t// ID filter and find\n\t\tif ( support.getById ) {\n\t\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\n\t\t\t// Support: IE 6 - 7 only\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar node, i, elems,\n\t\t\t\t\t\telem = context.getElementById( id );\n\t\n\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\t\tfunction( tag, context ) {\n\t\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\treturn context.getElementsByTagName( tag );\n\t\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if ( support.qsa ) {\n\t\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t\t}\n\t\t\t} :\n\t\n\t\t\tfunction( tag, context ) {\n\t\t\t\tvar elem,\n\t\t\t\t\ttmp = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\t\tresults = context.getElementsByTagName( tag );\n\t\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif ( tag === \"*\" ) {\n\t\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\t\treturn context.getElementsByClassName( className );\n\t\t\t}\n\t\t};\n\t\n\t\t/* QSA/matchesSelector\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// QSA and matchesSelector support\n\t\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\t\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See https://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\t\n\t\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function( el ) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\t\"<option selected=''></option></select>\";\n\t\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\t\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\t\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t\t}\n\t\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\t\n\t\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\t\tdocElem.webkitMatchesSelector ||\n\t\t\tdocElem.mozMatchesSelector ||\n\t\t\tdocElem.oMatchesSelector ||\n\t\t\tdocElem.msMatchesSelector) )) ) {\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\t\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t\t});\n\t\t}\n\t\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\t\n\t\t/* Contains\n\t\t---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\t\n\t\t// Element contains another\n\t\t// Purposefully self-exclusive\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\t\tfunction( a, b ) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t\tbup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\t\tadown.contains ?\n\t\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t\t));\n\t\t\t} :\n\t\t\tfunction( a, b ) {\n\t\t\t\tif ( b ) {\n\t\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\n\t\t/* Sorting\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ?\n\t\tfunction( a, b ) {\n\t\n\t\t\t// Flag for duplicate removal\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif ( compare ) {\n\t\t\t\treturn compare;\n\t\t\t}\n\t\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\t\ta.compareDocumentPosition( b ) :\n\t\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\t\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\t\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\t\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\taup = a.parentNode,\n\t\t\t\tbup = b.parentNode,\n\t\t\t\tap = [ a ],\n\t\t\t\tbp = [ b ];\n\t\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif ( !aup || !bup ) {\n\t\t\t\treturn a === document ? -1 :\n\t\t\t\t\tb === document ? 1 :\n\t\t\t\t\taup ? -1 :\n\t\t\t\t\tbup ? 1 :\n\t\t\t\t\tsortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\n\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if ( aup === bup ) {\n\t\t\t\treturn siblingCheck( a, b );\n\t\t\t}\n\t\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tap.unshift( cur );\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tbp.unshift( cur );\n\t\t\t}\n\t\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile ( ap[i] === bp[i] ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\n\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\t\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t\t0;\n\t\t};\n\t\n\t\treturn document;\n\t};\n\t\n\tSizzle.matches = function( expr, elements ) {\n\t\treturn Sizzle( expr, null, null, elements );\n\t};\n\t\n\tSizzle.matchesSelector = function( elem, expr ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\t// Make sure that attribute selectors are quoted\n\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\t\n\t\tif ( support.matchesSelector && documentIsHTML &&\n\t\t\t!compilerCache[ expr + \" \" ] &&\n\t\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\t\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call( elem, expr );\n\t\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\n\t\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n\t};\n\t\n\tSizzle.contains = function( context, elem ) {\n\t\t// Set document vars if needed\n\t\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\treturn contains( context, elem );\n\t};\n\t\n\tSizzle.attr = function( elem, name ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\t\tundefined;\n\t\n\t\treturn val !== undefined ?\n\t\t\tval :\n\t\t\tsupport.attributes || !documentIsHTML ?\n\t\t\t\telem.getAttribute( name ) :\n\t\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t};\n\t\n\tSizzle.escape = function( sel ) {\n\t\treturn (sel + \"\").replace( rcssescape, fcssescape );\n\t};\n\t\n\tSizzle.error = function( msg ) {\n\t\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\t};\n\t\n\t/**\n\t * Document sorting and removing duplicates\n\t * @param {ArrayLike} results\n\t */\n\tSizzle.uniqueSort = function( results ) {\n\t\tvar elem,\n\t\t\tduplicates = [],\n\t\t\tj = 0,\n\t\t\ti = 0;\n\t\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice( 0 );\n\t\tresults.sort( sortOrder );\n\t\n\t\tif ( hasDuplicate ) {\n\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\t\tj = duplicates.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( j-- ) {\n\t\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t\t}\n\t\t}\n\t\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\t\n\t\treturn results;\n\t};\n\t\n\t/**\n\t * Utility function for retrieving the text value of an array of DOM nodes\n\t * @param {Array|Element} elem\n\t */\n\tgetText = Sizzle.getText = function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\t\n\t\tif ( !nodeType ) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( (node = elem[i++]) ) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText( node );\n\t\t\t}\n\t\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tret += getText( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\t\t// Do not include comment or processing instruction nodes\n\t\n\t\treturn ret;\n\t};\n\t\n\tExpr = Sizzle.selectors = {\n\t\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\t\n\t\tcreatePseudo: markFunction,\n\t\n\t\tmatch: matchExpr,\n\t\n\t\tattrHandle: {},\n\t\n\t\tfind: {},\n\t\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\t\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function( match ) {\n\t\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\t\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\t\n\t\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\t\n\t\t\t\treturn match.slice( 0, 4 );\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( match ) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t\t1 type (only|nth|...)\n\t\t\t\t\t2 what (child|of-type)\n\t\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t\t5 sign of xn-component\n\t\t\t\t\t6 x of xn-component\n\t\t\t\t\t7 sign of y-component\n\t\t\t\t\t8 y of y-component\n\t\t\t\t*/\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\t\n\t\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\t\n\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if ( match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\t\n\t\t\t\treturn match;\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( match ) {\n\t\t\t\tvar excess,\n\t\t\t\t\tunquoted = !match[6] && match[2];\n\t\n\t\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif ( match[3] ) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\t\n\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\t\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t\t}\n\t\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice( 0, 3 );\n\t\t\t}\n\t\t},\n\t\n\t\tfilter: {\n\t\n\t\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\t\tfunction() { return true; } :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CLASS\": function( className ) {\n\t\t\t\tvar pattern = classCache[ className + \" \" ];\n\t\n\t\t\t\treturn pattern ||\n\t\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar result = Sizzle.attr( elem, name );\n\t\n\t\t\t\t\tif ( result == null ) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( !operator ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult += \"\";\n\t\n\t\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\t\tfalse;\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\t\tofType = what === \"of-type\";\n\t\n\t\t\t\treturn first === 1 && last === 0 ?\n\t\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} :\n\t\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\t\tdiff = false;\n\t\n\t\t\t\t\t\tif ( parent ) {\n\t\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\t\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif ( forward && useCache ) {\n\t\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\t\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\n\t\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t\t++diff ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\t\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif ( fn[ expando ] ) {\n\t\t\t\t\treturn fn( argument );\n\t\t\t\t}\n\t\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif ( fn.length > 1 ) {\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function( selector ) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t\tresults = [],\n\t\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\t\n\t\t\t\treturn matcher[ expando ] ?\n\t\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\t\ti = seed.length;\n\t\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"has\": markFunction(function( selector ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"contains\": markFunction(function( text ) {\n\t\t\t\ttext = text.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t\t}\n\t\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\t\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function( elem ) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t\t},\n\t\n\t\t\t\"root\": function( elem ) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\t\n\t\t\t\"focus\": function( elem ) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\t\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\t\"disabled\": createDisabledPseudo( true ),\n\t\n\t\t\t\"checked\": function( elem ) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t\t},\n\t\n\t\t\t\"selected\": function( elem ) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\t\n\t\t\t// Contents\n\t\t\t\"empty\": function( elem ) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"parent\": function( elem ) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t\t},\n\t\n\t\t\t// Element/input types\n\t\t\t\"header\": function( elem ) {\n\t\t\t\treturn rheader.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"input\": function( elem ) {\n\t\t\t\treturn rinputs.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"button\": function( elem ) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\t\n\t\t\t\"text\": function( elem ) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\t\telem.type === \"text\" &&\n\t\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t\t},\n\t\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function() {\n\t\t\t\treturn [ 0 ];\n\t\t\t}),\n\t\n\t\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\treturn [ length - 1 ];\n\t\t\t}),\n\t\n\t\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t\t}),\n\t\n\t\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\t\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\t\n\t// Add button/input type pseudos\n\tfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\t\tExpr.pseudos[ i ] = createInputPseudo( i );\n\t}\n\tfor ( i in { submit: true, reset: true } ) {\n\t\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\t}\n\t\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\t\n\ttokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\t\tvar matched, match, tokens, type,\n\t\t\tsoFar, groups, preFilters,\n\t\t\tcached = tokenCache[ selector + \" \" ];\n\t\n\t\tif ( cached ) {\n\t\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t\t}\n\t\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\t\n\t\twhile ( soFar ) {\n\t\n\t\t\t// Comma and first run\n\t\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\t\tif ( match ) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push( (tokens = []) );\n\t\t\t}\n\t\n\t\t\tmatched = false;\n\t\n\t\t\t// Combinators\n\t\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\n\t\t\t// Filters\n\t\t\tfor ( type in Expr.filter ) {\n\t\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !matched ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ?\n\t\t\tsoFar.length :\n\t\t\tsoFar ?\n\t\t\t\tSizzle.error( selector ) :\n\t\t\t\t// Cache the tokens\n\t\t\t\ttokenCache( selector, groups ).slice( 0 );\n\t};\n\t\n\tfunction toSelector( tokens ) {\n\t\tvar i = 0,\n\t\t\tlen = tokens.length,\n\t\t\tselector = \"\";\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\t\n\tfunction addCombinator( matcher, combinator, base ) {\n\t\tvar dir = combinator.dir,\n\t\t\tskip = combinator.next,\n\t\t\tkey = skip || dir,\n\t\t\tcheckNonElements = base && key === \"parentNode\",\n\t\t\tdoneName = done++;\n\t\n\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} :\n\t\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\t\tnewCache = [ dirruns, doneName ];\n\t\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\t\tif ( xml ) {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\t\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\t\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t}\n\t\n\tfunction elementMatcher( matchers ) {\n\t\treturn matchers.length > 1 ?\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} :\n\t\t\tmatchers[0];\n\t}\n\t\n\tfunction multipleContexts( selector, contexts, results ) {\n\t\tvar i = 0,\n\t\t\tlen = contexts.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tSizzle( selector, contexts[i], results );\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tfunction condense( unmatched, map, filter, context, xml ) {\n\t\tvar elem,\n\t\t\tnewUnmatched = [],\n\t\t\ti = 0,\n\t\t\tlen = unmatched.length,\n\t\t\tmapped = map != null;\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\t\tif ( mapped ) {\n\t\t\t\t\t\tmap.push( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn newUnmatched;\n\t}\n\t\n\tfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\t\tif ( postFilter && !postFilter[ expando ] ) {\n\t\t\tpostFilter = setMatcher( postFilter );\n\t\t}\n\t\tif ( postFinder && !postFinder[ expando ] ) {\n\t\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t\t}\n\t\treturn markFunction(function( seed, results, context, xml ) {\n\t\t\tvar temp, i, elem,\n\t\t\t\tpreMap = [],\n\t\t\t\tpostMap = [],\n\t\t\t\tpreexisting = results.length,\n\t\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\t\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\t\telems,\n\t\n\t\t\t\tmatcherOut = matcher ?\n\t\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\t\n\t\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t\t[] :\n\t\n\t\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\t\tresults :\n\t\t\t\t\tmatcherIn;\n\t\n\t\t\t// Find primary matches\n\t\t\tif ( matcher ) {\n\t\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t\t}\n\t\n\t\t\t// Apply postFilter\n\t\t\tif ( postFilter ) {\n\t\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\t\tpostFilter( temp, [], context, xml );\n\t\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( seed ) {\n\t\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\t\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(\n\t\t\t\t\tmatcherOut === results ?\n\t\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\t\tmatcherOut\n\t\t\t\t);\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction matcherFromTokens( tokens ) {\n\t\tvar checkContext, matcher, j,\n\t\t\tlen = tokens.length,\n\t\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\ti = leadingRelative ? 1 : 0,\n\t\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t} ];\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\t\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(\n\t\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmatchers.push( matcher );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elementMatcher( matchers );\n\t}\n\t\n\tfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t\tbyElement = elementMatchers.length > 0,\n\t\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\t\tvar elem, j, matcher,\n\t\t\t\t\tmatchedCount = 0,\n\t\t\t\t\ti = \"0\",\n\t\t\t\t\tunmatched = seed && [],\n\t\t\t\t\tsetMatched = [],\n\t\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\t\tlen = elems.length;\n\t\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t\t}\n\t\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif ( bySet ) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t\t// makes the latter nonnegative.\n\t\t\t\tmatchedCount += i;\n\t\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t\t// no element matchers and no seed.\n\t\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t\t// numerically zero.\n\t\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply( results, setMatched );\n\t\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\t\n\t\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\t\n\t\t\t\treturn unmatched;\n\t\t\t};\n\t\n\t\treturn bySet ?\n\t\t\tmarkFunction( superMatcher ) :\n\t\t\tsuperMatcher;\n\t}\n\t\n\tcompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\t\tvar i,\n\t\t\tsetMatchers = [],\n\t\t\telementMatchers = [],\n\t\t\tcached = compilerCache[ selector + \" \" ];\n\t\n\t\tif ( !cached ) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif ( !match ) {\n\t\t\t\tmatch = tokenize( selector );\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\t\tif ( cached[ expando ] ) {\n\t\t\t\t\tsetMatchers.push( cached );\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push( cached );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\t\n\t/**\n\t * A low-level selection function that works with Sizzle's compiled\n\t *  selector functions\n\t * @param {String|Function} selector A selector or a pre-compiled\n\t *  selector function built with Sizzle.compile\n\t * @param {Element} context\n\t * @param {Array} [results]\n\t * @param {Array} [seed] A set of elements to match against\n\t */\n\tselect = Sizzle.select = function( selector, context, results, seed ) {\n\t\tvar i, tokens, token, type, find,\n\t\t\tcompiled = typeof selector === \"function\" && selector,\n\t\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\t\n\t\tresults = results || [];\n\t\n\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t// (the latter of which guarantees us context)\n\t\tif ( match.length === 1 ) {\n\t\n\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\t\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\n\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if ( compiled ) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\t\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\t\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\t\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\t\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t( compiled || compile( selector, match ) )(\n\t\t\tseed,\n\t\t\tcontext,\n\t\t\t!documentIsHTML,\n\t\t\tresults,\n\t\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t\t);\n\t\treturn results;\n\t};\n\t\n\t// One-time assignments\n\t\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\t\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\t\n\t// Initialize against the default document\n\tsetDocument();\n\t\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function( el ) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n\t});\n\t\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !assert(function( el ) {\n\t\tel.innerHTML = \"<a href='#'></a>\";\n\t\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n\t}) ) {\n\t\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif ( !support.attributes || !assert(function( el ) {\n\t\tel.innerHTML = \"<input/>\";\n\t\tel.firstChild.setAttribute( \"value\", \"\" );\n\t\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n\t}) ) {\n\t\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif ( !assert(function( el ) {\n\t\treturn el.getAttribute(\"disabled\") == null;\n\t}) ) {\n\t\taddHandle( booleans, function( elem, name, isXML ) {\n\t\t\tvar val;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn Sizzle;\n\t\n\t})( window );\n\t\n\t\n\t\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\t\n\t// Deprecated\n\tjQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n\tjQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\tjQuery.escapeSelector = Sizzle.escape;\n\t\n\t\n\t\n\t\n\tvar dir = function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\t\n\t\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar siblings = function( n, elem ) {\n\t\tvar matched = [];\n\t\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\t\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\t\n\tvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\t\n\t\n\t\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\t\n\t// Implement the identical functionality for filter and not\n\tfunction winnow( elements, qualifier, not ) {\n\t\tif ( jQuery.isFunction( qualifier ) ) {\n\t\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Single element\n\t\tif ( qualifier.nodeType ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( elem === qualifier ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Arraylike of elements (jQuery, arguments, Array)\n\t\tif ( typeof qualifier !== \"string\" ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Simple selector that can be filtered directly, removing non-Elements\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\t\n\t\t// Complex selector, compare the two sets, removing non-Elements\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t\t} );\n\t}\n\t\n\tjQuery.filter = function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\t\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\t\n\t\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t\t}\n\t\n\t\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t} ) );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfind: function( selector ) {\n\t\t\tvar i, ret,\n\t\t\t\tlen = this.length,\n\t\t\t\tself = this;\n\t\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) );\n\t\t\t}\n\t\n\t\t\tret = this.pushStack( [] );\n\t\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t\t}\n\t\n\t\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t\t},\n\t\tfilter: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t\t},\n\t\tnot: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t\t},\n\t\tis: function( selector ) {\n\t\t\treturn !!winnow(\n\t\t\t\tthis,\n\t\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector ) :\n\t\t\t\t\tselector || [],\n\t\t\t\tfalse\n\t\t\t).length;\n\t\t}\n\t} );\n\t\n\t\n\t// Initialize a jQuery object\n\t\n\t\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\t\n\t\t// A simple way to check for HTML strings\n\t\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t\t// Strict HTML recognition (#11290: must start with <)\n\t\t// Shortcut simple #id case for speed\n\t\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\t\n\t\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\t\tvar match, elem;\n\t\n\t\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\t\tif ( !selector ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t// Method init() accepts an alternate rootjQuery\n\t\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\t\troot = root || rootjQuery;\n\t\n\t\t\t// Handle HTML strings\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\t\tselector.length >= 3 ) {\n\t\n\t\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\t\tmatch = [ null, selector, null ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t\t}\n\t\n\t\t\t\t// Match html or make sure no context is specified for #id\n\t\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\t\n\t\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\t\n\t\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) );\n\t\n\t\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tfor ( match in context ) {\n\t\n\t\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\t\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\t\n\t\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\t\treturn ( context || root ).find( selector );\n\t\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t\t}\n\t\n\t\t\t// HANDLE: $(DOMElement)\n\t\t\t} else if ( selector.nodeType ) {\n\t\t\t\tthis[ 0 ] = selector;\n\t\t\t\tthis.length = 1;\n\t\t\t\treturn this;\n\t\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\t\treturn root.ready !== undefined ?\n\t\t\t\t\troot.ready( selector ) :\n\t\n\t\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\t\tselector( jQuery );\n\t\t\t}\n\t\n\t\t\treturn jQuery.makeArray( selector, this );\n\t\t};\n\t\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\t\n\t// Initialize central reference\n\trootjQuery = jQuery( document );\n\t\n\t\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t\n\t\t// Methods guaranteed to produce a unique set when starting from a unique set\n\t\tguaranteedUnique = {\n\t\t\tchildren: true,\n\t\t\tcontents: true,\n\t\t\tnext: true,\n\t\t\tprev: true\n\t\t};\n\t\n\tjQuery.fn.extend( {\n\t\thas: function( target ) {\n\t\t\tvar targets = jQuery( target, this ),\n\t\t\t\tl = targets.length;\n\t\n\t\t\treturn this.filter( function() {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tclosest: function( selectors, context ) {\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tmatched = [],\n\t\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\t\n\t\t\t// Positional selectors never match, since there's no _selection_ context\n\t\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\t\n\t\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\t\n\t\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\t\n\t\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t\t},\n\t\n\t\t// Determine the position of an element within the set\n\t\tindex: function( elem ) {\n\t\n\t\t\t// No argument, return index in parent\n\t\t\tif ( !elem ) {\n\t\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t\t}\n\t\n\t\t\t// Index in selector\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t\t}\n\t\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call( this,\n\t\n\t\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t\t);\n\t\t},\n\t\n\t\tadd: function( selector, context ) {\n\t\t\treturn this.pushStack(\n\t\t\t\tjQuery.uniqueSort(\n\t\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\n\t\taddBack: function( selector ) {\n\t\t\treturn this.add( selector == null ?\n\t\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t\t);\n\t\t}\n\t} );\n\t\n\tfunction sibling( cur, dir ) {\n\t\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\t\treturn cur;\n\t}\n\t\n\tjQuery.each( {\n\t\tparent: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function( elem ) {\n\t\t\treturn dir( elem, \"parentNode\" );\n\t\t},\n\t\tparentsUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"parentNode\", until );\n\t\t},\n\t\tnext: function( elem ) {\n\t\t\treturn sibling( elem, \"nextSibling\" );\n\t\t},\n\t\tprev: function( elem ) {\n\t\t\treturn sibling( elem, \"previousSibling\" );\n\t\t},\n\t\tnextAll: function( elem ) {\n\t\t\treturn dir( elem, \"nextSibling\" );\n\t\t},\n\t\tprevAll: function( elem ) {\n\t\t\treturn dir( elem, \"previousSibling\" );\n\t\t},\n\t\tnextUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"nextSibling\", until );\n\t\t},\n\t\tprevUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"previousSibling\", until );\n\t\t},\n\t\tsiblings: function( elem ) {\n\t\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t\t},\n\t\tchildren: function( elem ) {\n\t\t\treturn siblings( elem.firstChild );\n\t\t},\n\t\tcontents: function( elem ) {\n\t\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t\t}\n\t}, function( name, fn ) {\n\t\tjQuery.fn[ name ] = function( until, selector ) {\n\t\t\tvar matched = jQuery.map( this, fn, until );\n\t\n\t\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\t\tselector = until;\n\t\t\t}\n\t\n\t\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t\t}\n\t\n\t\t\tif ( this.length > 1 ) {\n\t\n\t\t\t\t// Remove duplicates\n\t\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t\t}\n\t\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched );\n\t\t};\n\t} );\n\tvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\t\n\t\n\t\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions( options ) {\n\t\tvar object = {};\n\t\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\t\tobject[ flag ] = true;\n\t\t} );\n\t\treturn object;\n\t}\n\t\n\t/*\n\t * Create a callback list using the following parameters:\n\t *\n\t *\toptions: an optional list of space-separated options that will change how\n\t *\t\t\tthe callback list behaves or a more traditional option object\n\t *\n\t * By default a callback list will act like an event callback list and can be\n\t * \"fired\" multiple times.\n\t *\n\t * Possible options:\n\t *\n\t *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\t *\n\t *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\t *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\t *\t\t\t\t\tvalues (like a Deferred)\n\t *\n\t *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\t *\n\t *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\t *\n\t */\n\tjQuery.Callbacks = function( options ) {\n\t\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ?\n\t\t\tcreateOptions( options ) :\n\t\t\tjQuery.extend( {}, options );\n\t\n\t\tvar // Flag to know if list is currently firing\n\t\t\tfiring,\n\t\n\t\t\t// Last fire value for non-forgettable lists\n\t\t\tmemory,\n\t\n\t\t\t// Flag to know if list was already fired\n\t\t\tfired,\n\t\n\t\t\t// Flag to prevent firing\n\t\t\tlocked,\n\t\n\t\t\t// Actual callback list\n\t\t\tlist = [],\n\t\n\t\t\t// Queue of execution data for repeatable lists\n\t\t\tqueue = [],\n\t\n\t\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\t\tfiringIndex = -1,\n\t\n\t\t\t// Fire callbacks\n\t\t\tfire = function() {\n\t\n\t\t\t\t// Enforce single-firing\n\t\t\t\tlocked = options.once;\n\t\n\t\t\t\t// Execute callbacks for all pending executions,\n\t\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\t\tfired = firing = true;\n\t\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\t\tmemory = queue.shift();\n\t\t\t\t\twhile ( ++firingIndex < list.length ) {\n\t\n\t\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\t\toptions.stopOnFalse ) {\n\t\n\t\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Forget the data if we're done with it\n\t\t\t\tif ( !options.memory ) {\n\t\t\t\t\tmemory = false;\n\t\t\t\t}\n\t\n\t\t\t\tfiring = false;\n\t\n\t\t\t\t// Clean up if we're done firing for good\n\t\t\t\tif ( locked ) {\n\t\n\t\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\t\tif ( memory ) {\n\t\t\t\t\t\tlist = [];\n\t\n\t\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// Actual Callbacks object\n\t\t\tself = {\n\t\n\t\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\t\tadd: function() {\n\t\t\t\t\tif ( list ) {\n\t\n\t\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} )( arguments );\n\t\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove a callback from the list\n\t\t\t\tremove: function() {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Check if a given callback is in the list.\n\t\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\t\thas: function( fn ) {\n\t\t\t\t\treturn fn ?\n\t\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\t\tlist.length > 0;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove all callbacks from the list\n\t\t\t\tempty: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire and .add\n\t\t\t\t// Abort any current/pending executions\n\t\t\t\t// Clear all callbacks and values\n\t\t\t\tdisable: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tdisabled: function() {\n\t\t\t\t\treturn !list;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire\n\t\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t\t// Abort any pending executions\n\t\t\t\tlock: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tlocked: function() {\n\t\t\t\t\treturn !!locked;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all callbacks with the given context and arguments\n\t\t\t\tfireWith: function( context, args ) {\n\t\t\t\t\tif ( !locked ) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\t\tqueue.push( args );\n\t\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all the callbacks with the given arguments\n\t\t\t\tfire: function() {\n\t\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// To know if the callbacks have already been called at least once\n\t\t\t\tfired: function() {\n\t\t\t\t\treturn !!fired;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\treturn self;\n\t};\n\t\n\t\n\tfunction Identity( v ) {\n\t\treturn v;\n\t}\n\tfunction Thrower( ex ) {\n\t\tthrow ex;\n\t}\n\t\n\tfunction adoptValue( value, resolve, reject ) {\n\t\tvar method;\n\t\n\t\ttry {\n\t\n\t\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\t\n\t\t\t// Other thenables\n\t\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\t\tmethod.call( value, resolve, reject );\n\t\n\t\t\t// Other non-thenables\n\t\t\t} else {\n\t\n\t\t\t\t// Support: Android 4.0 only\n\t\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\t\tresolve.call( undefined, value );\n\t\t\t}\n\t\n\t\t// For Promises/A+, convert exceptions into rejections\n\t\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t\t// Deferred#then to conditionally suppress rejection.\n\t\t} catch ( value ) {\n\t\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\treject.call( undefined, value );\n\t\t}\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\tDeferred: function( func ) {\n\t\t\tvar tuples = [\n\t\n\t\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t\t],\n\t\t\t\tstate = \"pending\",\n\t\t\t\tpromise = {\n\t\t\t\t\tstate: function() {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t},\n\t\t\t\t\talways: function() {\n\t\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Keep pipe for back-compat\n\t\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\t\tvar fns = arguments;\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\n\t\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\t\n\t\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\t\tvar returned, then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\t\tthen = returned &&\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\t\treturned.then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\n\t\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdeferred = {};\n\t\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\tvar list = tuple[ 2 ],\n\t\t\t\t\tstateString = tuple[ 5 ];\n\t\n\t\t\t\t// promise.progress = list.add\n\t\t\t\t// promise.done = list.add\n\t\t\t\t// promise.fail = list.add\n\t\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\t\n\t\t\t\t// Handle state\n\t\t\t\tif ( stateString ) {\n\t\t\t\t\tlist.add(\n\t\t\t\t\t\tfunction() {\n\t\n\t\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\t\n\t\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// progress_handlers.fire\n\t\t\t\t// fulfilled_handlers.fire\n\t\t\t\t// rejected_handlers.fire\n\t\t\t\tlist.add( tuple[ 3 ].fire );\n\t\n\t\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\n\t\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t\t} );\n\t\n\t\t\t// Make the deferred a promise\n\t\t\tpromise.promise( deferred );\n\t\n\t\t\t// Call given func if any\n\t\t\tif ( func ) {\n\t\t\t\tfunc.call( deferred, deferred );\n\t\t\t}\n\t\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\t\n\t\t// Deferred helper\n\t\twhen: function( singleValue ) {\n\t\t\tvar\n\t\n\t\t\t\t// count of uncompleted subordinates\n\t\t\t\tremaining = arguments.length,\n\t\n\t\t\t\t// count of unprocessed arguments\n\t\t\t\ti = remaining,\n\t\n\t\t\t\t// subordinate fulfillment data\n\t\t\t\tresolveContexts = Array( i ),\n\t\t\t\tresolveValues = slice.call( arguments ),\n\t\n\t\t\t\t// the master Deferred\n\t\t\t\tmaster = jQuery.Deferred(),\n\t\n\t\t\t\t// subordinate callback factory\n\t\t\t\tupdateFunc = function( i ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\n\t\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\t\tif ( remaining <= 1 ) {\n\t\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\t\n\t\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\t\n\t\t\t\t\treturn master.then();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\t\twhile ( i-- ) {\n\t\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t\t}\n\t\n\t\t\treturn master.promise();\n\t\t}\n\t} );\n\t\n\t\n\t// These usually indicate a programmer mistake during development,\n\t// warn about them ASAP rather than swallowing them by default.\n\tvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\t\n\tjQuery.Deferred.exceptionHook = function( error, stack ) {\n\t\n\t\t// Support: IE 8 - 9 only\n\t\t// Console exists when dev tools are open, which can happen at any time\n\t\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t\t}\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.readyException = function( error ) {\n\t\twindow.setTimeout( function() {\n\t\t\tthrow error;\n\t\t} );\n\t};\n\t\n\t\n\t\n\t\n\t// The deferred used on DOM ready\n\tvar readyList = jQuery.Deferred();\n\t\n\tjQuery.fn.ready = function( fn ) {\n\t\n\t\treadyList\n\t\t\t.then( fn )\n\t\n\t\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t\t// happens at the time of error handling instead of callback\n\t\t\t// registration.\n\t\t\t.catch( function( error ) {\n\t\t\t\tjQuery.readyException( error );\n\t\t\t} );\n\t\n\t\treturn this;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\t\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\t\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function( hold ) {\n\t\t\tif ( hold ) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready( true );\n\t\t\t}\n\t\t},\n\t\n\t\t// Handle when the DOM is ready\n\t\tready: function( wait ) {\n\t\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\t\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\t\t}\n\t} );\n\t\n\tjQuery.ready.then = readyList.then;\n\t\n\t// The ready event handler and self cleanup method\n\tfunction completed() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\t\twindow.removeEventListener( \"load\", completed );\n\t\tjQuery.ready();\n\t}\n\t\n\t// Catch cases where $(document).ready() is called\n\t// after the browser event has already occurred.\n\t// Support: IE <=9 - 10 only\n\t// Older IE sometimes signals \"interactive\" too soon\n\tif ( document.readyState === \"complete\" ||\n\t\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\t\n\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\twindow.setTimeout( jQuery.ready );\n\t\n\t} else {\n\t\n\t\t// Use the handy event callback\n\t\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\t\n\t\t// A fallback to window.onload, that will always work\n\t\twindow.addEventListener( \"load\", completed );\n\t}\n\t\n\t\n\t\n\t\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlen = elems.length,\n\t\t\tbulk = key == null;\n\t\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t\t}\n\t\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\t\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\t\n\t\t\tif ( bulk ) {\n\t\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\t\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tfn(\n\t\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( chainable ) {\n\t\t\treturn elems;\n\t\t}\n\t\n\t\t// Gets\n\t\tif ( bulk ) {\n\t\t\treturn fn.call( elems );\n\t\t}\n\t\n\t\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n\t};\n\tvar acceptData = function( owner ) {\n\t\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n\t};\n\t\n\t\n\t\n\t\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\t\n\tData.uid = 1;\n\t\n\tData.prototype = {\n\t\n\t\tcache: function( owner ) {\n\t\n\t\t\t// Check if the owner object already has a cache\n\t\t\tvar value = owner[ this.expando ];\n\t\n\t\t\t// If not, create one\n\t\t\tif ( !value ) {\n\t\t\t\tvalue = {};\n\t\n\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\t\t\t\tif ( acceptData( owner ) ) {\n\t\n\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t// use plain assignment\n\t\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\t\towner[ this.expando ] = value;\n\t\n\t\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn value;\n\t\t},\n\t\tset: function( owner, data, value ) {\n\t\t\tvar prop,\n\t\t\t\tcache = this.cache( owner );\n\t\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\t\n\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\n\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function( owner, key ) {\n\t\t\treturn key === undefined ?\n\t\t\t\tthis.cache( owner ) :\n\t\n\t\t\t\t// Always use camelCase key (gh-2257)\n\t\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t\t},\n\t\taccess: function( owner, key, value ) {\n\t\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif ( key === undefined ||\n\t\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\t\n\t\t\t\treturn this.get( owner, key );\n\t\t\t}\n\t\n\t\t\t// When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set( owner, key, value );\n\t\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function( owner, key ) {\n\t\t\tvar i,\n\t\t\t\tcache = owner[ this.expando ];\n\t\n\t\t\tif ( cache === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( key !== undefined ) {\n\t\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif ( jQuery.isArray( key ) ) {\n\t\n\t\t\t\t\t// If key is an array of keys...\n\t\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t\t} else {\n\t\t\t\t\tkey = jQuery.camelCase( key );\n\t\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tkey = key in cache ?\n\t\t\t\t\t\t[ key ] :\n\t\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t\t}\n\t\n\t\t\t\ti = key.length;\n\t\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove the expando if there's no more data\n\t\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\t\n\t\t\t\t// Support: Chrome <=35 - 45\n\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdelete owner[ this.expando ];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function( owner ) {\n\t\t\tvar cache = owner[ this.expando ];\n\t\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t\t}\n\t};\n\tvar dataPriv = new Data();\n\t\n\tvar dataUser = new Data();\n\t\n\t\n\t\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\t\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t\trmultiDash = /[A-Z]/g;\n\t\n\tfunction getData( data ) {\n\t\tif ( data === \"true\" ) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif ( data === \"false\" ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif ( data === \"null\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Only convert to a number if it doesn't change the string\n\t\tif ( data === +data + \"\" ) {\n\t\t\treturn +data;\n\t\t}\n\t\n\t\tif ( rbrace.test( data ) ) {\n\t\t\treturn JSON.parse( data );\n\t\t}\n\t\n\t\treturn data;\n\t}\n\t\n\tfunction dataAttr( elem, key, data ) {\n\t\tvar name;\n\t\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\t\tdata = elem.getAttribute( name );\n\t\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = getData( data );\n\t\t\t\t} catch ( e ) {}\n\t\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdataUser.set( elem, key, data );\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\t\n\tjQuery.extend( {\n\t\thasData: function( elem ) {\n\t\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t\t},\n\t\n\t\tdata: function( elem, name, data ) {\n\t\t\treturn dataUser.access( elem, name, data );\n\t\t},\n\t\n\t\tremoveData: function( elem, name ) {\n\t\t\tdataUser.remove( elem, name );\n\t\t},\n\t\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to dataPriv methods, these can be deprecated.\n\t\t_data: function( elem, name, data ) {\n\t\t\treturn dataPriv.access( elem, name, data );\n\t\t},\n\t\n\t\t_removeData: function( elem, name ) {\n\t\t\tdataPriv.remove( elem, name );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdata: function( key, value ) {\n\t\t\tvar i, name, data,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tattrs = elem && elem.attributes;\n\t\n\t\t\t// Gets all values\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( this.length ) {\n\t\t\t\t\tdata = dataUser.get( elem );\n\t\n\t\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\n\t\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\t\t}\n\t\n\t\t\t// Sets multiple values\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\treturn this.each( function() {\n\t\t\t\t\tdataUser.set( this, key );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar data;\n\t\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif ( elem && value === undefined ) {\n\t\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each( function() {\n\t\n\t\t\t\t\t// We always store the camelCased key\n\t\t\t\t\tdataUser.set( this, key, value );\n\t\t\t\t} );\n\t\t\t}, null, value, arguments.length > 1, null, true );\n\t\t},\n\t\n\t\tremoveData: function( key ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.remove( this, key );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.extend( {\n\t\tqueue: function( elem, type, data ) {\n\t\t\tvar queue;\n\t\n\t\t\tif ( elem ) {\n\t\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\t\tqueue = dataPriv.get( elem, type );\n\t\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\t\n\t\tdequeue: function( elem, type ) {\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\t\tstartLength = queue.length,\n\t\t\t\tfn = queue.shift(),\n\t\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\t\tnext = function() {\n\t\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t\t};\n\t\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif ( fn === \"inprogress\" ) {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif ( type === \"fx\" ) {\n\t\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call( elem, next, hooks );\n\t\t\t}\n\t\n\t\t\tif ( !startLength && hooks ) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\t\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function( elem, type ) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t\t} )\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tqueue: function( type, data ) {\n\t\t\tvar setter = 2;\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\t\n\t\t\tif ( arguments.length < setter ) {\n\t\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t\t}\n\t\n\t\t\treturn data === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function() {\n\t\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\t\n\t\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\t\tjQuery._queueHooks( this, type );\n\t\n\t\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t},\n\t\tdequeue: function( type ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t} );\n\t\t},\n\t\tclearQueue: function( type ) {\n\t\t\treturn this.queue( type || \"fx\", [] );\n\t\t},\n\t\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function( type, obj ) {\n\t\t\tvar tmp,\n\t\t\t\tcount = 1,\n\t\t\t\tdefer = jQuery.Deferred(),\n\t\t\t\telements = this,\n\t\t\t\ti = this.length,\n\t\t\t\tresolve = function() {\n\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise( obj );\n\t\t}\n\t} );\n\tvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\t\n\tvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\t\n\t\n\tvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\t\n\tvar isHiddenWithinTree = function( elem, el ) {\n\t\n\t\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t\t// in that case, element will be second argument\n\t\t\telem = el || elem;\n\t\n\t\t\t// Inline style trumps all\n\t\t\treturn elem.style.display === \"none\" ||\n\t\t\t\telem.style.display === \"\" &&\n\t\n\t\t\t\t// Otherwise, check computed style\n\t\t\t\t// Support: Firefox <=43 - 45\n\t\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t\t// in the document.\n\t\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\t\n\t\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t\t};\n\t\n\tvar swap = function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\t\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\t\n\t\tret = callback.apply( elem, args || [] );\n\t\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\t\n\t\n\t\n\tfunction adjustCSS( elem, prop, valueParts, tween ) {\n\t\tvar adjusted,\n\t\t\tscale = 1,\n\t\t\tmaxIterations = 20,\n\t\t\tcurrentValue = tween ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn tween.cur();\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t\t},\n\t\t\tinitial = currentValue(),\n\t\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\t\n\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\t\n\t\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\t\n\t\t\t// Trust units reported by jQuery.css\n\t\t\tunit = unit || initialInUnit[ 3 ];\n\t\n\t\t\t// Make sure we update the tween properties later on\n\t\t\tvalueParts = valueParts || [];\n\t\n\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\tinitialInUnit = +initial || 1;\n\t\n\t\t\tdo {\n\t\n\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\tscale = scale || \".5\";\n\t\n\t\t\t\t// Adjust and apply\n\t\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\n\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t\t} while (\n\t\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t\t);\n\t\t}\n\t\n\t\tif ( valueParts ) {\n\t\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\t\n\t\t\t// Apply relative offset (+=/-=) if specified\n\t\t\tadjusted = valueParts[ 1 ] ?\n\t\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t\t+valueParts[ 2 ];\n\t\t\tif ( tween ) {\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = initialInUnit;\n\t\t\t\ttween.end = adjusted;\n\t\t\t}\n\t\t}\n\t\treturn adjusted;\n\t}\n\t\n\t\n\tvar defaultDisplayMap = {};\n\t\n\tfunction getDefaultDisplay( elem ) {\n\t\tvar temp,\n\t\t\tdoc = elem.ownerDocument,\n\t\t\tnodeName = elem.nodeName,\n\t\t\tdisplay = defaultDisplayMap[ nodeName ];\n\t\n\t\tif ( display ) {\n\t\t\treturn display;\n\t\t}\n\t\n\t\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\t\tdisplay = jQuery.css( temp, \"display\" );\n\t\n\t\ttemp.parentNode.removeChild( temp );\n\t\n\t\tif ( display === \"none\" ) {\n\t\t\tdisplay = \"block\";\n\t\t}\n\t\tdefaultDisplayMap[ nodeName ] = display;\n\t\n\t\treturn display;\n\t}\n\t\n\tfunction showHide( elements, show ) {\n\t\tvar display, elem,\n\t\t\tvalues = [],\n\t\t\tindex = 0,\n\t\t\tlength = elements.length;\n\t\n\t\t// Determine new display value for elements that need to change\n\t\tfor ( ; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tdisplay = elem.style.display;\n\t\t\tif ( show ) {\n\t\n\t\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t\t// inline or about-to-be-restored)\n\t\t\t\tif ( display === \"none\" ) {\n\t\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( display !== \"none\" ) {\n\t\t\t\t\tvalues[ index ] = \"none\";\n\t\n\t\t\t\t\t// Remember what we're overwriting\n\t\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Set the display of the elements in a second loop to avoid constant reflow\n\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\tif ( values[ index ] != null ) {\n\t\t\t\telements[ index ].style.display = values[ index ];\n\t\t\t}\n\t\t}\n\t\n\t\treturn elements;\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\tshow: function() {\n\t\t\treturn showHide( this, true );\n\t\t},\n\t\thide: function() {\n\t\t\treturn showHide( this );\n\t\t},\n\t\ttoggle: function( state ) {\n\t\t\tif ( typeof state === \"boolean\" ) {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\t\tjQuery( this ).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery( this ).hide();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\tvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\t\n\tvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\t\n\tvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\t\n\t\n\t\n\t// We have to close these tags to support XHTML (#13200)\n\tvar wrapMap = {\n\t\n\t\t// Support: IE <=9 only\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\n\t\t// XHTML parsers do not magically insert elements in the\n\t\t// same way that tag soup parsers do. So we cannot shorten\n\t\t// this by omitting <tbody> or other required elements.\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\t\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\t\n\t// Support: IE <=9 only\n\twrapMap.optgroup = wrapMap.option;\n\t\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\t\n\t\n\tfunction getAll( context, tag ) {\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\t\tvar ret;\n\t\n\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\tret = context.getElementsByTagName( tag || \"*\" );\n\t\n\t\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\t\tret = context.querySelectorAll( tag || \"*\" );\n\t\n\t\t} else {\n\t\t\tret = [];\n\t\t}\n\t\n\t\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\t\treturn jQuery.merge( [ context ], ret );\n\t\t}\n\t\n\t\treturn ret;\n\t}\n\t\n\t\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval( elems, refElements ) {\n\t\tvar i = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tdataPriv.set(\n\t\t\t\telems[ i ],\n\t\t\t\t\"globalEval\",\n\t\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t\t);\n\t\t}\n\t}\n\t\n\t\n\tvar rhtml = /<|&#?\\w+;/;\n\t\n\tfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\t\n\t\t\tif ( elem || elem === 0 ) {\n\t\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\t\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\t\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\t\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\t\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\t\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\t\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\t\n\t\ti = 0;\n\t\twhile ( ( elem = nodes[ i++ ] ) ) {\n\t\n\t\t\t// Skip elements already in the context collection (trac-4087)\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\t\tif ( ignored ) {\n\t\t\t\t\tignored.push( elem );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\t\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn fragment;\n\t}\n\t\n\t\n\t( function() {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\t\tinput = document.createElement( \"input\" );\n\t\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute( \"type\", \"radio\" );\n\t\tinput.setAttribute( \"checked\", \"checked\" );\n\t\tinput.setAttribute( \"name\", \"t\" );\n\t\n\t\tdiv.appendChild( input );\n\t\n\t\t// Support: Android <=4.1 only\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\t\n\t\t// Support: IE <=11 only\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\t} )();\n\tvar documentElement = document.documentElement;\n\t\n\t\n\t\n\tvar\n\t\trkeyEvent = /^key/,\n\t\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\t\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\t\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\t\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\t\n\t// Support: IE <=9 only\n\t// See #13393 for more info\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch ( err ) { }\n\t}\n\t\n\tfunction on( elem, types, selector, data, fn, one ) {\n\t\tvar origFn, type;\n\t\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( data == null && fn == null ) {\n\t\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn elem.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t} );\n\t}\n\t\n\t/*\n\t * Helper functions for managing events -- not part of the public interface.\n\t * Props to Dean Edwards' addEvent library for many of the ideas.\n\t */\n\tjQuery.event = {\n\t\n\t\tglobal: {},\n\t\n\t\tadd: function( elem, types, handler, data, selector ) {\n\t\n\t\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.get( elem );\n\t\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif ( !elemData ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif ( handler.handler ) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\t\n\t\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\t\tif ( selector ) {\n\t\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t\t}\n\t\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif ( !handler.guid ) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\t\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif ( !( events = elemData.events ) ) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\t\teventHandle = elemData.handle = function( e ) {\n\t\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend( {\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t\t}, handleObjIn );\n\t\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\t\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif ( !special.setup ||\n\t\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\n\t\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( special.add ) {\n\t\t\t\t\tspecial.add.call( elem, handleObj );\n\t\n\t\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif ( selector ) {\n\t\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push( handleObj );\n\t\t\t\t}\n\t\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[ type ] = true;\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// Detach an event or set of events from an element\n\t\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\n\t\t\tvar j, origCount, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\t\n\t\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tfor ( type in events ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\t\thandlers = events[ type ] || [];\n\t\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\t\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\thandleObj = handlers[ j ];\n\t\n\t\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\t\thandlers.splice( j, 1 );\n\t\n\t\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\n\t\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete events[ type ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove data and the expando if it's no longer used\n\t\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t\t}\n\t\t},\n\t\n\t\tdispatch: function( nativeEvent ) {\n\t\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tvar event = jQuery.event.fix( nativeEvent );\n\t\n\t\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\t\targs = new Array( arguments.length ),\n\t\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\t\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[ 0 ] = event;\n\t\n\t\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\t\targs[ i ] = arguments[ i ];\n\t\t\t}\n\t\n\t\t\tevent.delegateTarget = this;\n\t\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\t\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\t\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\t\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\t\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\t\n\t\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\t\n\t\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif ( special.postDispatch ) {\n\t\t\t\tspecial.postDispatch.call( this, event );\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\thandlers: function( event, handlers ) {\n\t\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\t\thandlerQueue = [],\n\t\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\t\tcur = event.target;\n\t\n\t\t\t// Find delegate handlers\n\t\t\tif ( delegateCount &&\n\t\n\t\t\t\t// Support: IE <=9\n\t\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\t\tcur.nodeType &&\n\t\n\t\t\t\t// Support: Firefox <=42\n\t\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t\t// Support: IE 11 only\n\t\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\t\n\t\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\t\n\t\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\t\thandleObj = handlers[ i ];\n\t\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\t\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tcur = this;\n\t\t\tif ( delegateCount < handlers.length ) {\n\t\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t\t}\n\t\n\t\t\treturn handlerQueue;\n\t\t},\n\t\n\t\taddProp: function( name, hook ) {\n\t\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\n\t\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t\t}\n\t\t\t\t\t} :\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\n\t\t\t\tset: function( value ) {\n\t\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tfix: function( originalEvent ) {\n\t\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\t\toriginalEvent :\n\t\t\t\tnew jQuery.Event( originalEvent );\n\t\t},\n\t\n\t\tspecial: {\n\t\t\tload: {\n\t\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function( event ) {\n\t\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function( event ) {\n\t\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.removeEvent = function( elem, type, handle ) {\n\t\n\t\t// This \"if\" is needed for plain objects\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle );\n\t\t}\n\t};\n\t\n\tjQuery.Event = function( src, props ) {\n\t\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif ( !( this instanceof jQuery.Event ) ) {\n\t\t\treturn new jQuery.Event( src, props );\n\t\t}\n\t\n\t\t// Event object\n\t\tif ( src && src.type ) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\t\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\n\t\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\t\tsrc.returnValue === false ?\n\t\t\t\treturnTrue :\n\t\t\t\treturnFalse;\n\t\n\t\t\t// Create target properties\n\t\t\t// Support: Safari <=6 - 7 only\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\t\tsrc.target.parentNode :\n\t\t\t\tsrc.target;\n\t\n\t\t\tthis.currentTarget = src.currentTarget;\n\t\t\tthis.relatedTarget = src.relatedTarget;\n\t\n\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\t\n\t\t// Put explicitly provided properties onto the event object\n\t\tif ( props ) {\n\t\t\tjQuery.extend( this, props );\n\t\t}\n\t\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\t\n\t\t// Mark it as fixed\n\t\tthis[ jQuery.expando ] = true;\n\t};\n\t\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tconstructor: jQuery.Event,\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\t\tisSimulated: false,\n\t\n\t\tpreventDefault: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isPropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\t\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\tjQuery.each( {\n\t\taltKey: true,\n\t\tbubbles: true,\n\t\tcancelable: true,\n\t\tchangedTouches: true,\n\t\tctrlKey: true,\n\t\tdetail: true,\n\t\teventPhase: true,\n\t\tmetaKey: true,\n\t\tpageX: true,\n\t\tpageY: true,\n\t\tshiftKey: true,\n\t\tview: true,\n\t\t\"char\": true,\n\t\tcharCode: true,\n\t\tkey: true,\n\t\tkeyCode: true,\n\t\tbutton: true,\n\t\tbuttons: true,\n\t\tclientX: true,\n\t\tclientY: true,\n\t\toffsetX: true,\n\t\toffsetY: true,\n\t\tpointerId: true,\n\t\tpointerType: true,\n\t\tscreenX: true,\n\t\tscreenY: true,\n\t\ttargetTouches: true,\n\t\ttoElement: true,\n\t\ttouches: true,\n\t\n\t\twhich: function( event ) {\n\t\t\tvar button = event.button;\n\t\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t\t}\n\t\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\t\tif ( button & 1 ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 2 ) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 4 ) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\treturn event.which;\n\t\t}\n\t}, jQuery.event.addProp );\n\t\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in jQuery.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t//\n\t// Support: Safari 7 only\n\t// Safari sends mouseenter too often; see:\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n\t// for the description of the bug (it existed in older Chrome versions as well).\n\tjQuery.each( {\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function( orig, fix ) {\n\t\tjQuery.event.special[ orig ] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\t\n\t\t\thandle: function( event ) {\n\t\t\t\tvar ret,\n\t\t\t\t\ttarget = this,\n\t\t\t\t\trelated = event.relatedTarget,\n\t\t\t\t\thandleObj = event.handleObj;\n\t\n\t\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ton: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn );\n\t\t},\n\t\tone: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn, 1 );\n\t\t},\n\t\toff: function( types, selector, fn ) {\n\t\t\tvar handleObj, type;\n\t\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\t\thandleObj.namespace ?\n\t\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\t\thandleObj.origType,\n\t\t\t\t\thandleObj.selector,\n\t\t\t\t\thandleObj.handler\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\n\t\t/* eslint-disable max-len */\n\t\n\t\t// See https://github.com/eslint/eslint/issues/3229\n\t\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\t\n\t\t/* eslint-enable */\n\t\n\t\t// Support: IE <=10 - 11, Edge 12 - 13\n\t\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\t\trnoInnerhtml = /<script|<style|<link/i,\n\t\n\t\t// checked=\"checked\" or checked\n\t\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t\trscriptTypeMasked = /^true\\/(.*)/,\n\t\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\t\n\tfunction manipulationTarget( elem, content ) {\n\t\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\t\n\t\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript( elem ) {\n\t\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript( elem ) {\n\t\tvar match = rscriptTypeMasked.exec( elem.type );\n\t\n\t\tif ( match ) {\n\t\t\telem.type = match[ 1 ];\n\t\t} else {\n\t\t\telem.removeAttribute( \"type\" );\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tfunction cloneCopyEvent( src, dest ) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\t\n\t\tif ( dest.nodeType !== 1 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif ( dataPriv.hasData( src ) ) {\n\t\t\tpdataOld = dataPriv.access( src );\n\t\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\t\tevents = pdataOld.events;\n\t\n\t\t\tif ( events ) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\t\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// 2. Copy user data\n\t\tif ( dataUser.hasData( src ) ) {\n\t\t\tudataOld = dataUser.access( src );\n\t\t\tudataCur = jQuery.extend( {}, udataOld );\n\t\n\t\t\tdataUser.set( dest, udataCur );\n\t\t}\n\t}\n\t\n\t// Fix IE bugs, see support tests\n\tfunction fixInput( src, dest ) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\t\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t\tdest.checked = src.checked;\n\t\n\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\t\n\tfunction domManip( collection, args, callback, ignored ) {\n\t\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\t\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = collection.length,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn collection.each( function( index ) {\n\t\t\t\tvar self = collection.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tdomManip( self, args, callback, ignored );\n\t\t\t} );\n\t\t}\n\t\n\t\tif ( l ) {\n\t\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\t\tfirst = fragment.firstChild;\n\t\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\t\n\t\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\t\tif ( first || ignored ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\t\n\t\t\t\t// Use the original fragment for the last item\n\t\t\t\t// instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\t\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\t\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\n\t\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\t\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\t\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\t\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn collection;\n\t}\n\t\n\tfunction remove( elem, selector, keepData ) {\n\t\tvar node,\n\t\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\t\ti = 0;\n\t\n\t\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t\t}\n\t\n\t\t\tif ( node.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t\t}\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tjQuery.extend( {\n\t\thtmlPrefilter: function( html ) {\n\t\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t\t},\n\t\n\t\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\t\tvar i, l, srcElements, destElements,\n\t\t\t\tclone = elem.cloneNode( true ),\n\t\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Fix IE cloning issues\n\t\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll( clone );\n\t\t\t\tsrcElements = getAll( elem );\n\t\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif ( dataAndEvents ) {\n\t\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\t\tdestElements = destElements || getAll( clone );\n\t\n\t\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll( clone, \"script\" );\n\t\t\tif ( destElements.length > 0 ) {\n\t\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t\t}\n\t\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\t\n\t\tcleanData: function( elems ) {\n\t\t\tvar data, elem, type,\n\t\t\t\tspecial = jQuery.event.special,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\t\n\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdetach: function( selector ) {\n\t\t\treturn remove( this, selector, true );\n\t\t},\n\t\n\t\tremove: function( selector ) {\n\t\t\treturn remove( this, selector );\n\t\t},\n\t\n\t\ttext: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\tjQuery.text( this ) :\n\t\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\tappend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.appendChild( elem );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tprepend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tbefore: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tafter: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tempty: function() {\n\t\t\tvar elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\t\n\t\t\treturn this.map( function() {\n\t\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t\t} );\n\t\t},\n\t\n\t\thtml: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\t\ti = 0,\n\t\t\t\t\tl = this.length;\n\t\n\t\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\t\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\t\n\t\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\t\telem = this[ i ] || {};\n\t\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telem = 0;\n\t\n\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch ( e ) {}\n\t\t\t\t}\n\t\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tthis.empty().append( value );\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\treplaceWith: function() {\n\t\t\tvar ignored = [];\n\t\n\t\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tvar parent = this.parentNode;\n\t\n\t\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\t\tif ( parent ) {\n\t\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Force callback invocation\n\t\t\t}, ignored );\n\t\t}\n\t} );\n\t\n\tjQuery.each( {\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar elems,\n\t\t\t\tret = [],\n\t\t\t\tinsert = jQuery( selector ),\n\t\t\t\tlast = insert.length - 1,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; i <= last; i++ ) {\n\t\t\t\telems = i === last ? this : this.clone( true );\n\t\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\t\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tpush.apply( ret, elems.get() );\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t} );\n\tvar rmargin = ( /^margin/ );\n\t\n\tvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\t\n\tvar getStyles = function( elem ) {\n\t\n\t\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t\t// IE throws on elements created in popups\n\t\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\t\tvar view = elem.ownerDocument.defaultView;\n\t\n\t\t\tif ( !view || !view.opener ) {\n\t\t\t\tview = window;\n\t\t\t}\n\t\n\t\t\treturn view.getComputedStyle( elem );\n\t\t};\n\t\n\t\n\t\n\t( function() {\n\t\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computeStyleTests() {\n\t\n\t\t\t// This is a singleton, we need to execute it only once\n\t\t\tif ( !div ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tdiv.style.cssText =\n\t\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\t\"position:relative;display:block;\" +\n\t\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\t\"top:1%;width:50%\";\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdocumentElement.appendChild( container );\n\t\n\t\t\tvar divStyle = window.getComputedStyle( div );\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only\n\t\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\t\tdiv.style.marginRight = \"50%\";\n\t\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\t\n\t\t\tdocumentElement.removeChild( container );\n\t\n\t\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t\t// it will also be a sign that checks already performed\n\t\t\tdiv = null;\n\t\t}\n\t\n\t\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\t\tcontainer = document.createElement( \"div\" ),\n\t\t\tdiv = document.createElement( \"div\" );\n\t\n\t\t// Finish early in limited (non-browser) environments\n\t\tif ( !div.style ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\t\n\t\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\t\"padding:0;margin-top:1px;position:absolute\";\n\t\tcontainer.appendChild( div );\n\t\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\tpixelMarginRight: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelMarginRightVal;\n\t\t\t},\n\t\t\treliableMarginLeft: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn reliableMarginLeftVal;\n\t\t\t}\n\t\t} );\n\t} )();\n\t\n\t\n\tfunction curCSS( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\t\n\t\tcomputed = computed || getStyles( elem );\n\t\n\t\t// Support: IE <=9 only\n\t\t// getPropertyValue is only needed for .css('filter') (#12537)\n\t\tif ( computed ) {\n\t\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\t\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Android Browser returns percentage for some values,\n\t\t\t// but width seems to be reliably pixels.\n\t\t\t// This is against the CSSOM draft spec:\n\t\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\t\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\t\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\t\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret !== undefined ?\n\t\n\t\t\t// Support: IE <=9 - 11 only\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\tret + \"\" :\n\t\t\tret;\n\t}\n\t\n\t\n\tfunction addGetHookIf( conditionFn, hookFn ) {\n\t\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\tif ( conditionFn() ) {\n\t\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t\t}\n\t\t};\n\t}\n\t\n\t\n\tvar\n\t\n\t\t// Swappable if display is none or starts with table\n\t\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\t\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t\tcssNormalTransform = {\n\t\t\tletterSpacing: \"0\",\n\t\t\tfontWeight: \"400\"\n\t\t},\n\t\n\t\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\t\temptyStyle = document.createElement( \"div\" ).style;\n\t\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName( name ) {\n\t\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\t\ti = cssPrefixes.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tname = cssPrefixes[ i ] + capName;\n\t\t\tif ( name in emptyStyle ) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction setPositiveNumber( elem, value, subtract ) {\n\t\n\t\t// Any relative (+/-) values have already been\n\t\t// normalized at this point\n\t\tvar matches = rcssNum.exec( value );\n\t\treturn matches ?\n\t\n\t\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\t\tvalue;\n\t}\n\t\n\tfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\t\tvar i,\n\t\t\tval = 0;\n\t\n\t\t// If we already have the right measurement, avoid augmentation\n\t\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\t\ti = 4;\n\t\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t} else {\n\t\t\ti = name === \"width\" ? 1 : 0;\n\t\t}\n\t\n\t\tfor ( ; i < 4; i += 2 ) {\n\t\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t\t}\n\t\n\t\t\tif ( isBorderBox ) {\n\t\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif ( extra === \"content\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t\t}\n\t\n\t\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t} else {\n\t\n\t\t\t\t// At this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\n\t\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn val;\n\t}\n\t\n\tfunction getWidthOrHeight( elem, name, extra ) {\n\t\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar val,\n\t\t\tvalueIsBorderBox = true,\n\t\t\tstyles = getStyles( elem ),\n\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a disconnected node\n\t\t// in IE throws an error.\n\t\tif ( elem.getClientRects().length ) {\n\t\t\tval = elem.getBoundingClientRect()[ name ];\n\t\t}\n\t\n\t\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif ( val <= 0 || val == null ) {\n\t\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS( elem, name, styles );\n\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\tval = elem.style[ name ];\n\t\t\t}\n\t\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\t\treturn val;\n\t\t\t}\n\t\n\t\t\t// Check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\t\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat( val ) || 0;\n\t\t}\n\t\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn ( val +\n\t\t\taugmentWidthOrHeight(\n\t\t\t\telem,\n\t\t\t\tname,\n\t\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\t\tvalueIsBorderBox,\n\t\t\t\tstyles\n\t\t\t)\n\t\t) + \"px\";\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"animationIterationCount\": true,\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\t\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t\"float\": \"cssFloat\"\n\t\t},\n\t\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function( elem, name, value, extra ) {\n\t\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret, type, hooks,\n\t\t\t\torigName = jQuery.camelCase( name ),\n\t\t\t\tstyle = elem.style;\n\t\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// Check if we're setting a value\n\t\t\tif ( value !== undefined ) {\n\t\t\t\ttype = typeof value;\n\t\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\t\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\t\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif ( value == null || value !== value ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t\tif ( type === \"number\" ) {\n\t\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t\t}\n\t\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t\t}\n\t\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[ name ];\n\t\t\t}\n\t\t},\n\t\n\t\tcss: function( elem, name, extra, styles ) {\n\t\t\tvar val, num, hooks,\n\t\t\t\torigName = jQuery.camelCase( name );\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\t\tval = hooks.get( elem, true, extra );\n\t\t\t}\n\t\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif ( val === undefined ) {\n\t\t\t\tval = curCSS( elem, name, styles );\n\t\t\t}\n\t\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\t\tval = cssNormalTransform[ name ];\n\t\t\t}\n\t\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif ( extra === \"\" || extra ) {\n\t\t\t\tnum = parseFloat( val );\n\t\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\t\tjQuery.cssHooks[ name ] = {\n\t\t\tget: function( elem, computed, extra ) {\n\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\t\n\t\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t\t} ) :\n\t\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tset: function( elem, value, extra ) {\n\t\t\t\tvar matches,\n\t\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\t\tstyles\n\t\t\t\t\t);\n\t\n\t\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\t\n\t\t\t\t\telem.style[ name ] = value;\n\t\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t\t}\n\t\n\t\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t\t} )\n\t\t\t\t\t) + \"px\";\n\t\t\t}\n\t\t}\n\t);\n\t\n\t// These hooks are used by animate to expand properties\n\tjQuery.each( {\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function( prefix, suffix ) {\n\t\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\t\texpand: function( value ) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\texpanded = {},\n\t\n\t\t\t\t\t// Assumes a single number if not a string\n\t\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\t\n\t\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t\t}\n\t\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\t\n\t\tif ( !rmargin.test( prefix ) ) {\n\t\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tcss: function( name, value ) {\n\t\t\treturn access( this, function( elem, name, value ) {\n\t\t\t\tvar styles, len,\n\t\t\t\t\tmap = {},\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\t\tstyles = getStyles( elem );\n\t\t\t\t\tlen = name.length;\n\t\n\t\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\n\t\t\t\treturn value !== undefined ?\n\t\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\t\tjQuery.css( elem, name );\n\t\t\t}, name, value, arguments.length > 1 );\n\t\t}\n\t} );\n\t\n\t\n\tfunction Tween( elem, options, prop, end, easing ) {\n\t\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\t}\n\tjQuery.Tween = Tween;\n\t\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || jQuery.easing._default;\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t\t},\n\t\tcur: function() {\n\t\t\tvar hooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\treturn hooks && hooks.get ?\n\t\t\t\thooks.get( this ) :\n\t\t\t\tTween.propHooks._default.get( this );\n\t\t},\n\t\trun: function( percent ) {\n\t\t\tvar eased,\n\t\t\t\thooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\tif ( this.options.duration ) {\n\t\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\t\n\t\t\tif ( this.options.step ) {\n\t\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t\t}\n\t\n\t\t\tif ( hooks && hooks.set ) {\n\t\t\t\thooks.set( this );\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set( this );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\t\n\tTween.prototype.init.prototype = Tween.prototype;\n\t\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function( tween ) {\n\t\t\t\tvar result;\n\t\n\t\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t\t// or when there is no matching style property that exists.\n\t\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t\t}\n\t\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function( tween ) {\n\t\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// Support: IE <=9 only\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function( tween ) {\n\t\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.easing = {\n\t\tlinear: function( p ) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function( p ) {\n\t\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t\t},\n\t\t_default: \"swing\"\n\t};\n\t\n\tjQuery.fx = Tween.prototype.init;\n\t\n\t// Back compat <1.8 extension point\n\tjQuery.fx.step = {};\n\t\n\t\n\t\n\t\n\tvar\n\t\tfxNow, timerId,\n\t\trfxtypes = /^(?:toggle|show|hide)$/,\n\t\trrun = /queueHooks$/;\n\t\n\tfunction raf() {\n\t\tif ( timerId ) {\n\t\t\twindow.requestAnimationFrame( raf );\n\t\t\tjQuery.fx.tick();\n\t\t}\n\t}\n\t\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\twindow.setTimeout( function() {\n\t\t\tfxNow = undefined;\n\t\t} );\n\t\treturn ( fxNow = jQuery.now() );\n\t}\n\t\n\t// Generate parameters to create a standard animation\n\tfunction genFx( type, includeWidth ) {\n\t\tvar which,\n\t\t\ti = 0,\n\t\t\tattrs = { height: type };\n\t\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\t\twhich = cssExpand[ i ];\n\t\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t\t}\n\t\n\t\tif ( includeWidth ) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\t\n\t\treturn attrs;\n\t}\n\t\n\tfunction createTween( value, prop, animation ) {\n\t\tvar tween,\n\t\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\t\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction defaultPrefilter( elem, props, opts ) {\n\t\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\t\tisBox = \"width\" in props || \"height\" in props,\n\t\t\tanim = this,\n\t\t\torig = {},\n\t\t\tstyle = elem.style,\n\t\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\t\n\t\t// Queue-skipping animations hijack the fx hooks\n\t\tif ( !opts.queue ) {\n\t\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\t\tif ( hooks.unqueued == null ) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function() {\n\t\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\t\n\t\t\tanim.always( function() {\n\t\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always( function() {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\t// Detect show/hide animations\n\t\tfor ( prop in props ) {\n\t\t\tvalue = props[ prop ];\n\t\t\tif ( rfxtypes.test( value ) ) {\n\t\t\t\tdelete props[ prop ];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\n\t\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\t\thidden = true;\n\t\n\t\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t\t}\n\t\t}\n\t\n\t\t// Bail out if this is a no-op like .hide().hide()\n\t\tpropTween = !jQuery.isEmptyObject( props );\n\t\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Restrict \"overflow\" and \"display\" styles during box animations\n\t\tif ( isBox && elem.nodeType === 1 ) {\n\t\n\t\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t\t// from identically-valued overflowX and overflowY\n\t\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\t\n\t\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\t\trestoreDisplay = dataShow && dataShow.display;\n\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t\t}\n\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tif ( restoreDisplay ) {\n\t\t\t\t\tdisplay = restoreDisplay;\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Animate inline elements as inline-block\n\t\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\n\t\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\t\tif ( !propTween ) {\n\t\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( opts.overflow ) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always( function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t} );\n\t\t}\n\t\n\t\t// Implement show/hide animations\n\t\tpropTween = false;\n\t\tfor ( prop in orig ) {\n\t\n\t\t\t// General show/hide setup for this element animation\n\t\t\tif ( !propTween ) {\n\t\t\t\tif ( dataShow ) {\n\t\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t\t}\n\t\n\t\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\t\tif ( toggle ) {\n\t\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t\t}\n\t\n\t\t\t\t// Show elements before animating them\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t}\n\t\n\t\t\t\t/* eslint-disable no-loop-func */\n\t\n\t\t\t\tanim.done( function() {\n\t\n\t\t\t\t/* eslint-enable no-loop-func */\n\t\n\t\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\t\tif ( !hidden ) {\n\t\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\t// Per-property setup\n\t\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\t\tpropTween.start = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction propFilter( props, specialEasing ) {\n\t\tvar index, name, easing, value, hooks;\n\t\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor ( index in props ) {\n\t\t\tname = jQuery.camelCase( index );\n\t\t\teasing = specialEasing[ name ];\n\t\t\tvalue = props[ index ];\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\teasing = value[ 1 ];\n\t\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t\t}\n\t\n\t\t\tif ( index !== name ) {\n\t\t\t\tprops[ name ] = value;\n\t\t\t\tdelete props[ index ];\n\t\t\t}\n\t\n\t\t\thooks = jQuery.cssHooks[ name ];\n\t\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\t\tvalue = hooks.expand( value );\n\t\t\t\tdelete props[ name ];\n\t\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor ( index in value ) {\n\t\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[ name ] = easing;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction Animation( elem, properties, options ) {\n\t\tvar result,\n\t\t\tstopped,\n\t\t\tindex = 0,\n\t\t\tlength = Animation.prefilters.length,\n\t\t\tdeferred = jQuery.Deferred().always( function() {\n\t\n\t\t\t\t// Don't match elem in the :animated selector\n\t\t\t\tdelete tick.elem;\n\t\t\t} ),\n\t\t\ttick = function() {\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\n\t\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\t\tpercent = 1 - temp,\n\t\t\t\t\tindex = 0,\n\t\t\t\t\tlength = animation.tweens.length;\n\t\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t\t}\n\t\n\t\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\t\n\t\t\t\tif ( percent < 1 && length ) {\n\t\t\t\t\treturn remaining;\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = deferred.promise( {\n\t\t\t\telem: elem,\n\t\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\t\topts: jQuery.extend( true, {\n\t\t\t\t\tspecialEasing: {},\n\t\t\t\t\teasing: jQuery.easing._default\n\t\t\t\t}, options ),\n\t\t\t\toriginalProperties: properties,\n\t\t\t\toriginalOptions: options,\n\t\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\t\tduration: options.duration,\n\t\t\t\ttweens: [],\n\t\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\t\treturn tween;\n\t\t\t\t},\n\t\t\t\tstop: function( gotoEnd ) {\n\t\t\t\t\tvar index = 0,\n\t\n\t\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\t\tif ( stopped ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tstopped = true;\n\t\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} ),\n\t\t\tprops = animation.props;\n\t\n\t\tpropFilter( props, animation.opts.specialEasing );\n\t\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\t\tif ( result ) {\n\t\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\n\t\tjQuery.map( props, createTween, animation );\n\t\n\t\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\t\tanimation.opts.start.call( elem, animation );\n\t\t}\n\t\n\t\tjQuery.fx.timer(\n\t\t\tjQuery.extend( tick, {\n\t\t\t\telem: elem,\n\t\t\t\tanim: animation,\n\t\t\t\tqueue: animation.opts.queue\n\t\t\t} )\n\t\t);\n\t\n\t\t// attach callbacks from options\n\t\treturn animation.progress( animation.opts.progress )\n\t\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t\t.fail( animation.opts.fail )\n\t\t\t.always( animation.opts.always );\n\t}\n\t\n\tjQuery.Animation = jQuery.extend( Animation, {\n\t\n\t\ttweeners: {\n\t\t\t\"*\": [ function( prop, value ) {\n\t\t\t\tvar tween = this.createTween( prop, value );\n\t\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\t\treturn tween;\n\t\t\t} ]\n\t\t},\n\t\n\t\ttweener: function( props, callback ) {\n\t\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [ \"*\" ];\n\t\t\t} else {\n\t\t\t\tprops = props.match( rnothtmlwhite );\n\t\t\t}\n\t\n\t\t\tvar prop,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = props.length;\n\t\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tprop = props[ index ];\n\t\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t\t}\n\t\t},\n\t\n\t\tprefilters: [ defaultPrefilter ],\n\t\n\t\tprefilter: function( callback, prepend ) {\n\t\t\tif ( prepend ) {\n\t\t\t\tAnimation.prefilters.unshift( callback );\n\t\t\t} else {\n\t\t\t\tAnimation.prefilters.push( callback );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.speed = function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t\t};\n\t\n\t\t// Go to the end state if fx are off or if document is hidden\n\t\tif ( jQuery.fx.off || document.hidden ) {\n\t\t\topt.duration = 0;\n\t\n\t\t} else {\n\t\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif ( opt.queue == null || opt.queue === true ) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\t\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\n\t\topt.complete = function() {\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\t\n\t\t\tif ( opt.queue ) {\n\t\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t\t}\n\t\t};\n\t\n\t\treturn opt;\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfadeTo: function( speed, to, easing, callback ) {\n\t\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\t\n\t\t\t\t// Animate to the value specified\n\t\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t\t},\n\t\tanimate: function( prop, speed, easing, callback ) {\n\t\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\t\tdoAnimation = function() {\n\t\n\t\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\t\n\t\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\t\tanim.stop( true );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoAnimation.finish = doAnimation;\n\t\n\t\t\treturn empty || optall.queue === false ?\n\t\t\t\tthis.each( doAnimation ) :\n\t\t\t\tthis.queue( optall.queue, doAnimation );\n\t\t},\n\t\tstop: function( type, clearQueue, gotoEnd ) {\n\t\t\tvar stopQueue = function( hooks ) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop( gotoEnd );\n\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif ( clearQueue && type !== false ) {\n\t\t\t\tthis.queue( type || \"fx\", [] );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tdata = dataPriv.get( this );\n\t\n\t\t\t\tif ( index ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( index in data ) {\n\t\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\t\n\t\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\tfinish: function( type ) {\n\t\t\tif ( type !== false ) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tvar index,\n\t\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tlength = queue ? queue.length : 0;\n\t\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\t\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue( this, type, [] );\n\t\n\t\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\t\thooks.stop.call( this, true );\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\t\tvar cssFn = jQuery.fn[ name ];\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\t\tcssFn.apply( this, arguments ) :\n\t\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t\t};\n\t} );\n\t\n\t// Generate shortcuts for custom animations\n\tjQuery.each( {\n\t\tslideDown: genFx( \"show\" ),\n\t\tslideUp: genFx( \"hide\" ),\n\t\tslideToggle: genFx( \"toggle\" ),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function( name, props ) {\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn this.animate( props, speed, easing, callback );\n\t\t};\n\t} );\n\t\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function() {\n\t\tvar timer,\n\t\t\ti = 0,\n\t\t\ttimers = jQuery.timers;\n\t\n\t\tfxNow = jQuery.now();\n\t\n\t\tfor ( ; i < timers.length; i++ ) {\n\t\t\ttimer = timers[ i ];\n\t\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\t\ttimers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\t\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\t\n\tjQuery.fx.timer = function( timer ) {\n\t\tjQuery.timers.push( timer );\n\t\tif ( timer() ) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\t\n\tjQuery.fx.interval = 13;\n\tjQuery.fx.start = function() {\n\t\tif ( !timerId ) {\n\t\t\ttimerId = window.requestAnimationFrame ?\n\t\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t\t}\n\t};\n\t\n\tjQuery.fx.stop = function() {\n\t\tif ( window.cancelAnimationFrame ) {\n\t\t\twindow.cancelAnimationFrame( timerId );\n\t\t} else {\n\t\t\twindow.clearInterval( timerId );\n\t\t}\n\t\n\t\ttimerId = null;\n\t};\n\t\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\t\n\t\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\t\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = window.setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\twindow.clearTimeout( timeout );\n\t\t\t};\n\t\t} );\n\t};\n\t\n\t\n\t( function() {\n\t\tvar input = document.createElement( \"input\" ),\n\t\t\tselect = document.createElement( \"select\" ),\n\t\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\t\n\t\tinput.type = \"checkbox\";\n\t\n\t\t// Support: Android <=4.3 only\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\t\n\t\t// Support: IE <=11 only\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t} )();\n\t\n\t\n\tvar boolHook,\n\t\tattrHandle = jQuery.expr.attrHandle;\n\t\n\tjQuery.fn.extend( {\n\t\tattr: function( name, value ) {\n\t\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveAttr: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.removeAttr( this, name );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tattr: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\t\treturn jQuery.prop( elem, name, value );\n\t\t\t}\n\t\n\t\t\t// Attribute hooks are determined by the lowercase version\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\tret = jQuery.find.attr( elem, name );\n\t\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ? undefined : ret;\n\t\t},\n\t\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tremoveAttr: function( elem, value ) {\n\t\t\tvar name,\n\t\t\t\ti = 0,\n\t\n\t\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\t\n\t\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\t\telem.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === false ) {\n\t\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, name );\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\t\n\tjQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\t\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\t\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tvar ret, handle,\n\t\t\t\tlowercaseName = name.toLowerCase();\n\t\n\t\t\tif ( !isXML ) {\n\t\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tlowercaseName :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\t\trclickable = /^(?:a|area)$/i;\n\t\n\tjQuery.fn.extend( {\n\t\tprop: function( name, value ) {\n\t\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveProp: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tprop: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\t\thooks = jQuery.propHooks[ name ];\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn ( elem[ name ] = value );\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\treturn elem[ name ];\n\t\t},\n\t\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\t\n\t\t\t\t\tif ( tabindex ) {\n\t\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (\n\t\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\t\telem.href\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t}\n\t} );\n\t\n\t// Support: IE <=11 only\n\t// Accessing the selectedIndex property\n\t// forces the browser to respect setting selected\n\t// on the option\n\t// The getter ensures a default option is selected\n\t// when in an optgroup\n\t// eslint rule \"no-unused-expressions\" is disabled for this code\n\t// since it considers such accessions noop\n\tif ( !support.optSelected ) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tset: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.selectedIndex;\n\t\n\t\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tjQuery.each( [\n\t\t\"tabIndex\",\n\t\t\"readOnly\",\n\t\t\"maxLength\",\n\t\t\"cellSpacing\",\n\t\t\"cellPadding\",\n\t\t\"rowSpan\",\n\t\t\"colSpan\",\n\t\t\"useMap\",\n\t\t\"frameBorder\",\n\t\t\"contentEditable\"\n\t], function() {\n\t\tjQuery.propFix[ this.toLowerCase() ] = this;\n\t} );\n\t\n\t\n\t\n\t\n\t\t// Strip and collapse whitespace according to HTML spec\n\t\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\t\tfunction stripAndCollapse( value ) {\n\t\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\t\treturn tokens.join( \" \" );\n\t\t}\n\t\n\t\n\tfunction getClass( elem ) {\n\t\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\taddClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\treturn this.attr( \"class\", \"\" );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\ttoggleClass: function( value, stateVal ) {\n\t\t\tvar type = typeof value;\n\t\n\t\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\t\tstateVal\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar className, i, self, classNames;\n\t\n\t\t\t\tif ( type === \"string\" ) {\n\t\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\ti = 0;\n\t\t\t\t\tself = jQuery( this );\n\t\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\t\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\t\tclassName = getClass( this );\n\t\t\t\t\tif ( className ) {\n\t\n\t\t\t\t\t\t// Store className if set\n\t\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\thasClass: function( selector ) {\n\t\t\tvar className, elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tclassName = \" \" + selector + \" \";\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar rreturn = /\\r/g;\n\t\n\tjQuery.fn.extend( {\n\t\tval: function( value ) {\n\t\t\tvar hooks, ret, isFunction,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\t\n\t\t\t\t\tif ( hooks &&\n\t\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tret = elem.value;\n\t\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tvar val;\n\t\n\t\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\t\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\tval = \"\";\n\t\n\t\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\t\tval += \"\";\n\t\n\t\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\t\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\t\treturn val != null ?\n\t\t\t\t\t\tval :\n\t\n\t\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar value, option, i,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\t\tmax = one ? index + 1 : options.length;\n\t\n\t\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\t\ti = max;\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\n\t\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\t\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery( option ).val();\n\t\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\t\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tvar optionSet, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\t\ti = options.length;\n\t\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t/* eslint-disable no-cond-assign */\n\t\n\t\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Radios and checkboxes getter/setter\n\tjQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif ( !support.checkOn ) {\n\t\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Return jQuery for attributes-only inclusion\n\t\n\t\n\tvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\t\n\tjQuery.extend( jQuery.event, {\n\t\n\t\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\n\t\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\t\teventPath = [ elem || document ],\n\t\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\t\n\t\t\tcur = tmp = elem = elem || document;\n\t\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\t\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split( \".\" );\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\t\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[ jQuery.expando ] ?\n\t\t\t\tevent :\n\t\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\t\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join( \".\" );\n\t\t\tevent.rnamespace = event.namespace ?\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\t\tnull;\n\t\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\t\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ?\n\t\t\t\t[ event ] :\n\t\t\t\tjQuery.makeArray( data, [ event ] );\n\t\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\t\teventPath.push( cur );\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\t\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\n\t\t\t\tevent.type = i > 1 ?\n\t\t\t\t\tbubbleType :\n\t\t\t\t\tspecial.bindType || type;\n\t\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.apply( cur, data );\n\t\t\t\t}\n\t\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ ontype ];\n\t\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\t\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\t\n\t\t\t\tif ( ( !special._default ||\n\t\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\t\tacceptData( elem ) ) {\n\t\n\t\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ ontype ];\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\t// Piggyback on a donor event to simulate a different one\n\t\t// Used only for `focus(in | out)` events\n\t\tsimulate: function( type, elem, event ) {\n\t\t\tvar e = jQuery.extend(\n\t\t\t\tnew jQuery.Event(),\n\t\t\t\tevent,\n\t\t\t\t{\n\t\t\t\t\ttype: type,\n\t\t\t\t\tisSimulated: true\n\t\t\t\t}\n\t\t\t);\n\t\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t}\n\t\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ttrigger: function( type, data ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.trigger( type, data, this );\n\t\t\t} );\n\t\t},\n\t\ttriggerHandler: function( type, data ) {\n\t\t\tvar elem = this[ 0 ];\n\t\t\tif ( elem ) {\n\t\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\t\tfunction( i, name ) {\n\t\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\thover: function( fnOver, fnOut ) {\n\t\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tsupport.focusin = \"onfocusin\" in window;\n\t\n\t\n\t// Support: Firefox <=44\n\t// Firefox doesn't have focus(in | out) events\n\t// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n\t//\n\t// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n\t// focus(in | out) events fire after focus & blur events,\n\t// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n\t// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\tif ( !support.focusin ) {\n\t\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\t\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t\t};\n\t\n\t\t\tjQuery.event.special[ fix ] = {\n\t\t\t\tsetup: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\t\tdataPriv.remove( doc, fix );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} );\n\t}\n\tvar location = window.location;\n\t\n\tvar nonce = jQuery.now();\n\t\n\tvar rquery = ( /\\?/ );\n\t\n\t\n\t\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function( data ) {\n\t\tvar xml;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Support: IE 9 - 11 only\n\t\t// IE throws on parseFromString with invalid input.\n\t\ttry {\n\t\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t};\n\t\n\t\n\tvar\n\t\trbracket = /\\[\\]$/,\n\t\trCRLF = /\\r?\\n/g,\n\t\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\tfunction buildParams( prefix, obj, traditional, add ) {\n\t\tvar name;\n\t\n\t\tif ( jQuery.isArray( obj ) ) {\n\t\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each( obj, function( i, v ) {\n\t\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd( prefix, v );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(\n\t\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\t\tv,\n\t\t\t\t\t\ttraditional,\n\t\t\t\t\t\tadd\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\n\t\t\t// Serialize object item.\n\t\t\tfor ( name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\t\n\t\t} else {\n\t\n\t\t\t// Serialize scalar item.\n\t\t\tadd( prefix, obj );\n\t\t}\n\t}\n\t\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function( a, traditional ) {\n\t\tvar prefix,\n\t\t\ts = [],\n\t\t\tadd = function( key, valueOrFunction ) {\n\t\n\t\t\t\t// If value is a function, invoke it and use its return value\n\t\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\t\tvalueOrFunction() :\n\t\t\t\t\tvalueOrFunction;\n\t\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t\t};\n\t\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t} );\n\t\n\t\t} else {\n\t\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tserialize: function() {\n\t\t\treturn jQuery.param( this.serializeArray() );\n\t\t},\n\t\tserializeArray: function() {\n\t\t\treturn this.map( function() {\n\t\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t\t} )\n\t\t\t.filter( function() {\n\t\t\t\tvar type = this.type;\n\t\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t\t} )\n\t\t\t.map( function( i, elem ) {\n\t\t\t\tvar val = jQuery( this ).val();\n\t\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t} ).get();\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\tr20 = /%20/g,\n\t\trhash = /#.*$/,\n\t\trantiCache = /([?&])_=[^&]*/,\n\t\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t\n\t\t// #7653, #8125, #8152: local protocol detection\n\t\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t\trnoContent = /^(?:GET|HEAD)$/,\n\t\trprotocol = /^\\/\\//,\n\t\n\t\t/* Prefilters\n\t\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t\t * 2) These are called:\n\t\t *    - BEFORE asking for a transport\n\t\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t\t * 3) key is the dataType\n\t\t * 4) the catchall symbol \"*\" can be used\n\t\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t\t */\n\t\tprefilters = {},\n\t\n\t\t/* Transports bindings\n\t\t * 1) key is the dataType\n\t\t * 2) the catchall symbol \"*\" can be used\n\t\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t\t */\n\t\ttransports = {},\n\t\n\t\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\t\tallTypes = \"*/\".concat( \"*\" ),\n\t\n\t\t// Anchor tag for parsing the document origin\n\t\toriginAnchor = document.createElement( \"a\" );\n\t\toriginAnchor.href = location.href;\n\t\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports( structure ) {\n\t\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function( dataTypeExpression, func ) {\n\t\n\t\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\t\n\t\t\tvar dataType,\n\t\t\t\ti = 0,\n\t\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\t\n\t\t\tif ( jQuery.isFunction( func ) ) {\n\t\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\t\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\t\n\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\t\n\t\tvar inspected = {},\n\t\t\tseekingTransport = ( structure === transports );\n\t\n\t\tfunction inspect( dataType ) {\n\t\t\tvar selected;\n\t\t\tinspected[ dataType ] = true;\n\t\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\n\t\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\t\treturn false;\n\t\t\t\t} else if ( seekingTransport ) {\n\t\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn selected;\n\t\t}\n\t\n\t\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\t}\n\t\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend( target, src ) {\n\t\tvar key, deep,\n\t\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\t\n\t\tfor ( key in src ) {\n\t\t\tif ( src[ key ] !== undefined ) {\n\t\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t\t}\n\t\t}\n\t\tif ( deep ) {\n\t\t\tjQuery.extend( true, target, deep );\n\t\t}\n\t\n\t\treturn target;\n\t}\n\t\n\t/* Handles responses to an ajax request:\n\t * - finds the right dataType (mediates between content-type and expected dataType)\n\t * - returns the corresponding response\n\t */\n\tfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\t\n\t\tvar ct, type, finalDataType, firstDataType,\n\t\t\tcontents = s.contents,\n\t\t\tdataTypes = s.dataTypes;\n\t\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\t\tdataTypes.shift();\n\t\t\tif ( ct === undefined ) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t\t}\n\t\t}\n\t\n\t\t// Check if we're dealing with a known content-type\n\t\tif ( ct ) {\n\t\t\tfor ( type in contents ) {\n\t\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\t\tdataTypes.unshift( type );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif ( dataTypes[ 0 ] in responses ) {\n\t\t\tfinalDataType = dataTypes[ 0 ];\n\t\t} else {\n\t\n\t\t\t// Try convertible dataTypes\n\t\t\tfor ( type in responses ) {\n\t\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( !firstDataType ) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\t\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif ( finalDataType ) {\n\t\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\t\tdataTypes.unshift( finalDataType );\n\t\t\t}\n\t\t\treturn responses[ finalDataType ];\n\t\t}\n\t}\n\t\n\t/* Chain conversions given the request and the original response\n\t * Also sets the responseXXX fields on the jqXHR instance\n\t */\n\tfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\t\tvar conv2, current, conv, tmp, prev,\n\t\t\tconverters = {},\n\t\n\t\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\t\tdataTypes = s.dataTypes.slice();\n\t\n\t\t// Create converters map with lowercased keys\n\t\tif ( dataTypes[ 1 ] ) {\n\t\t\tfor ( conv in s.converters ) {\n\t\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t\t}\n\t\t}\n\t\n\t\tcurrent = dataTypes.shift();\n\t\n\t\t// Convert to each sequential dataType\n\t\twhile ( current ) {\n\t\n\t\t\tif ( s.responseFields[ current ] ) {\n\t\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t\t}\n\t\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t\t}\n\t\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\t\n\t\t\tif ( current ) {\n\t\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif ( current === \"*\" ) {\n\t\n\t\t\t\t\tcurrent = prev;\n\t\n\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\t\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\t\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif ( !conv ) {\n\t\t\t\t\t\tfor ( conv2 in converters ) {\n\t\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\t\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\t\tif ( conv ) {\n\t\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\t\n\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif ( conv !== true ) {\n\t\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn { state: \"success\", data: response };\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\t\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\t\n\t\tajaxSettings: {\n\t\t\turl: location.href,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\n\t\t\t/*\n\t\t\ttimeout: 0,\n\t\t\tdata: null,\n\t\t\tdataType: null,\n\t\t\tusername: null,\n\t\t\tpassword: null,\n\t\t\tcache: null,\n\t\t\tthrows: false,\n\t\t\ttraditional: false,\n\t\t\theaders: {},\n\t\t\t*/\n\t\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\t\n\t\t\tcontents: {\n\t\t\t\txml: /\\bxml\\b/,\n\t\t\t\thtml: /\\bhtml/,\n\t\t\t\tjson: /\\bjson\\b/\n\t\t\t},\n\t\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\t\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\t\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\t\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\t\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": JSON.parse,\n\t\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\t\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\t\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function( target, settings ) {\n\t\t\treturn settings ?\n\t\n\t\t\t\t// Building a settings object\n\t\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\t\n\t\t\t\t// Extending ajaxSettings\n\t\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t\t},\n\t\n\t\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\t\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\t\n\t\t// Main method\n\t\tajax: function( url, options ) {\n\t\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ( typeof url === \"object\" ) {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\t\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\t\n\t\t\tvar transport,\n\t\n\t\t\t\t// URL without anti-cache param\n\t\t\t\tcacheURL,\n\t\n\t\t\t\t// Response headers\n\t\t\t\tresponseHeadersString,\n\t\t\t\tresponseHeaders,\n\t\n\t\t\t\t// timeout handle\n\t\t\t\ttimeoutTimer,\n\t\n\t\t\t\t// Url cleanup var\n\t\t\t\turlAnchor,\n\t\n\t\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\t\tcompleted,\n\t\n\t\t\t\t// To know if global events are to be dispatched\n\t\t\t\tfireGlobals,\n\t\n\t\t\t\t// Loop variable\n\t\t\t\ti,\n\t\n\t\t\t\t// uncached part of the url\n\t\t\t\tuncached,\n\t\n\t\t\t\t// Create the final options object\n\t\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\n\t\t\t\t// Callbacks context\n\t\t\t\tcallbackContext = s.context || s,\n\t\n\t\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\t\tglobalEventContext = s.context &&\n\t\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\t\tjQuery.event,\n\t\n\t\t\t\t// Deferreds\n\t\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode = s.statusCode || {},\n\t\n\t\t\t\t// Headers (they are sent all at once)\n\t\t\t\trequestHeaders = {},\n\t\t\t\trequestHeadersNames = {},\n\t\n\t\t\t\t// Default abort message\n\t\t\t\tstrAbort = \"canceled\",\n\t\n\t\t\t\t// Fake xhr\n\t\t\t\tjqXHR = {\n\t\t\t\t\treadyState: 0,\n\t\n\t\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Raw string\n\t\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Caches the header\n\t\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Overrides response content-type header\n\t\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Status-dependent callbacks\n\t\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\t\tvar code;\n\t\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\t\tif ( completed ) {\n\t\n\t\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Cancel the request\n\t\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise( jqXHR );\n\t\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\t\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\t\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\t\n\t\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\t\tif ( s.crossDomain == null ) {\n\t\t\t\turlAnchor = document.createElement( \"a\" );\n\t\n\t\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t\t// e.g. http://example.com:80x/\n\t\t\t\ttry {\n\t\t\t\t\turlAnchor.href = s.url;\n\t\n\t\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\t\ts.crossDomain = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Convert data if not already a string\n\t\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t\t}\n\t\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\t\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\t\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\t\n\t\t\t// Watch for a new set of requests\n\t\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t\t}\n\t\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\t\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test( s.type );\n\t\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\t// Remove hash to simplify url manipulation\n\t\t\tcacheURL = s.url.replace( rhash, \"\" );\n\t\n\t\t\t// More options handling for requests with no content\n\t\t\tif ( !s.hasContent ) {\n\t\n\t\t\t\t// Remember the hash so we can put it back\n\t\t\t\tuncached = s.url.slice( cacheURL.length );\n\t\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif ( s.data ) {\n\t\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\t\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\t\n\t\t\t\t// Add or update anti-cache param if needed\n\t\t\t\tif ( s.cache === false ) {\n\t\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t\t}\n\t\n\t\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\t\ts.url = cacheURL + uncached;\n\t\n\t\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t\t} else if ( s.data && s.processData &&\n\t\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t\t}\n\t\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t\t}\n\t\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t\t}\n\t\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\n\t\t\t\t\"Accept\",\n\t\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\t\ts.accepts[ \"*\" ]\n\t\t\t);\n\t\n\t\t\t// Check for headers option\n\t\t\tfor ( i in s.headers ) {\n\t\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t\t}\n\t\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif ( s.beforeSend &&\n\t\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\t\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\t\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\t\n\t\t\t// Install callbacks on deferreds\n\t\t\tcompleteDeferred.add( s.complete );\n\t\t\tjqXHR.done( s.success );\n\t\t\tjqXHR.fail( s.error );\n\t\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\t\n\t\t\t// If no transport, we auto-abort\n\t\t\tif ( !transport ) {\n\t\t\t\tdone( -1, \"No Transport\" );\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\t\n\t\t\t\t// Send global event\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t\t}\n\t\n\t\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn jqXHR;\n\t\t\t\t}\n\t\n\t\t\t\t// Timeout\n\t\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t\t}, s.timeout );\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\tcompleted = false;\n\t\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Propagate others as results\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\t\tstatusText = nativeStatusText;\n\t\n\t\t\t\t// Ignore repeat invocations\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tcompleted = true;\n\t\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif ( timeoutTimer ) {\n\t\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t\t}\n\t\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\t\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\t\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\t\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\t\n\t\t\t\t// Get response data\n\t\t\t\tif ( responses ) {\n\t\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t\t}\n\t\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\t\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif ( isSuccess ) {\n\t\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if no content\n\t\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\t\n\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\t\n\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\t\n\t\t\t\t// Success/Error\n\t\t\t\tif ( isSuccess ) {\n\t\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode( statusCode );\n\t\t\t\tstatusCode = undefined;\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn jqXHR;\n\t\t},\n\t\n\t\tgetJSON: function( url, data, callback ) {\n\t\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t\t},\n\t\n\t\tgetScript: function( url, callback ) {\n\t\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\t\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\n\t\t\t// The url can be an options object (which then must have .url)\n\t\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t\t};\n\t} );\n\t\n\t\n\tjQuery._evalUrl = function( url ) {\n\t\treturn jQuery.ajax( {\n\t\t\turl: url,\n\t\n\t\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tcache: true,\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t} );\n\t};\n\t\n\t\n\tjQuery.fn.extend( {\n\t\twrapAll: function( html ) {\n\t\t\tvar wrap;\n\t\n\t\t\tif ( this[ 0 ] ) {\n\t\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\t\n\t\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\twrap.map( function() {\n\t\t\t\t\tvar elem = this;\n\t\n\t\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn elem;\n\t\t\t\t} ).append( this );\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\twrapInner: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar self = jQuery( this ),\n\t\t\t\t\tcontents = self.contents();\n\t\n\t\t\t\tif ( contents.length ) {\n\t\t\t\t\tcontents.wrapAll( html );\n\t\n\t\t\t\t} else {\n\t\t\t\t\tself.append( html );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\twrap: function( html ) {\n\t\t\tvar isFunction = jQuery.isFunction( html );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t\t} );\n\t\t},\n\t\n\t\tunwrap: function( selector ) {\n\t\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.expr.pseudos.hidden = function( elem ) {\n\t\treturn !jQuery.expr.pseudos.visible( elem );\n\t};\n\tjQuery.expr.pseudos.visible = function( elem ) {\n\t\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.ajaxSettings.xhr = function() {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch ( e ) {}\n\t};\n\t\n\tvar xhrSuccessStatus = {\n\t\n\t\t\t// File protocol always yields status code 0, assume 200\n\t\t\t0: 200,\n\t\n\t\t\t// Support: IE <=9 only\n\t\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t\t1223: 204\n\t\t},\n\t\txhrSupported = jQuery.ajaxSettings.xhr();\n\t\n\tsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\t\n\tjQuery.ajaxTransport( function( options ) {\n\t\tvar callback, errorCallback;\n\t\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr();\n\t\n\t\t\t\t\txhr.open(\n\t\t\t\t\t\toptions.type,\n\t\t\t\t\t\toptions.url,\n\t\t\t\t\t\toptions.async,\n\t\t\t\t\t\toptions.username,\n\t\t\t\t\t\toptions.password\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Callback\n\t\t\t\t\tcallback = function( type ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\t\n\t\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcomplete(\n\t\n\t\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = callback();\n\t\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\t\n\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t\t// to handle uncaught aborts\n\t\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.onreadystatechange = function() {\n\t\n\t\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\t\n\t\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\tcallback = callback( \"abort\" );\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\tjQuery.ajaxPrefilter( function( s ) {\n\t\tif ( s.crossDomain ) {\n\t\t\ts.contents.script = false;\n\t\t}\n\t} );\n\t\n\t// Install script dataType\n\tjQuery.ajaxSetup( {\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /\\b(?:java|ecma)script\\b/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function( text ) {\n\t\t\t\tjQuery.globalEval( text );\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter( \"script\", function( s ) {\n\t\tif ( s.cache === undefined ) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif ( s.crossDomain ) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t} );\n\t\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport( \"script\", function( s ) {\n\t\n\t\t// This transport only deals with cross domain requests\n\t\tif ( s.crossDomain ) {\n\t\t\tvar script, callback;\n\t\t\treturn {\n\t\t\t\tsend: function( _, complete ) {\n\t\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t} ).on(\n\t\t\t\t\t\t\"load error\",\n\t\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t\t},\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar oldCallbacks = [],\n\t\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\t\n\t// Default jsonp settings\n\tjQuery.ajaxSetup( {\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function() {\n\t\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\t\tthis[ callback ] = true;\n\t\t\treturn callback;\n\t\t}\n\t} );\n\t\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\t\n\t\tvar callbackName, overwritten, responseContainer,\n\t\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\t\"url\" :\n\t\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t\t);\n\t\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\t\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\t\ts.jsonpCallback() :\n\t\t\t\ts.jsonpCallback;\n\t\n\t\t\t// Insert callback into url or form data\n\t\t\tif ( jsonProp ) {\n\t\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t\t} else if ( s.jsonp !== false ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\t\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[ \"script json\" ] = function() {\n\t\t\t\tif ( !responseContainer ) {\n\t\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t\t}\n\t\t\t\treturn responseContainer[ 0 ];\n\t\t\t};\n\t\n\t\t\t// Force json dataType\n\t\t\ts.dataTypes[ 0 ] = \"json\";\n\t\n\t\t\t// Install callback\n\t\t\toverwritten = window[ callbackName ];\n\t\t\twindow[ callbackName ] = function() {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\t\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always( function() {\n\t\n\t\t\t\t// If previous value didn't exist - remove it\n\t\t\t\tif ( overwritten === undefined ) {\n\t\t\t\t\tjQuery( window ).removeProp( callbackName );\n\t\n\t\t\t\t// Otherwise restore preexisting value\n\t\t\t\t} else {\n\t\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t\t}\n\t\n\t\t\t\t// Save back as free\n\t\t\t\tif ( s[ callbackName ] ) {\n\t\n\t\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\t\n\t\t\t\t\t// Save the callback name for future use\n\t\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t\t}\n\t\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t} );\n\t\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Support: Safari 8 only\n\t// In Safari 8 documents created via document.implementation.createHTMLDocument\n\t// collapse sibling forms: the second one becomes a child of the first one.\n\t// Because of that, this security measure has to be disabled in Safari 8.\n\t// https://bugs.webkit.org/show_bug.cgi?id=137337\n\tsupport.createHTMLDocument = ( function() {\n\t\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\t\tbody.innerHTML = \"<form></form><form></form>\";\n\t\treturn body.childNodes.length === 2;\n\t} )();\n\t\n\t\n\t// Argument \"data\" should be string of html\n\t// context (optional): If specified, the fragment will be created in this context,\n\t// defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function( data, context, keepScripts ) {\n\t\tif ( typeof data !== \"string\" ) {\n\t\t\treturn [];\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\n\t\tvar base, parsed, scripts;\n\t\n\t\tif ( !context ) {\n\t\n\t\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t\t// by using document.implementation\n\t\t\tif ( support.createHTMLDocument ) {\n\t\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\t\n\t\t\t\t// Set the base href for the created document\n\t\t\t\t// so any parsed elements with URLs\n\t\t\t\t// are based on the document's URL (gh-2965)\n\t\t\t\tbase = context.createElement( \"base\" );\n\t\t\t\tbase.href = document.location.href;\n\t\t\t\tcontext.head.appendChild( base );\n\t\t\t} else {\n\t\t\t\tcontext = document;\n\t\t\t}\n\t\t}\n\t\n\t\tparsed = rsingleTag.exec( data );\n\t\tscripts = !keepScripts && [];\n\t\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t\t}\n\t\n\t\tparsed = buildFragment( [ data ], context, scripts );\n\t\n\t\tif ( scripts && scripts.length ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\t\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t};\n\t\n\t\n\t/**\n\t * Load a url into a page\n\t */\n\tjQuery.fn.load = function( url, params, callback ) {\n\t\tvar selector, type, response,\n\t\t\tself = this,\n\t\t\toff = url.indexOf( \" \" );\n\t\n\t\tif ( off > -1 ) {\n\t\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\t\n\t\t// If it's a function\n\t\tif ( jQuery.isFunction( params ) ) {\n\t\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\t\n\t\t// Otherwise, build a param string\n\t\t} else if ( params && typeof params === \"object\" ) {\n\t\t\ttype = \"POST\";\n\t\t}\n\t\n\t\t// If we have elements to modify, make the request\n\t\tif ( self.length > 0 ) {\n\t\t\tjQuery.ajax( {\n\t\t\t\turl: url,\n\t\n\t\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t\t// Make value of this field explicit since\n\t\t\t\t// user can override it through ajaxSetup method\n\t\t\t\ttype: type || \"GET\",\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t} ).done( function( responseText ) {\n\t\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\t\n\t\t\t\tself.html( selector ?\n\t\n\t\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\t\n\t\t\t\t\t// Otherwise use the full result\n\t\t\t\t\tresponseText );\n\t\n\t\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t\t// but they are ignored because response was set above.\n\t\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\t\tself.each( function() {\n\t\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\t\n\t\n\t\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each( [\n\t\t\"ajaxStart\",\n\t\t\"ajaxStop\",\n\t\t\"ajaxComplete\",\n\t\t\"ajaxError\",\n\t\t\"ajaxSuccess\",\n\t\t\"ajaxSend\"\n\t], function( i, type ) {\n\t\tjQuery.fn[ type ] = function( fn ) {\n\t\t\treturn this.on( type, fn );\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tjQuery.expr.pseudos.animated = function( elem ) {\n\t\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t} ).length;\n\t};\n\t\n\t\n\t\n\t\n\t/**\n\t * Gets a window from an element\n\t */\n\tfunction getWindow( elem ) {\n\t\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n\t}\n\t\n\tjQuery.offset = {\n\t\tsetOffset: function( elem, options, i ) {\n\t\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\t\tcurElem = jQuery( elem ),\n\t\t\t\tprops = {};\n\t\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif ( position === \"static\" ) {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\t\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\t\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif ( calculatePosition ) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( options ) ) {\n\t\n\t\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t\t}\n\t\n\t\t\tif ( options.top != null ) {\n\t\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t\t}\n\t\t\tif ( options.left != null ) {\n\t\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t\t}\n\t\n\t\t\tif ( \"using\" in options ) {\n\t\t\t\toptions.using.call( elem, props );\n\t\n\t\t\t} else {\n\t\t\t\tcurElem.css( props );\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\toffset: function( options ) {\n\t\n\t\t\t// Preserve chaining for setter\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn options === undefined ?\n\t\t\t\t\tthis :\n\t\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tvar docElem, win, rect, doc,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !elem ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Support: IE <=11 only\n\t\t\t// Running getBoundingClientRect on a\n\t\t\t// disconnected node in IE throws an error\n\t\t\tif ( !elem.getClientRects().length ) {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\t\n\t\t\trect = elem.getBoundingClientRect();\n\t\n\t\t\t// Make sure element is not hidden (display: none)\n\t\t\tif ( rect.width || rect.height ) {\n\t\t\t\tdoc = elem.ownerDocument;\n\t\t\t\twin = getWindow( doc );\n\t\t\t\tdocElem = doc.documentElement;\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\t\treturn rect;\n\t\t},\n\t\n\t\tposition: function() {\n\t\t\tif ( !this[ 0 ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar offsetParent, offset,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tparentOffset = { top: 0, left: 0 };\n\t\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t\t// because it is its only offset parent\n\t\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\t\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\t\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset = {\n\t\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t\t};\n\t\t},\n\t\n\t\t// This method will return documentElement in the following cases:\n\t\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t\t//    documentElement of the parent window\n\t\t// 2) For the hidden or detached element\n\t\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t\t//\n\t\t// but those exceptions were never presented as a real life use-cases\n\t\t// and might be considered as more preferable results.\n\t\t//\n\t\t// This logic, however, is not guaranteed and can change at any point in the future\n\t\toffsetParent: function() {\n\t\t\treturn this.map( function() {\n\t\t\t\tvar offsetParent = this.offsetParent;\n\t\n\t\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\t\n\t\t\t\treturn offsetParent || documentElement;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\t\tvar top = \"pageYOffset\" === prop;\n\t\n\t\tjQuery.fn[ method ] = function( val ) {\n\t\t\treturn access( this, function( elem, method, val ) {\n\t\t\t\tvar win = getWindow( elem );\n\t\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t\t}\n\t\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t\t);\n\t\n\t\t\t\t} else {\n\t\t\t\t\telem[ method ] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length );\n\t\t};\n\t} );\n\t\n\t// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\t\tfunction( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\n\t\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\tcomputed;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t} );\n\t\n\t\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\t\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\t\tfunction( defaultExtra, funcName ) {\n\t\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\t\n\t\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\t\tvar doc;\n\t\n\t\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\t\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn value === undefined ?\n\t\n\t\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\t\n\t\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t\t};\n\t\t} );\n\t} );\n\t\n\t\n\tjQuery.fn.extend( {\n\t\n\t\tbind: function( types, data, fn ) {\n\t\t\treturn this.on( types, null, data, fn );\n\t\t},\n\t\tunbind: function( types, fn ) {\n\t\t\treturn this.off( types, null, fn );\n\t\t},\n\t\n\t\tdelegate: function( selector, types, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn );\n\t\t},\n\t\tundelegate: function( selector, types, fn ) {\n\t\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ?\n\t\t\t\tthis.off( selector, \"**\" ) :\n\t\t\t\tthis.off( types, selector || \"**\", fn );\n\t\t}\n\t} );\n\t\n\tjQuery.parseJSON = JSON.parse;\n\t\n\t\n\t\n\t\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\t\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\t\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t\n\t\n\t\n\t\n\tvar\n\t\n\t\t// Map over jQuery in case of overwrite\n\t\t_jQuery = window.jQuery,\n\t\n\t\t// Map over the $ in case of overwrite\n\t\t_$ = window.$;\n\t\n\tjQuery.noConflict = function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\t\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\t\n\t\treturn jQuery;\n\t};\n\t\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ( !noGlobal ) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\t\n\t\n\t\n\t\n\t\n\treturn jQuery;\n\t} );\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":[{\"t\":2,\"r\":\"css.main\"}],\"t\":13}],\"f\":[{\"t\":7,\"e\":\"SortableDragList\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"css.insertAfter\"],\"s\":\"_0==\\\"list1\\\"?_1:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":\"list1\",\"t\":13}],\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"SortableDragItem\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"key\",\"css.insertBefore\"],\"s\":\"_0==_1?_2:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":[{\"t\":2,\"r\":\"key\"}],\"t\":13}],\"f\":[{\"t\":2,\"r\":\"value\"}]}],\"r\":\"list1\"}]},\" \",{\"t\":7,\"e\":\"SortableDragList\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"css.insertAfter\"],\"s\":\"_0==\\\"list2\\\"?_1:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":\"list2\",\"t\":13}],\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"SortableDragItem\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"key\",\"css.insertBefore\"],\"s\":\"_0==_1?_2:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":[{\"t\":2,\"r\":\"key\"}],\"t\":13}],\"f\":[{\"t\":2,\"r\":\"value\"}]}],\"r\":\"list2\"}]}]}],\"e\":{}};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"li\",\"m\":[{\"n\":\"dragstart\",\"f\":\"dragStart\",\"t\":70},{\"n\":\"dragend\",\"f\":\"dragEnd\",\"t\":70},{\"n\":\"draggable\",\"f\":\"true\",\"t\":13},{\"n\":\"class\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"css.sortableDragItem\",\"isDragging\",\"css.isDragging\",\"className\"],\"s\":\"_0+\\\" \\\"+(_1?_2:\\\"\\\")+\\\" \\\"+_3\"}}],\"t\":13},{\"n\":\"rel\",\"f\":[{\"t\":2,\"r\":\"key\"}],\"t\":13}],\"f\":[{\"t\":7,\"e\":\"a\",\"f\":[{\"t\":16}]}]}],\"e\":{}};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tmodule.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"ul\",\"m\":[{\"n\":\"dragenter\",\"f\":\"dragEnter\",\"t\":70},{\"n\":\"dragover\",\"f\":\"dragOver\",\"t\":70},{\"n\":\"dragleave\",\"f\":\"dragLeave\",\"t\":70},{\"n\":\"drop\",\"f\":\"dragDrop\",\"t\":70},{\"n\":\"class\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"css.sortableDragList\",\"isDropping\",\"css.isDropping\",\"className\"],\"s\":\"_0+\\\" \\\"+(_1?_2:\\\"\\\")+\\\" \\\"+_3\"}}],\"t\":13}],\"f\":[{\"t\":16}]}],\"e\":{}};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(10);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragItem.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragItem.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(11);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragList.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragList.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 70afc96cca3fc0a1967e","/*\n\tRactive.js v0.8.9\n\tWed Jan 04 2017 06:42:26 GMT+0000 (UTC) - commit ede92044770a136fd1179bd766fec4d47063faed\n\n\thttp://ractivejs.org\n\thttp://twitter.com/RactiveJS\n\n\tReleased under the MIT License.\n*/\n\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t((function() { var current = global.Ractive; var next = factory(); next.noConflict = function() { global.Ractive = current; return next; }; return global.Ractive = next; })());\n}(this, function () { 'use strict';\n\n\tvar defaults = {\n\t\t// render placement:\n\t\tel:                     void 0,\n\t\tappend:\t\t\t\t    false,\n\n\t\t// template:\n\t\ttemplate:               null,\n\n\t\t// parse:\n\t\tdelimiters:             [ '{{', '}}' ],\n\t\ttripleDelimiters:       [ '{{{', '}}}' ],\n\t\tstaticDelimiters:       [ '[[', ']]' ],\n\t\tstaticTripleDelimiters: [ '[[[', ']]]' ],\n\t\tcsp: \t\t\t\t\ttrue,\n\t\tinterpolate:            false,\n\t\tpreserveWhitespace:     false,\n\t\tsanitize:               false,\n\t\tstripComments:          true,\n\t\tcontextLines:           0,\n\n\t\t// data & binding:\n\t\tdata:                   {},\n\t\tcomputed:               {},\n\t\tmagic:                  false,\n\t\tmodifyArrays:           false,\n\t\tadapt:                  [],\n\t\tisolated:               false,\n\t\ttwoway:                 true,\n\t\tlazy:                   false,\n\n\t\t// transitions:\n\t\tnoIntro:                false,\n\t\ttransitionsEnabled:     true,\n\t\tcomplete:               void 0,\n\n\t\t// css:\n\t\tcss:                    null,\n\t\tnoCssTransform:         false\n\t};\n\n\t// These are a subset of the easing equations found at\n\t// https://raw.github.com/danro/easing-js - license info\n\t// follows:\n\n\t// --------------------------------------------------\n\t// easing.js v0.5.4\n\t// Generic set of easing functions with AMD support\n\t// https://github.com/danro/easing-js\n\t// This code may be freely distributed under the MIT license\n\t// http://danro.mit-license.org/\n\t// --------------------------------------------------\n\t// All functions adapted from Thomas Fuchs & Jeremy Kahn\n\t// Easing Equations (c) 2003 Robert Penner, BSD license\n\t// https://raw.github.com/danro/easing-js/master/LICENSE\n\t// --------------------------------------------------\n\n\t// In that library, the functions named easeIn, easeOut, and\n\t// easeInOut below are named easeInCubic, easeOutCubic, and\n\t// (you guessed it) easeInOutCubic.\n\t//\n\t// You can add additional easing functions to this list, and they\n\t// will be globally available.\n\n\n\tvar easing = {\n\t\tlinear: function ( pos ) { return pos; },\n\t\teaseIn: function ( pos ) { return Math.pow( pos, 3 ); },\n\t\teaseOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },\n\t\teaseInOut: function ( pos ) {\n\t\t\tif ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }\n\t\t\treturn ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );\n\t\t}\n\t};\n\n\tvar legacy = null;\n\n\t/*global console, navigator */\n\n\tvar win = typeof window !== 'undefined' ? window : null;\n\tvar doc = win ? document : null;\n\n\tvar isClient = !!doc;\n\tvar isJsdom = ( typeof navigator !== 'undefined' && /jsDom/.test( navigator.appName ) );\n\tvar hasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );\n\n\tvar magicSupported;\n\ttry {\n\t\tObject.defineProperty({}, 'test', { value: 0 });\n\t\tmagicSupported = true;\n\t} catch ( e ) {\n\t\tmagicSupported = false;\n\t}\n\n\tvar svg = doc ?\n\t\tdoc.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' ) :\n\t\tfalse;\n\n\tvar vendors = [ 'o', 'ms', 'moz', 'webkit' ];\n\n\tvar html   = 'http://www.w3.org/1999/xhtml';\n\tvar mathml = 'http://www.w3.org/1998/Math/MathML';\n\tvar svg$1    = 'http://www.w3.org/2000/svg';\n\tvar xlink  = 'http://www.w3.org/1999/xlink';\n\tvar xml    = 'http://www.w3.org/XML/1998/namespace';\n\tvar xmlns  = 'http://www.w3.org/2000/xmlns';\n\n\tvar namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };\n\n\tvar createElement;\n\tvar matches;\n\tvar div;\n\tvar methodNames;\n\tvar unprefixed;\n\tvar prefixed;\n\tvar i;\n\tvar j;\n\tvar makeFunction;\n\t// Test for SVG support\n\tif ( !svg ) {\n\t\tcreateElement = function ( type, ns, extend ) {\n\t\t\tif ( ns && ns !== html ) {\n\t\t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n\t\t\t}\n\n\t\t\treturn extend ?\n\t\t\t\tdoc.createElement( type, extend ) :\n\t\t\t\tdoc.createElement( type );\n\t\t};\n\t} else {\n\t\tcreateElement = function ( type, ns, extend ) {\n\t\t\tif ( !ns || ns === html ) {\n\t\t\t\treturn extend ?\n\t\t\t\t\tdoc.createElement( type, extend ) :\n\t\t\t\t\tdoc.createElement( type );\n\t\t\t}\n\n\t\t\treturn extend ?\n\t\t\t\tdoc.createElementNS( ns, type, extend ) :\n\t\t\t\tdoc.createElementNS( ns, type );\n\t\t};\n\t}\n\n\tfunction createDocumentFragment () {\n\t\treturn doc.createDocumentFragment();\n\t}\n\n\tfunction getElement ( input ) {\n\t\tvar output;\n\n\t\tif ( !input || typeof input === 'boolean' ) { return; }\n\n\t\tif ( !win || !doc || !input ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// We already have a DOM node - no work to do. (Duck typing alert!)\n\t\tif ( input.nodeType ) {\n\t\t\treturn input;\n\t\t}\n\n\t\t// Get node from string\n\t\tif ( typeof input === 'string' ) {\n\t\t\t// try ID first\n\t\t\toutput = doc.getElementById( input );\n\n\t\t\t// then as selector, if possible\n\t\t\tif ( !output && doc.querySelector ) {\n\t\t\t\toutput = doc.querySelector( input );\n\t\t\t}\n\n\t\t\t// did it work?\n\t\t\tif ( output && output.nodeType ) {\n\t\t\t\treturn output;\n\t\t\t}\n\t\t}\n\n\t\t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n\t\tif ( input[0] && input[0].nodeType ) {\n\t\t\treturn input[0];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tif ( !isClient ) {\n\t\tmatches = null;\n\t} else {\n\t\tdiv = createElement( 'div' );\n\t\tmethodNames = [ 'matches', 'matchesSelector' ];\n\n\t\tmakeFunction = function ( methodName ) {\n\t\t\treturn function ( node, selector ) {\n\t\t\t\treturn node[ methodName ]( selector );\n\t\t\t};\n\t\t};\n\n\t\ti = methodNames.length;\n\n\t\twhile ( i-- && !matches ) {\n\t\t\tunprefixed = methodNames[i];\n\n\t\t\tif ( div[ unprefixed ] ) {\n\t\t\t\tmatches = makeFunction( unprefixed );\n\t\t\t} else {\n\t\t\t\tj = vendors.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\tprefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\n\t\t\t\t\tif ( div[ prefixed ] ) {\n\t\t\t\t\t\tmatches = makeFunction( prefixed );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// IE8...\n\t\tif ( !matches ) {\n\t\t\tmatches = function ( node, selector ) {\n\t\t\t\tvar nodes, parentNode, i;\n\n\t\t\t\tparentNode = node.parentNode;\n\n\t\t\t\tif ( !parentNode ) {\n\t\t\t\t\t// empty dummy <div>\n\t\t\t\t\tdiv.innerHTML = '';\n\n\t\t\t\t\tparentNode = div;\n\t\t\t\t\tnode = node.cloneNode();\n\n\t\t\t\t\tdiv.appendChild( node );\n\t\t\t\t}\n\n\t\t\t\tnodes = parentNode.querySelectorAll( selector );\n\n\t\t\t\ti = nodes.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( nodes[i] === node ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}\n\t}\n\n\tfunction detachNode ( node ) {\n\t\tif ( node && typeof node.parentNode !== 'unknown' && node.parentNode ) {\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tfunction safeToStringValue ( value ) {\n\t\treturn ( value == null || !value.toString ) ? '' : '' + value;\n\t}\n\n\tfunction safeAttributeString ( string ) {\n\t\treturn safeToStringValue( string )\n\t\t\t.replace( /&/g, '&amp;' )\n\t\t\t.replace( /\"/g, '&quot;' )\n\t\t\t.replace( /'/g, '&#39;' );\n\t}\n\n\tvar decamel = /[A-Z]/g;\n\tfunction decamelize ( string ) {\n\t\treturn string.replace( decamel, function ( s ) { return (\"-\" + (s.toLowerCase())); } );\n\t}\n\n\tvar create;\n\tvar defineProperty;\n\tvar defineProperties;\n\ttry {\n\t\tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\n\t\tif ( doc ) {\n\t\t\tObject.defineProperty( createElement( 'div' ), 'test', { value: 0 });\n\t\t}\n\n\t\tdefineProperty = Object.defineProperty;\n\t} catch ( err ) {\n\t\t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n\t\t// only use it with DOM objects (what were you smoking, MSFT?)\n\t\tdefineProperty = function ( obj, prop, desc ) {\n\t\t\tif ( desc.get ) obj[ prop ] = desc.get();\n\t\t\telse obj[ prop ] = desc.value;\n\t\t};\n\t}\n\n\ttry {\n\t\ttry {\n\t\t\tObject.defineProperties({}, { test: { value: 0 } });\n\t\t} catch ( err ) {\n\t\t\t// TODO how do we account for this? noMagic = true;\n\t\t\tthrow err;\n\t\t}\n\n\t\tif ( doc ) {\n\t\t\tObject.defineProperties( createElement( 'div' ), { test: { value: 0 } });\n\t\t}\n\n\t\tdefineProperties = Object.defineProperties;\n\t} catch ( err ) {\n\t\tdefineProperties = function ( obj, props ) {\n\t\t\tvar prop;\n\n\t\t\tfor ( prop in props ) {\n\t\t\t\tif ( props.hasOwnProperty( prop ) ) {\n\t\t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\ttry {\n\t\tObject.create( null );\n\n\t\tcreate = Object.create;\n\t} catch ( err ) {\n\t\t// sigh\n\t\tcreate = (function () {\n\t\t\tvar F = function () {};\n\n\t\t\treturn function ( proto, props ) {\n\t\t\t\tvar obj;\n\n\t\t\t\tif ( proto === null ) {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\n\t\t\t\tF.prototype = proto;\n\t\t\t\tobj = new F();\n\n\t\t\t\tif ( props ) {\n\t\t\t\t\tObject.defineProperties( obj, props );\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}());\n\t}\n\n\tfunction extendObj ( target ) {\n\t\tvar sources = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n\t\tvar prop;\n\n\t\tsources.forEach( function ( source ) {\n\t\t\tfor ( prop in source ) {\n\t\t\t\tif ( hasOwn.call( source, prop ) ) {\n\t\t\t\t\ttarget[ prop ] = source[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn target;\n\t}\n\n\tfunction fillGaps ( target ) {\n\t\tvar sources = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n\t\tsources.forEach( function ( s ) {\n\t\t\tfor ( var key in s ) {\n\t\t\t\tif ( hasOwn.call( s, key ) && !( key in target ) ) {\n\t\t\t\t\ttarget[ key ] = s[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn target;\n\t}\n\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\n\tvar toString = Object.prototype.toString;\n\t// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n\tfunction isArray ( thing ) {\n\t\treturn toString.call( thing ) === '[object Array]';\n\t}\n\n\tfunction isEqual ( a, b ) {\n\t\tif ( a === null && b === null ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( typeof a === 'object' || typeof b === 'object' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\t// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n\tfunction isNumeric ( thing ) {\n\t\treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n\t}\n\n\tfunction isObject ( thing ) {\n\t\treturn ( thing && toString.call( thing ) === '[object Object]' );\n\t}\n\n\tfunction noop () {}\n\n\tvar alreadyWarned = {};\n\tvar log;\n\tvar printWarning;\n\tvar welcome;\n\tif ( hasConsole ) {\n\t\tvar welcomeIntro = [\n\t\t\t(\"%cRactive.js %c0.8.9 %cin debug mode, %cmore...\"),\n\t\t\t'color: rgb(114, 157, 52); font-weight: normal;',\n\t\t\t'color: rgb(85, 85, 85); font-weight: normal;',\n\t\t\t'color: rgb(85, 85, 85); font-weight: normal;',\n\t\t\t'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n\t\t];\n\t\tvar welcomeMessage = \"You're running Ractive 0.8.9 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n\t\twelcome = function () {\n\t\t\tif ( Ractive.WELCOME_MESSAGE === false ) {\n\t\t\t\twelcome = noop;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n\t\t\tvar hasGroup = !!console.groupCollapsed;\n\t\t\tif ( hasGroup ) console.groupCollapsed.apply( console, welcomeIntro );\n\t\t\tconsole.log( message );\n\t\t\tif ( hasGroup ) {\n\t\t\t\tconsole.groupEnd( welcomeIntro );\n\t\t\t}\n\n\t\t\twelcome = noop;\n\t\t};\n\n\t\tprintWarning = function ( message, args ) {\n\t\t\twelcome();\n\n\t\t\t// extract information about the instance this message pertains to, if applicable\n\t\t\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\t\t\tvar options = args.pop();\n\t\t\t\tvar ractive = options ? options.ractive : null;\n\n\t\t\t\tif ( ractive ) {\n\t\t\t\t\t// if this is an instance of a component that we know the name of, add\n\t\t\t\t\t// it to the message\n\t\t\t\t\tvar name;\n\t\t\t\t\tif ( ractive.component && ( name = ractive.component.name ) ) {\n\t\t\t\t\t\tmessage = \"<\" + name + \"> \" + message;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar node;\n\t\t\t\t\tif ( node = ( options.node || ( ractive.fragment && ractive.fragment.rendered && ractive.find( '*' ) ) ) ) {\n\t\t\t\t\t\targs.push( node );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );\n\t\t};\n\n\t\tlog = function () {\n\t\t\tconsole.log.apply( console, arguments );\n\t\t};\n\t} else {\n\t\tprintWarning = log = welcome = noop;\n\t}\n\n\tfunction format ( message, args ) {\n\t\treturn message.replace( /%s/g, function () { return args.shift(); } );\n\t}\n\n\tfunction fatal ( message ) {\n\t\tvar args = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t\tmessage = format( message, args );\n\t\tthrow new Error( message );\n\t}\n\n\tfunction logIfDebug () {\n\t\tif ( Ractive.DEBUG ) {\n\t\t\tlog.apply( null, arguments );\n\t\t}\n\t}\n\n\tfunction warn ( message ) {\n\t\tvar args = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t\tmessage = format( message, args );\n\t\tprintWarning( message, args );\n\t}\n\n\tfunction warnOnce ( message ) {\n\t\tvar args = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t\tmessage = format( message, args );\n\n\t\tif ( alreadyWarned[ message ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\talreadyWarned[ message ] = true;\n\t\tprintWarning( message, args );\n\t}\n\n\tfunction warnIfDebug () {\n\t\tif ( Ractive.DEBUG ) {\n\t\t\twarn.apply( null, arguments );\n\t\t}\n\t}\n\n\tfunction warnOnceIfDebug () {\n\t\tif ( Ractive.DEBUG ) {\n\t\t\twarnOnce.apply( null, arguments );\n\t\t}\n\t}\n\n\t// Error messages that are used (or could be) in multiple places\n\tvar badArguments = 'Bad arguments';\n\tvar noRegistryFunctionReturn = 'A function was specified for \"%s\" %s, but no %s was returned';\n\tvar missingPlugin = function ( name, type ) { return (\"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\" + type + \"s\"); };\n\n\tfunction findInViewHierarchy ( registryName, ractive, name ) {\n\t\tvar instance = findInstance( registryName, ractive, name );\n\t\treturn instance ? instance[ registryName ][ name ] : null;\n\t}\n\n\tfunction findInstance ( registryName, ractive, name ) {\n\t\twhile ( ractive ) {\n\t\t\tif ( name in ractive[ registryName ] ) {\n\t\t\t\treturn ractive;\n\t\t\t}\n\n\t\t\tif ( ractive.isolated ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tractive = ractive.parent;\n\t\t}\n\t}\n\n\tfunction interpolate ( from, to, ractive, type ) {\n\t\tif ( from === to ) return null;\n\n\t\tif ( type ) {\n\t\t\tvar interpol = findInViewHierarchy( 'interpolators', ractive, type );\n\t\t\tif ( interpol ) return interpol( from, to ) || null;\n\n\t\t\tfatal( missingPlugin( type, 'interpolator' ) );\n\t\t}\n\n\t\treturn interpolators.number( from, to ) ||\n\t\t       interpolators.array( from, to ) ||\n\t\t       interpolators.object( from, to ) ||\n\t\t       null;\n\t}\n\n\tfunction snap ( to ) {\n\t\treturn function () { return to; };\n\t}\n\n\tvar interpolators = {\n\t\tnumber: function ( from, to ) {\n\t\t\tvar delta;\n\n\t\t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfrom = +from;\n\t\t\tto = +to;\n\n\t\t\tdelta = to - from;\n\n\t\t\tif ( !delta ) {\n\t\t\t\treturn function () { return from; };\n\t\t\t}\n\n\t\t\treturn function ( t ) {\n\t\t\t\treturn from + ( t * delta );\n\t\t\t};\n\t\t},\n\n\t\tarray: function ( from, to ) {\n\t\t\tvar intermediate, interpolators, len, i;\n\n\t\t\tif ( !isArray( from ) || !isArray( to ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tintermediate = [];\n\t\t\tinterpolators = [];\n\n\t\t\ti = len = Math.min( from.length, to.length );\n\t\t\twhile ( i-- ) {\n\t\t\t\tinterpolators[i] = interpolate( from[i], to[i] );\n\t\t\t}\n\n\t\t\t// surplus values - don't interpolate, but don't exclude them either\n\t\t\tfor ( i=len; i<from.length; i+=1 ) {\n\t\t\t\tintermediate[i] = from[i];\n\t\t\t}\n\n\t\t\tfor ( i=len; i<to.length; i+=1 ) {\n\t\t\t\tintermediate[i] = to[i];\n\t\t\t}\n\n\t\t\treturn function ( t ) {\n\t\t\t\tvar i = len;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tintermediate[i] = interpolators[i]( t );\n\t\t\t\t}\n\n\t\t\t\treturn intermediate;\n\t\t\t};\n\t\t},\n\n\t\tobject: function ( from, to ) {\n\t\t\tvar properties, len, interpolators, intermediate, prop;\n\n\t\t\tif ( !isObject( from ) || !isObject( to ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tproperties = [];\n\t\t\tintermediate = {};\n\t\t\tinterpolators = {};\n\n\t\t\tfor ( prop in from ) {\n\t\t\t\tif ( hasOwn.call( from, prop ) ) {\n\t\t\t\t\tif ( hasOwn.call( to, prop ) ) {\n\t\t\t\t\t\tproperties.push( prop );\n\t\t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\tintermediate[ prop ] = from[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( prop in to ) {\n\t\t\t\tif ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {\n\t\t\t\t\tintermediate[ prop ] = to[ prop ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen = properties.length;\n\n\t\t\treturn function ( t ) {\n\t\t\t\tvar i = len, prop;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = properties[i];\n\n\t\t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n\t\t\t\t}\n\n\t\t\t\treturn intermediate;\n\t\t\t};\n\t\t}\n\t};\n\n\t// TODO: deprecate in future release\n\tvar deprecations = {\n\t\tconstruct: {\n\t\t\tdeprecated: 'beforeInit',\n\t\t\treplacement: 'onconstruct'\n\t\t},\n\t\trender: {\n\t\t\tdeprecated: 'init',\n\t\t\tmessage: 'The \"init\" method has been deprecated ' +\n\t\t\t\t'and will likely be removed in a future release. ' +\n\t\t\t\t'You can either use the \"oninit\" method which will fire ' +\n\t\t\t\t'only once prior to, and regardless of, any eventual ractive ' +\n\t\t\t\t'instance being rendered, or if you need to access the ' +\n\t\t\t\t'rendered DOM, use \"onrender\" instead. ' +\n\t\t\t\t'See http://docs.ractivejs.org/latest/migrating for more information.'\n\t\t},\n\t\tcomplete: {\n\t\t\tdeprecated: 'complete',\n\t\t\treplacement: 'oncomplete'\n\t\t}\n\t};\n\n\tvar Hook = function Hook ( event ) {\n\t\tthis.event = event;\n\t\tthis.method = 'on' + event;\n\t\tthis.deprecate = deprecations[ event ];\n\t};\n\n\tHook.prototype.call = function call ( method, ractive, arg ) {\n\t\tif ( ractive[ method ] ) {\n\t\t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tHook.prototype.fire = function fire ( ractive, arg ) {\n\t\tthis.call( this.method, ractive, arg );\n\n\t\t// handle deprecations\n\t\tif ( !ractive[ this.method ] && this.deprecate && this.call( this.deprecate.deprecated, ractive, arg ) ) {\n\t\t\tif ( this.deprecate.message ) {\n\t\t\t\twarnIfDebug( this.deprecate.message );\n\t\t\t} else {\n\t\t\t\twarnIfDebug( 'The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.', this.deprecate.deprecated, this.deprecate.replacement );\n\t\t\t}\n\t\t}\n\n\t\t// TODO should probably use internal method, in case ractive.fire was overwritten\n\t\targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n\t};\n\n\tfunction addToArray ( array, value ) {\n\t\tvar index = array.indexOf( value );\n\n\t\tif ( index === -1 ) {\n\t\t\tarray.push( value );\n\t\t}\n\t}\n\n\tfunction arrayContains ( array, value ) {\n\t\tfor ( var i = 0, c = array.length; i < c; i++ ) {\n\t\t\tif ( array[i] == value ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction arrayContentsMatch ( a, b ) {\n\t\tvar i;\n\n\t\tif ( !isArray( a ) || !isArray( b ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( a.length !== b.length ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ti = a.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( a[i] !== b[i] ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction ensureArray ( x ) {\n\t\tif ( typeof x === 'string' ) {\n\t\t\treturn [ x ];\n\t\t}\n\n\t\tif ( x === undefined ) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn x;\n\t}\n\n\tfunction lastItem ( array ) {\n\t\treturn array[ array.length - 1 ];\n\t}\n\n\tfunction removeFromArray ( array, member ) {\n\t\tif ( !array ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar index = array.indexOf( member );\n\n\t\tif ( index !== -1 ) {\n\t\t\tarray.splice( index, 1 );\n\t\t}\n\t}\n\n\tfunction toArray ( arrayLike ) {\n\t\tvar array = [], i = arrayLike.length;\n\t\twhile ( i-- ) {\n\t\t\tarray[i] = arrayLike[i];\n\t\t}\n\n\t\treturn array;\n\t}\n\n\tvar _Promise;\n\tvar PENDING = {};\n\tvar FULFILLED = {};\n\tvar REJECTED = {};\n\tif ( typeof Promise === 'function' ) {\n\t\t// use native Promise\n\t\t_Promise = Promise;\n\t} else {\n\t\t_Promise = function ( callback ) {\n\t\t\tvar fulfilledHandlers = [],\n\t\t\t\trejectedHandlers = [],\n\t\t\t\tstate = PENDING,\n\n\t\t\t\tresult,\n\t\t\t\tdispatchHandlers,\n\t\t\t\tmakeResolver,\n\t\t\t\tfulfil,\n\t\t\t\treject,\n\n\t\t\t\tpromise;\n\n\t\t\tmakeResolver = function ( newState ) {\n\t\t\t\treturn function ( value ) {\n\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = value;\n\t\t\t\t\tstate = newState;\n\n\t\t\t\t\tdispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );\n\n\t\t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tfulfil = makeResolver( FULFILLED );\n\t\t\treject = makeResolver( REJECTED );\n\n\t\t\ttry {\n\t\t\t\tcallback( fulfil, reject );\n\t\t\t} catch ( err ) {\n\t\t\t\treject( err );\n\t\t\t}\n\n\t\t\tpromise = {\n\t\t\t\t// `then()` returns a Promise - 2.2.7\n\t\t\t\tthen: function ( onFulfilled, onRejected ) {\n\t\t\t\t\tvar promise2 = new _Promise( function ( fulfil, reject ) {\n\n\t\t\t\t\t\tvar processResolutionHandler = function ( handler, handlers, forward ) {\n\n\t\t\t\t\t\t\t// 2.2.1.1\n\t\t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t\t\t\t\t\t\t\thandlers.push( function ( p1result ) {\n\t\t\t\t\t\t\t\t\tvar x;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t\t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t\t\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t\t\t\t\t\t\t\t// are not given\n\t\t\t\t\t\t\t\thandlers.push( forward );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// 2.2\n\t\t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t\t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\n\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\t\treturn promise2;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tpromise[ 'catch' ] = function ( onRejected ) {\n\t\t\t\treturn this.then( null, onRejected );\n\t\t\t};\n\n\t\t\treturn promise;\n\t\t};\n\n\t\t_Promise.all = function ( promises ) {\n\t\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\t\tvar result = [], pending, i, processPromise;\n\n\t\t\t\tif ( !promises.length ) {\n\t\t\t\t\tfulfil( result );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tprocessPromise = function ( promise, i ) {\n\t\t\t\t\tif ( promise && typeof promise.then === 'function' ) {\n\t\t\t\t\t\tpromise.then( function ( value ) {\n\t\t\t\t\t\t\tresult[i] = value;\n\t\t\t\t\t\t\t--pending || fulfil( result );\n\t\t\t\t\t\t}, reject );\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult[i] = promise;\n\t\t\t\t\t\t--pending || fulfil( result );\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tpending = i = promises.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprocessPromise( promises[i], i );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t_Promise.resolve = function ( value ) {\n\t\t\treturn new _Promise( function ( fulfil ) {\n\t\t\t\tfulfil( value );\n\t\t\t});\n\t\t};\n\n\t\t_Promise.reject = function ( reason ) {\n\t\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\t\treject( reason );\n\t\t\t});\n\t\t};\n\t}\n\n\tvar Promise$1 = _Promise;\n\n\t// TODO use MutationObservers or something to simulate setImmediate\n\tfunction wait ( callback ) {\n\t\tsetTimeout( callback, 0 );\n\t}\n\n\tfunction makeDispatcher ( handlers, result ) {\n\t\treturn function () {\n\t\t\tvar handler;\n\n\t\t\twhile ( handler = handlers.shift() ) {\n\t\t\t\thandler( result );\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction resolve ( promise, x, fulfil, reject ) {\n\t\t// Promise Resolution Procedure\n\t\tvar then;\n\n\t\t// 2.3.1\n\t\tif ( x === promise ) {\n\t\t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t\t}\n\n\t\t// 2.3.2\n\t\tif ( x instanceof _Promise ) {\n\t\t\tx.then( fulfil, reject );\n\t\t}\n\n\t\t// 2.3.3\n\t\telse if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t\t\ttry {\n\t\t\t\tthen = x.then; // 2.3.3.1\n\t\t\t} catch ( e ) {\n\t\t\t\treject( e ); // 2.3.3.2\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 2.3.3.3\n\t\t\tif ( typeof then === 'function' ) {\n\t\t\t\tvar called, resolvePromise, rejectPromise;\n\n\t\t\t\tresolvePromise = function ( y ) {\n\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tresolve( promise, y, fulfil, reject );\n\t\t\t\t};\n\n\t\t\t\trejectPromise = function ( r ) {\n\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcalled = true;\n\t\t\t\t\treject( r );\n\t\t\t\t};\n\n\t\t\t\ttry {\n\t\t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tif ( !called ) { // 2.3.3.3.4.1\n\t\t\t\t\t\treject( e ); // 2.3.3.3.4.2\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfulfil( x );\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tfulfil( x );\n\t\t}\n\t}\n\n\tvar TransitionManager = function TransitionManager ( callback, parent ) {\n\t\tthis.callback = callback;\n\t\tthis.parent = parent;\n\n\t\tthis.intros = [];\n\t\tthis.outros = [];\n\n\t\tthis.children = [];\n\t\tthis.totalChildren = this.outroChildren = 0;\n\n\t\tthis.detachQueue = [];\n\t\tthis.outrosComplete = false;\n\n\t\tif ( parent ) {\n\t\t\tparent.addChild( this );\n\t\t}\n\t};\n\n\tTransitionManager.prototype.add = function add ( transition ) {\n\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\tlist.push( transition );\n\t};\n\n\tTransitionManager.prototype.addChild = function addChild ( child ) {\n\t\tthis.children.push( child );\n\n\t\tthis.totalChildren += 1;\n\t\tthis.outroChildren += 1;\n\t};\n\n\tTransitionManager.prototype.decrementOutros = function decrementOutros () {\n\t\tthis.outroChildren -= 1;\n\t\tcheck( this );\n\t};\n\n\tTransitionManager.prototype.decrementTotal = function decrementTotal () {\n\t\tthis.totalChildren -= 1;\n\t\tcheck( this );\n\t};\n\n\tTransitionManager.prototype.detachNodes = function detachNodes () {\n\t\tthis.detachQueue.forEach( detach );\n\t\tthis.children.forEach( _detachNodes );\n\t};\n\n\tTransitionManager.prototype.ready = function ready () {\n\t\tdetachImmediate( this );\n\t};\n\n\tTransitionManager.prototype.remove = function remove ( transition ) {\n\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\tremoveFromArray( list, transition );\n\t\tcheck( this );\n\t};\n\n\tTransitionManager.prototype.start = function start () {\n\t\tthis.children.forEach( function ( c ) { return c.start(); } );\n\t\tthis.intros.concat( this.outros ).forEach( function ( t ) { return t.start(); } );\n\t\tthis.ready = true;\n\t\tcheck( this );\n\t};\n\n\tfunction detach ( element ) {\n\t\telement.detach();\n\t}\n\n\tfunction _detachNodes ( tm ) { // _ to avoid transpiler quirk\n\t\ttm.detachNodes();\n\t}\n\n\tfunction check ( tm ) {\n\t\tif ( !tm.ready || tm.outros.length || tm.outroChildren ) return;\n\n\t\t// If all outros are complete, and we haven't already done this,\n\t\t// we notify the parent if there is one, otherwise\n\t\t// start detaching nodes\n\t\tif ( !tm.outrosComplete ) {\n\t\t\ttm.outrosComplete = true;\n\n\t\t\tif ( tm.parent && !tm.parent.outrosComplete ) {\n\t\t\t\ttm.parent.decrementOutros( tm );\n\t\t\t} else {\n\t\t\t\ttm.detachNodes();\n\t\t\t}\n\t\t}\n\n\t\t// Once everything is done, we can notify parent transition\n\t\t// manager and call the callback\n\t\tif ( !tm.intros.length && !tm.totalChildren ) {\n\t\t\tif ( typeof tm.callback === 'function' ) {\n\t\t\t\ttm.callback();\n\t\t\t}\n\n\t\t\tif ( tm.parent && !tm.notifiedTotal ) {\n\t\t\t\ttm.notifiedTotal = true;\n\t\t\t\ttm.parent.decrementTotal();\n\t\t\t}\n\t\t}\n\t}\n\n\t// check through the detach queue to see if a node is up or downstream from a\n\t// transition and if not, go ahead and detach it\n\tfunction detachImmediate ( manager ) {\n\t\tvar queue = manager.detachQueue;\n\t\tvar outros = collectAllOutros( manager );\n\n\t\tvar i = queue.length, j = 0, node, trans;\n\t\tstart: while ( i-- ) {\n\t\t\tnode = queue[i].node;\n\t\t\tj = outros.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\ttrans = outros[j].element.node;\n\t\t\t\t// check to see if the node is, contains, or is contained by the transitioning node\n\t\t\t\tif ( trans === node || trans.contains( node ) || node.contains( trans ) ) continue start;\n\t\t\t}\n\n\t\t\t// no match, we can drop it\n\t\t\tqueue[i].detach();\n\t\t\tqueue.splice( i, 1 );\n\t\t}\n\t}\n\n\tfunction collectAllOutros ( manager, list ) {\n\t\tif ( !list ) {\n\t\t\tlist = [];\n\t\t\tvar parent = manager;\n\t\t\twhile ( parent.parent ) parent = parent.parent;\n\t\t\treturn collectAllOutros( parent, list );\n\t\t} else {\n\t\t\tvar i = manager.children.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tlist = collectAllOutros( manager.children[i], list );\n\t\t\t}\n\t\t\tlist = list.concat( manager.outros );\n\t\t\treturn list;\n\t\t}\n\t}\n\n\tvar changeHook = new Hook( 'change' );\n\n\tvar batch;\n\n\tvar runloop = {\n\t\tstart: function ( instance, returnPromise ) {\n\t\t\tvar promise, fulfilPromise;\n\n\t\t\tif ( returnPromise ) {\n\t\t\t\tpromise = new Promise$1( function ( f ) { return ( fulfilPromise = f ); } );\n\t\t\t}\n\n\t\t\tbatch = {\n\t\t\t\tpreviousBatch: batch,\n\t\t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t\t\t\tfragments: [],\n\t\t\t\ttasks: [],\n\t\t\t\timmediateObservers: [],\n\t\t\t\tdeferredObservers: [],\n\t\t\t\tractives: [],\n\t\t\t\tinstance: instance\n\t\t\t};\n\n\t\t\treturn promise;\n\t\t},\n\n\t\tend: function () {\n\t\t\tflushChanges();\n\n\t\t\tif ( !batch.previousBatch ) batch.transitionManager.start();\n\n\t\t\tbatch = batch.previousBatch;\n\t\t},\n\n\t\taddFragment: function ( fragment ) {\n\t\t\taddToArray( batch.fragments, fragment );\n\t\t},\n\n\t\t// TODO: come up with a better way to handle fragments that trigger their own update\n\t\taddFragmentToRoot: function ( fragment ) {\n\t\t\tif ( !batch ) return;\n\n\t\t\tvar b = batch;\n\t\t\twhile ( b.previousBatch ) {\n\t\t\t\tb = b.previousBatch;\n\t\t\t}\n\n\t\t\taddToArray( b.fragments, fragment );\n\t\t},\n\n\t\taddInstance: function ( instance ) {\n\t\t\tif ( batch ) addToArray( batch.ractives, instance );\n\t\t},\n\n\t\taddObserver: function ( observer, defer ) {\n\t\t\taddToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );\n\t\t},\n\n\t\tregisterTransition: function ( transition ) {\n\t\t\ttransition._manager = batch.transitionManager;\n\t\t\tbatch.transitionManager.add( transition );\n\t\t},\n\n\t\t// synchronise node detachments with transition ends\n\t\tdetachWhenReady: function ( thing ) {\n\t\t\tbatch.transitionManager.detachQueue.push( thing );\n\t\t},\n\n\t\tscheduleTask: function ( task, postRender ) {\n\t\t\tvar _batch;\n\n\t\t\tif ( !batch ) {\n\t\t\t\ttask();\n\t\t\t} else {\n\t\t\t\t_batch = batch;\n\t\t\t\twhile ( postRender && _batch.previousBatch ) {\n\t\t\t\t\t// this can't happen until the DOM has been fully updated\n\t\t\t\t\t// otherwise in some situations (with components inside elements)\n\t\t\t\t\t// transitions and decorators will initialise prematurely\n\t\t\t\t\t_batch = _batch.previousBatch;\n\t\t\t\t}\n\n\t\t\t\t_batch.tasks.push( task );\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction dispatch ( observer ) {\n\t\tobserver.dispatch();\n\t}\n\n\tfunction flushChanges () {\n\t\tvar which = batch.immediateObservers;\n\t\tbatch.immediateObservers = [];\n\t\twhich.forEach( dispatch );\n\n\t\t// Now that changes have been fully propagated, we can update the DOM\n\t\t// and complete other tasks\n\t\tvar i = batch.fragments.length;\n\t\tvar fragment;\n\n\t\twhich = batch.fragments;\n\t\tbatch.fragments = [];\n\t\tvar ractives = batch.ractives;\n\t\tbatch.ractives = [];\n\n\t\twhile ( i-- ) {\n\t\t\tfragment = which[i];\n\n\t\t\t// TODO deprecate this. It's annoying and serves no useful function\n\t\t\tvar ractive = fragment.ractive;\n\t\t\tif ( Object.keys( ractive.viewmodel.changes ).length ) {\n\t\t\t\tchangeHook.fire( ractive, ractive.viewmodel.changes );\n\t\t\t}\n\t\t\tractive.viewmodel.changes = {};\n\t\t\tremoveFromArray( ractives, ractive );\n\n\t\t\tfragment.update();\n\t\t}\n\n\t\ti = ractives.length;\n\t\twhile ( i-- ) {\n\t\t\tvar ractive$1 = ractives[i];\n\t\t\tchangeHook.fire( ractive$1, ractive$1.viewmodel.changes );\n\t\t\tractive$1.viewmodel.changes = {};\n\t\t}\n\n\t\tbatch.transitionManager.ready();\n\n\t\twhich = batch.deferredObservers;\n\t\tbatch.deferredObservers = [];\n\t\twhich.forEach( dispatch );\n\n\t\tvar tasks = batch.tasks;\n\t\tbatch.tasks = [];\n\n\t\tfor ( i = 0; i < tasks.length; i += 1 ) {\n\t\t\ttasks[i]();\n\t\t}\n\n\t\t// If updating the view caused some model blowback - e.g. a triple\n\t\t// containing <option> elements caused the binding on the <select>\n\t\t// to update - then we start over\n\t\tif ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.ractives.length || batch.tasks.length ) return flushChanges();\n\t}\n\n\tvar refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n\tvar splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\n\tvar escapeKeyPattern = /\\\\|\\./g;\n\tvar unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\n\tfunction escapeKey ( key ) {\n\t\tif ( typeof key === 'string' ) {\n\t\t\treturn key.replace( escapeKeyPattern, '\\\\$&' );\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tfunction normalise ( ref ) {\n\t\treturn ref ? ref.replace( refPattern, '.$1' ) : '';\n\t}\n\n\tfunction splitKeypathI ( keypath ) {\n\t\tvar result = [],\n\t\t\tmatch;\n\n\t\tkeypath = normalise( keypath );\n\n\t\twhile ( match = splitPattern.exec( keypath ) ) {\n\t\t\tvar index = match.index + match[1].length;\n\t\t\tresult.push( keypath.substr( 0, index ) );\n\t\t\tkeypath = keypath.substr( index + 1 );\n\t\t}\n\n\t\tresult.push(keypath);\n\n\t\treturn result;\n\t}\n\n\tfunction unescapeKey ( key ) {\n\t\tif ( typeof key === 'string' ) {\n\t\t\treturn key.replace( unescapeKeyPattern, '$1$2' );\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tfunction bind ( fn, context ) {\n\t\tif ( !/this/.test( fn.toString() ) ) return fn;\n\n\t\tvar bound = fn.bind( context );\n\t\tfor ( var prop in fn ) bound[ prop ] = fn[ prop ];\n\n\t\treturn bound;\n\t}\n\n\tfunction set ( ractive, pairs ) {\n\t\tvar promise = runloop.start( ractive, true );\n\n\t\tvar i = pairs.length;\n\t\twhile ( i-- ) {\n\t\t\tvar ref = pairs[i], model = ref[0], value = ref[1];\n\t\t\tif ( typeof value === 'function' ) value = bind( value, ractive );\n\t\t\tmodel.set( value );\n\t\t}\n\n\t\trunloop.end();\n\n\t\treturn promise;\n\t}\n\n\tvar star = /\\*/;\n\tfunction gather ( ractive, keypath, base ) {\n\t\tif ( base === void 0 ) base = ractive.viewmodel;\n\n\t\tif ( star.test( keypath ) ) {\n\t\t\treturn base.findMatches( splitKeypathI( keypath ) );\n\t\t} else {\n\t\t\treturn [ base.joinAll( splitKeypathI( keypath ) ) ];\n\t\t}\n\t}\n\n\tfunction build ( ractive, keypath, value ) {\n\t\tvar sets = [];\n\n\t\t// set multiple keypaths in one go\n\t\tif ( isObject( keypath ) ) {\n\t\t\tvar loop = function ( k ) {\n\t\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\t\tsets.push.apply( sets, gather( ractive, k ).map( function ( m ) { return [ m, keypath[k] ]; } ) );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor ( var k in keypath ) loop( k );\n\n\t\t}\n\t\t// set a single keypath\n\t\telse {\n\t\t\tsets.push.apply( sets, gather( ractive, keypath ).map( function ( m ) { return [ m, value ]; } ) );\n\t\t}\n\n\t\treturn sets;\n\t}\n\n\tvar errorMessage = 'Cannot add to a non-numeric value';\n\n\tfunction add ( ractive, keypath, d ) {\n\t\tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n\t\t\tthrow new Error( 'Bad arguments' );\n\t\t}\n\n\t\tvar sets = build( ractive, keypath, d );\n\n\t\treturn set( ractive, sets.map( function ( pair ) {\n\t\t\tvar model = pair[0], add = pair[1], value = model.get();\n\t\t\tif ( !isNumeric( add ) || !isNumeric( value ) ) throw new Error( errorMessage );\n\t\t\treturn [ model, value + add ];\n\t\t}));\n\t}\n\n\tfunction Ractive$add ( keypath, d ) {\n\t\treturn add( this, keypath, ( d === undefined ? 1 : +d ) );\n\t}\n\n\tvar noAnimation = Promise$1.resolve();\n\tdefineProperty( noAnimation, 'stop', { value: noop });\n\n\tvar linear = easing.linear;\n\n\tfunction getOptions ( options, instance ) {\n\t\toptions = options || {};\n\n\t\tvar easing;\n\t\tif ( options.easing ) {\n\t\t\teasing = typeof options.easing === 'function' ?\n\t\t\t\toptions.easing :\n\t\t\t\tinstance.easing[ options.easing ];\n\t\t}\n\n\t\treturn {\n\t\t\teasing: easing || linear,\n\t\t\tduration: 'duration' in options ? options.duration : 400,\n\t\t\tcomplete: options.complete || noop,\n\t\t\tstep: options.step || noop\n\t\t};\n\t}\n\n\tfunction protoAnimate ( ractive, model, to, options ) {\n\t\toptions = getOptions( options, ractive );\n\t\tvar from = model.get();\n\n\t\t// don't bother animating values that stay the same\n\t\tif ( isEqual( from, to ) ) {\n\t\t\toptions.complete( options.to );\n\t\t\treturn noAnimation; // TODO should this have .then and .catch methods?\n\t\t}\n\n\t\tvar interpolator = interpolate( from, to, ractive, options.interpolator );\n\n\t\t// if we can't interpolate the value, set it immediately\n\t\tif ( !interpolator ) {\n\t\t\trunloop.start();\n\t\t\tmodel.set( to );\n\t\t\trunloop.end();\n\n\t\t\treturn noAnimation;\n\t\t}\n\n\t\treturn model.animate( from, to, options, interpolator );\n\t}\n\n\tfunction Ractive$animate ( keypath, to, options ) {\n\t\tif ( typeof keypath === 'object' ) {\n\t\t\tvar keys = Object.keys( keypath );\n\n\t\t\tthrow new Error( (\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \" + (keys.map( function ( key ) { return (\"'\" + key + \"': \" + (keypath[ key ])); } ).join( '\\n  ' )) + \"\\n}, {...}), do\\n\\n\" + (keys.map( function ( key ) { return (\"ractive.animate('\" + key + \"', \" + (keypath[ key ]) + \", {...});\"); } ).join( '\\n' )) + \"\\n\") );\n\t\t}\n\n\n\t\treturn protoAnimate( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), to, options );\n\t}\n\n\tvar detachHook = new Hook( 'detach' );\n\n\tfunction Ractive$detach () {\n\t\tif ( this.isDetached ) {\n\t\t\treturn this.el;\n\t\t}\n\n\t\tif ( this.el ) {\n\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t}\n\n\t\tthis.el = this.fragment.detach();\n\t\tthis.isDetached = true;\n\n\t\tdetachHook.fire( this );\n\t\treturn this.el;\n\t}\n\n\tfunction Ractive$find ( selector ) {\n\t\tif ( !this.el ) throw new Error( (\"Cannot call ractive.find('\" + selector + \"') unless instance is rendered to the DOM\") );\n\n\t\treturn this.fragment.find( selector );\n\t}\n\n\tfunction sortByDocumentPosition ( node, otherNode ) {\n\t\tif ( node.compareDocumentPosition ) {\n\t\t\tvar bitmask = node.compareDocumentPosition( otherNode );\n\t\t\treturn ( bitmask & 2 ) ? 1 : -1;\n\t\t}\n\n\t\t// In old IE, we can piggy back on the mechanism for\n\t\t// comparing component positions\n\t\treturn sortByItemPosition( node, otherNode );\n\t}\n\n\tfunction sortByItemPosition ( a, b ) {\n\t\tvar ancestryA = getAncestry( a.component || a._ractive.proxy );\n\t\tvar ancestryB = getAncestry( b.component || b._ractive.proxy );\n\n\t\tvar oldestA = lastItem( ancestryA );\n\t\tvar oldestB = lastItem( ancestryB );\n\t\tvar mutualAncestor;\n\n\t\t// remove items from the end of both ancestries as long as they are identical\n\t\t// - the final one removed is the closest mutual ancestor\n\t\twhile ( oldestA && ( oldestA === oldestB ) ) {\n\t\t\tancestryA.pop();\n\t\t\tancestryB.pop();\n\n\t\t\tmutualAncestor = oldestA;\n\n\t\t\toldestA = lastItem( ancestryA );\n\t\t\toldestB = lastItem( ancestryB );\n\t\t}\n\n\t\t// now that we have the mutual ancestor, we can find which is earliest\n\t\toldestA = oldestA.component || oldestA;\n\t\toldestB = oldestB.component || oldestB;\n\n\t\tvar fragmentA = oldestA.parentFragment;\n\t\tvar fragmentB = oldestB.parentFragment;\n\n\t\t// if both items share a parent fragment, our job is easy\n\t\tif ( fragmentA === fragmentB ) {\n\t\t\tvar indexA = fragmentA.items.indexOf( oldestA );\n\t\t\tvar indexB = fragmentB.items.indexOf( oldestB );\n\n\t\t\t// if it's the same index, it means one contains the other,\n\t\t\t// so we see which has the longest ancestry\n\t\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t\t}\n\n\t\t// if mutual ancestor is a section, we first test to see which section\n\t\t// fragment comes first\n\t\tvar fragments = mutualAncestor.iterations;\n\t\tif ( fragments ) {\n\t\t\tvar indexA$1 = fragments.indexOf( fragmentA );\n\t\t\tvar indexB$1 = fragments.indexOf( fragmentB );\n\n\t\t\treturn ( indexA$1 - indexB$1 ) || ancestryA.length - ancestryB.length;\n\t\t}\n\n\t\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t}\n\n\tfunction getParent ( item ) {\n\t\tvar parentFragment = item.parentFragment;\n\n\t\tif ( parentFragment ) return parentFragment.owner;\n\n\t\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\t\treturn parentFragment.owner;\n\t\t}\n\t}\n\n\tfunction getAncestry ( item ) {\n\t\tvar ancestry = [ item ];\n\t\tvar ancestor = getParent( item );\n\n\t\twhile ( ancestor ) {\n\t\t\tancestry.push( ancestor );\n\t\t\tancestor = getParent( ancestor );\n\t\t}\n\n\t\treturn ancestry;\n\t}\n\n\n\tvar Query = function Query ( ractive, selector, live, isComponentQuery ) {\n\t\tthis.ractive = ractive;\n\t\tthis.selector = selector;\n\t\tthis.live = live;\n\t\tthis.isComponentQuery = isComponentQuery;\n\n\t\tthis.result = [];\n\n\t\tthis.dirty = true;\n\t};\n\n\tQuery.prototype.add = function add ( item ) {\n\t\tthis.result.push( item );\n\t\tthis.makeDirty();\n\t};\n\n\tQuery.prototype.cancel = function cancel () {\n\t\tvar liveQueries = this._root[ this.isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\t\tvar selector = this.selector;\n\n\t\tvar index = liveQueries.indexOf( selector );\n\n\t\tif ( index !== -1 ) {\n\t\t\tliveQueries.splice( index, 1 );\n\t\t\tliveQueries[ selector ] = null;\n\t\t}\n\t};\n\n\tQuery.prototype.init = function init () {\n\t\tthis.dirty = false;\n\t};\n\n\tQuery.prototype.makeDirty = function makeDirty () {\n\t\tvar this$1 = this;\n\n\t\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\n\t\t\t// Once the DOM has been updated, ensure the query\n\t\t\t// is correctly ordered\n\t\t\trunloop.scheduleTask( function () { return this$1.update(); } );\n\t\t}\n\t};\n\n\tQuery.prototype.remove = function remove ( nodeOrComponent ) {\n\t\tvar index = this.result.indexOf( this.isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\t\tif ( index !== -1 ) this.result.splice( index, 1 );\n\t};\n\n\tQuery.prototype.update = function update () {\n\t\tthis.result.sort( this.isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\t\tthis.dirty = false;\n\t};\n\n\tQuery.prototype.test = function test ( item ) {\n\t\treturn this.isComponentQuery ?\n\t\t\t( !this.selector || item.name === this.selector ) :\n\t\t\t( item ? matches( item, this.selector ) : null );\n\t};\n\n\tfunction Ractive$findAll ( selector, options ) {\n\t\tif ( !this.el ) throw new Error( (\"Cannot call ractive.findAll('\" + selector + \"', ...) unless instance is rendered to the DOM\") );\n\n\t\toptions = options || {};\n\t\tvar liveQueries = this._liveQueries;\n\n\t\t// Shortcut: if we're maintaining a live query with this\n\t\t// selector, we don't need to traverse the parallel DOM\n\t\tvar query = liveQueries[ selector ];\n\t\tif ( query ) {\n\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\treturn ( options && options.live ) ? query : query.slice();\n\t\t}\n\n\t\tquery = new Query( this, selector, !!options.live, false );\n\n\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t// if applicable\n\t\tif ( query.live ) {\n\t\t\tliveQueries.push( selector );\n\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t}\n\n\t\tthis.fragment.findAll( selector, query );\n\n\t\tquery.init();\n\t\treturn query.result;\n\t}\n\n\tfunction Ractive$findAllComponents ( selector, options ) {\n\t\toptions = options || {};\n\t\tvar liveQueries = this._liveComponentQueries;\n\n\t\t// Shortcut: if we're maintaining a live query with this\n\t\t// selector, we don't need to traverse the parallel DOM\n\t\tvar query = liveQueries[ selector ];\n\t\tif ( query ) {\n\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\treturn ( options && options.live ) ? query : query.slice();\n\t\t}\n\n\t\tquery = new Query( this, selector, !!options.live, true );\n\n\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t// if applicable\n\t\tif ( query.live ) {\n\t\t\tliveQueries.push( selector );\n\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t}\n\n\t\tthis.fragment.findAllComponents( selector, query );\n\n\t\tquery.init();\n\t\treturn query.result;\n\t}\n\n\tfunction Ractive$findComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t}\n\n\tfunction Ractive$findContainer ( selector ) {\n\t\tif ( this.container ) {\n\t\t\tif ( this.container.component && this.container.component.name === selector ) {\n\t\t\t\treturn this.container;\n\t\t\t} else {\n\t\t\t\treturn this.container.findContainer( selector );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction Ractive$findParent ( selector ) {\n\n\t\tif ( this.parent ) {\n\t\t\tif ( this.parent.component && this.parent.component.name === selector ) {\n\t\t\t\treturn this.parent;\n\t\t\t} else {\n\t\t\t\treturn this.parent.findParent ( selector );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction enqueue ( ractive, event ) {\n\t\tif ( ractive.event ) {\n\t\t\tractive._eventQueue.push( ractive.event );\n\t\t}\n\n\t\tractive.event = event;\n\t}\n\n\tfunction dequeue ( ractive ) {\n\t\tif ( ractive._eventQueue.length ) {\n\t\t\tractive.event = ractive._eventQueue.pop();\n\t\t} else {\n\t\t\tractive.event = null;\n\t\t}\n\t}\n\n\tvar starMaps = {};\n\n\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t// all the variants of that keypath that include a wildcard in place\n\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t// to see if any pattern observers are downstream of one or more of\n\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\tfunction getPotentialWildcardMatches ( keypath ) {\n\t\tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\n\t\tkeys = splitKeypathI( keypath );\n\t\tif( !( starMap = starMaps[ keys.length ]) ) {\n\t\t\tstarMap = getStarMap( keys.length );\n\t\t}\n\n\t\tresult = [];\n\n\t\tmapper = function ( star, i ) {\n\t\t\treturn star ? '*' : keys[i];\n\t\t};\n\n\t\ti = starMap.length;\n\t\twhile ( i-- ) {\n\t\t\twildcardKeypath = starMap[i].map( mapper ).join( '.' );\n\n\t\t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n\t\t\t\tresult.push( wildcardKeypath );\n\t\t\t\tresult[ wildcardKeypath ] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// This function returns all the possible true/false combinations for\n\t// a given number - e.g. for two, the possible combinations are\n\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t// It does so by getting all the binary values between 0 and e.g. 11\n\tfunction getStarMap ( num ) {\n\t\tvar ones = '', max, binary, starMap, mapper, i, j, l, map;\n\n\t\tif ( !starMaps[ num ] ) {\n\t\t\tstarMap = [];\n\n\t\t\twhile ( ones.length < num ) {\n\t\t\t\tones += 1;\n\t\t\t}\n\n\t\t\tmax = parseInt( ones, 2 );\n\n\t\t\tmapper = function ( digit ) {\n\t\t\t\treturn digit === '1';\n\t\t\t};\n\n\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\twhile ( binary.length < num ) {\n\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t}\n\n\t\t\t\tmap = [];\n\t\t\t\tl = binary.length;\n\t\t\t\tfor (j = 0; j < l; j++) {\n\t\t\t\t\tmap.push( mapper( binary[j] ) );\n\t\t\t\t}\n\t\t\t\tstarMap[i] = map;\n\t\t\t}\n\n\t\t\tstarMaps[ num ] = starMap;\n\t\t}\n\n\t\treturn starMaps[ num ];\n\t}\n\n\tvar wildcardCache = {};\n\n\tfunction fireEvent ( ractive, eventName, options ) {\n\t\tif ( options === void 0 ) options = {};\n\n\t\tif ( !eventName ) { return; }\n\n\t\tif ( !options.event ) {\n\t\t\toptions.event = {\n\t\t\t\tname: eventName,\n\t\t\t\t// until event not included as argument default\n\t\t\t\t_noArg: true\n\t\t\t};\n\t\t} else {\n\t\t\toptions.event.name = eventName;\n\t\t}\n\n\t\tvar eventNames = getWildcardNames( eventName );\n\n\t\treturn fireEventAs( ractive, eventNames, options.event, options.args, true );\n\t}\n\n\tfunction getWildcardNames ( eventName ) {\n\t\tif ( wildcardCache.hasOwnProperty( eventName ) ) {\n\t\t\treturn wildcardCache[ eventName ];\n\t\t} else {\n\t\t\treturn wildcardCache[ eventName ] = getPotentialWildcardMatches( eventName );\n\t\t}\n\t}\n\n\tfunction fireEventAs  ( ractive, eventNames, event, args, initialFire ) {\n\n\t\tif ( initialFire === void 0 ) initialFire = false;\n\n\t\tvar subscribers, i, bubble = true;\n\n\t\tenqueue( ractive, event );\n\n\t\tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t\t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\n\t\t\tif ( subscribers ) {\n\t\t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t\t\t}\n\t\t}\n\n\t\tdequeue( ractive );\n\n\t\tif ( ractive.parent && bubble ) {\n\n\t\t\tif ( initialFire && ractive.component ) {\n\t\t\t\tvar fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];\n\t\t\t\teventNames = getWildcardNames( fullName );\n\n\t\t\t\tif( event && !event.component ) {\n\t\t\t\t\tevent.component = ractive;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfireEventAs( ractive.parent, eventNames, event, args );\n\t\t}\n\n\t\treturn bubble;\n\t}\n\n\tfunction notifySubscribers ( ractive, subscribers, event, args ) {\n\t\tvar originalEvent = null, stopEvent = false;\n\n\t\tif ( event && !event._noArg ) {\n\t\t\targs = [ event ].concat( args );\n\t\t}\n\n\t\t// subscribers can be modified inflight, e.g. \"once\" functionality\n\t\t// so we need to copy to make sure everyone gets called\n\t\tsubscribers = subscribers.slice();\n\n\t\tfor ( var i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t\t\tif ( !subscribers[ i ].off && subscribers[ i ].apply( ractive, args ) === false ) {\n\t\t\t\tstopEvent = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t\t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t\t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t\t}\n\n\t\treturn !stopEvent;\n\t}\n\n\tfunction Ractive$fire ( eventName ) {\n\t\tvar args = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t\treturn fireEvent( this, eventName, { args: args });\n\t}\n\n\tfunction badReference ( key ) {\n\t\tthrow new Error( (\"An index or key reference (\" + key + \") cannot have child properties\") );\n\t}\n\n\tfunction resolveAmbiguousReference ( fragment, ref ) {\n\t\tvar localViewmodel = fragment.findContext().root;\n\t\tvar keys = splitKeypathI( ref );\n\t\tvar key = keys[0];\n\n\t\tvar hasContextChain;\n\t\tvar crossedComponentBoundary;\n\t\tvar aliases;\n\n\t\twhile ( fragment ) {\n\t\t\t// repeated fragments\n\t\t\tif ( fragment.isIteration ) {\n\t\t\t\tif ( key === fragment.parent.keyRef ) {\n\t\t\t\t\tif ( keys.length > 1 ) badReference( key );\n\t\t\t\t\treturn fragment.context.getKeyModel( fragment.key );\n\t\t\t\t}\n\n\t\t\t\tif ( key === fragment.parent.indexRef ) {\n\t\t\t\t\tif ( keys.length > 1 ) badReference( key );\n\t\t\t\t\treturn fragment.context.getKeyModel( fragment.index );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// alias node or iteration\n\t\t\tif ( ( ( aliases = fragment.owner.aliases ) || ( aliases = fragment.aliases ) ) && aliases.hasOwnProperty( key ) ) {\n\t\t\t\tvar model = aliases[ key ];\n\n\t\t\t\tif ( keys.length === 1 ) return model;\n\t\t\t\telse if ( typeof model.joinAll === 'function' ) {\n\t\t\t\t\treturn model.joinAll( keys.slice( 1 ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fragment.context ) {\n\t\t\t\t// TODO better encapsulate the component check\n\t\t\t\tif ( !fragment.isRoot || fragment.ractive.component ) hasContextChain = true;\n\n\t\t\t\tif ( fragment.context.has( key ) ) {\n\t\t\t\t\tif ( crossedComponentBoundary ) {\n\t\t\t\t\t\treturn localViewmodel.createLink( key, fragment.context.joinKey( keys.shift() ), key ).joinAll( keys );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fragment.context.joinAll( keys );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n\t\t\t\t// ascend through component boundary\n\t\t\t\tfragment = fragment.componentParent;\n\t\t\t\tcrossedComponentBoundary = true;\n\t\t\t} else {\n\t\t\t\tfragment = fragment.parent;\n\t\t\t}\n\t\t}\n\n\t\tif ( !hasContextChain ) {\n\t\t\treturn localViewmodel.joinAll( keys );\n\t\t}\n\t}\n\n\tvar stack = [];\n\tvar captureGroup;\n\n\tfunction startCapturing () {\n\t\tstack.push( captureGroup = [] );\n\t}\n\n\tfunction stopCapturing () {\n\t\tvar dependencies = stack.pop();\n\t\tcaptureGroup = stack[ stack.length - 1 ];\n\t\treturn dependencies;\n\t}\n\n\tfunction capture ( model ) {\n\t\tif ( captureGroup ) {\n\t\t\tcaptureGroup.push( model );\n\t\t}\n\t}\n\n\tvar KeyModel = function KeyModel ( key, parent ) {\n\t\tthis.value = key;\n\t\tthis.isReadonly = this.isKey = true;\n\t\tthis.deps = [];\n\t\tthis.links = [];\n\t\tthis.parent = parent;\n\t};\n\n\tKeyModel.prototype.get = function get ( shouldCapture ) {\n\t\tif ( shouldCapture ) capture( this );\n\t\treturn unescapeKey( this.value );\n\t};\n\n\tKeyModel.prototype.getKeypath = function getKeypath () {\n\t\treturn unescapeKey( this.value );\n\t};\n\n\tKeyModel.prototype.rebinding = function rebinding ( next, previous ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar i = this.deps.length;\n\t\twhile ( i-- ) this$1.deps[i].rebinding( next, previous, false );\n\n\t\ti = this.links.length;\n\t\twhile ( i-- ) this$1.links[i].rebinding( next, previous, false );\n\t};\n\n\tKeyModel.prototype.register = function register ( dependant ) {\n\t\tthis.deps.push( dependant );\n\t};\n\n\tKeyModel.prototype.registerLink = function registerLink ( link ) {\n\t\taddToArray( this.links, link );\n\t};\n\n\tKeyModel.prototype.unregister = function unregister ( dependant ) {\n\t\tremoveFromArray( this.deps, dependant );\n\t};\n\n\tKeyModel.prototype.unregisterLink = function unregisterLink ( link ) {\n\t\tremoveFromArray( this.links, link );\n\t};\n\n\tfunction bind$1               ( x ) { x.bind(); }\n\tfunction cancel             ( x ) { x.cancel(); }\n\tfunction handleChange       ( x ) { x.handleChange(); }\n\tfunction mark               ( x ) { x.mark(); }\n\tfunction marked             ( x ) { x.marked(); }\n\tfunction notifiedUpstream   ( x ) { x.notifiedUpstream(); }\n\tfunction render             ( x ) { x.render(); }\n\tfunction teardown           ( x ) { x.teardown(); }\n\tfunction unbind             ( x ) { x.unbind(); }\n\tfunction unrender           ( x ) { x.unrender(); }\n\tfunction unrenderAndDestroy ( x ) { x.unrender( true ); }\n\tfunction update             ( x ) { x.update(); }\n\tfunction toString$1           ( x ) { return x.toString(); }\n\tfunction toEscapedString    ( x ) { return x.toString( true ); }\n\n\tvar KeypathModel = function KeypathModel ( parent, ractive ) {\n\t\tthis.parent = parent;\n\t\tthis.ractive = ractive;\n\t\tthis.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();\n\t\tthis.deps = [];\n\t\tthis.children = {};\n\t\tthis.isReadonly = this.isKeypath = true;\n\t};\n\n\tKeypathModel.prototype.get = function get ( shouldCapture ) {\n\t\tif ( shouldCapture ) capture( this );\n\t\treturn this.value;\n\t};\n\n\tKeypathModel.prototype.getChild = function getChild ( ractive ) {\n\t\tif ( !( ractive._guid in this.children ) ) {\n\t\t\tvar model = new KeypathModel( this.parent, ractive );\n\t\t\tthis.children[ ractive._guid ] = model;\n\t\t\tmodel.owner = this;\n\t\t}\n\t\treturn this.children[ ractive._guid ];\n\t};\n\n\tKeypathModel.prototype.getKeypath = function getKeypath () {\n\t\treturn this.value;\n\t};\n\n\tKeypathModel.prototype.handleChange = function handleChange$1 () {\n\t\tvar this$1 = this;\n\n\t\t\tvar keys = Object.keys( this.children );\n\t\tvar i = keys.length;\n\t\twhile ( i-- ) {\n\t\t\tthis$1.children[ keys[i] ].handleChange();\n\t\t}\n\n\t\tthis.deps.forEach( handleChange );\n\t};\n\n\tKeypathModel.prototype.rebindChildren = function rebindChildren ( next ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar keys = Object.keys( this.children );\n\t\tvar i = keys.length;\n\t\twhile ( i-- ) {\n\t\t\tvar child = this$1.children[keys[i]];\n\t\t\tchild.value = next.getKeypath( child.ractive );\n\t\t\tchild.handleChange();\n\t\t}\n\t};\n\n\tKeypathModel.prototype.rebinding = function rebinding ( next, previous ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar model = next ? next.getKeypathModel( this.ractive ) : undefined;\n\n\t\tvar keys = Object.keys( this.children );\n\t\tvar i = keys.length;\n\t\twhile ( i-- ) {\n\t\t\tthis$1.children[ keys[i] ].rebinding( next, previous, false );\n\t\t}\n\n\t\ti = this.deps.length;\n\t\twhile ( i-- ) {\n\t\t\tthis$1.deps[i].rebinding( model, this$1, false );\n\t\t}\n\t};\n\n\tKeypathModel.prototype.register = function register ( dep ) {\n\t\tthis.deps.push( dep );\n\t};\n\n\tKeypathModel.prototype.removeChild = function removeChild( model ) {\n\t\tif ( model.ractive ) delete this.children[ model.ractive._guid ];\n\t};\n\n\tKeypathModel.prototype.teardown = function teardown () {\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.owner ) this.owner.removeChild( this );\n\n\t\tvar keys = Object.keys( this.children );\n\t\tvar i = keys.length;\n\t\twhile ( i-- ) {\n\t\t\tthis$1.children[ keys[i] ].teardown();\n\t\t}\n\t};\n\n\tKeypathModel.prototype.unregister = function unregister ( dep ) {\n\t\tremoveFromArray( this.deps, dep );\n\t\tif ( !this.deps.length ) this.teardown();\n\t};\n\n\tvar hasProp = Object.prototype.hasOwnProperty;\n\n\tvar shuffleTasks = { early: [], mark: [] };\n\tvar registerQueue = { early: [], mark: [] };\n\n\tvar ModelBase = function ModelBase ( parent ) {\n\t\tthis.deps = [];\n\n\t\tthis.children = [];\n\t\tthis.childByKey = {};\n\t\tthis.links = [];\n\n\t\tthis.keyModels = {};\n\n\t\tthis.unresolved = [];\n\t\tthis.unresolvedByKey = {};\n\n\t\tthis.bindings = [];\n\t\tthis.patternObservers = [];\n\n\t\tif ( parent ) {\n\t\t\tthis.parent = parent;\n\t\t\tthis.root = parent.root;\n\t\t}\n\t};\n\n\tModelBase.prototype.addUnresolved = function addUnresolved ( key, resolver ) {\n\t\tif ( !this.unresolvedByKey[ key ] ) {\n\t\t\tthis.unresolved.push( key );\n\t\t\tthis.unresolvedByKey[ key ] = [];\n\t\t}\n\n\t\tthis.unresolvedByKey[ key ].push( resolver );\n\t};\n\n\tModelBase.prototype.addShuffleTask = function addShuffleTask ( task, stage ) { if ( stage === void 0 ) stage = 'early';\n\n\t\tshuffleTasks[stage].push( task ); };\n\tModelBase.prototype.addShuffleRegister = function addShuffleRegister ( item, stage ) { if ( stage === void 0 ) stage = 'early';\n\n\t\tregisterQueue[stage].push({ model: this, item: item }); };\n\n\tModelBase.prototype.clearUnresolveds = function clearUnresolveds ( specificKey ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar i = this.unresolved.length;\n\n\t\twhile ( i-- ) {\n\t\t\tvar key = this$1.unresolved[i];\n\n\t\t\tif ( specificKey && key !== specificKey ) continue;\n\n\t\t\tvar resolvers = this$1.unresolvedByKey[ key ];\n\t\t\tvar hasKey = this$1.has( key );\n\n\t\t\tvar j = resolvers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\tif ( hasKey ) resolvers[j].attemptResolution();\n\t\t\t\tif ( resolvers[j].resolved ) resolvers.splice( j, 1 );\n\t\t\t}\n\n\t\t\tif ( !resolvers.length ) {\n\t\t\t\tthis$1.unresolved.splice( i, 1 );\n\t\t\t\tthis$1.unresolvedByKey[ key ] = null;\n\t\t\t}\n\t\t}\n\t};\n\n\tModelBase.prototype.findMatches = function findMatches ( keys ) {\n\t\tvar len = keys.length;\n\n\t\tvar existingMatches = [ this ];\n\t\tvar matches;\n\t\tvar i;\n\n\t\tvar loop = function (  ) {\n\t\t\tvar key = keys[i];\n\n\t\t\tif ( key === '*' ) {\n\t\t\t\tmatches = [];\n\t\t\t\texistingMatches.forEach( function ( model ) {\n\t\t\t\t\tmatches.push.apply( matches, model.getValueChildren( model.get() ) );\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tmatches = existingMatches.map( function ( model ) { return model.joinKey( key ); } );\n\t\t\t}\n\n\t\t\texistingMatches = matches;\n\t\t};\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) loop(  );\n\n\t\treturn matches;\n\t};\n\n\tModelBase.prototype.getKeyModel = function getKeyModel ( key, skip ) {\n\t\tif ( key !== undefined && !skip ) return this.parent.getKeyModel( key, true );\n\n\t\tif ( !( key in this.keyModels ) ) this.keyModels[ key ] = new KeyModel( escapeKey( key ), this );\n\n\t\treturn this.keyModels[ key ];\n\t};\n\n\tModelBase.prototype.getKeypath = function getKeypath ( ractive ) {\n\t\tif ( ractive !== this.ractive && this._link ) return this._link.target.getKeypath( ractive );\n\n\t\tif ( !this.keypath ) {\n\t\t\tthis.keypath = this.parent.isRoot ? this.key : (\"\" + (this.parent.getKeypath( ractive )) + \".\" + (escapeKey( this.key )));\n\t\t}\n\n\t\treturn this.keypath;\n\t};\n\n\tModelBase.prototype.getValueChildren = function getValueChildren ( value ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar children;\n\t\tif ( isArray( value ) ) {\n\t\t\tchildren = [];\n\t\t\tif ( 'length' in this && this.length !== value.length ) {\n\t\t\t\tchildren.push( this.joinKey( 'length' ) );\n\t\t\t}\n\t\t\tvalue.forEach( function ( m, i ) {\n\t\t\t\tchildren.push( this$1.joinKey( i ) );\n\t\t\t});\n\t\t}\n\n\t\telse if ( isObject( value ) || typeof value === 'function' ) {\n\t\t\tchildren = Object.keys( value ).map( function ( key ) { return this$1.joinKey( key ); } );\n\t\t}\n\n\t\telse if ( value != null ) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn children;\n\t};\n\n\tModelBase.prototype.getVirtual = function getVirtual ( shouldCapture ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar value = this.get( shouldCapture, { virtual: false } );\n\t\tif ( isObject( value ) ) {\n\t\t\tvar result = isArray( value ) ? [] : {};\n\n\t\t\tvar keys = Object.keys( value );\n\t\t\tvar i = keys.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar child = this$1.childByKey[ keys[i] ];\n\t\t\t\tif ( !child ) result[ keys[i] ] = value[ keys[i] ];\n\t\t\t\telse if ( child._link ) result[ keys[i] ] = child._link.getVirtual();\n\t\t\t\telse result[ keys[i] ] = child.getVirtual();\n\t\t\t}\n\n\t\t\ti = this.children.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar child$1 = this$1.children[i];\n\t\t\t\tif ( !( child$1.key in result ) && child$1._link ) {\n\t\t\t\t\tresult[ child$1.key ] = child$1._link.getVirtual();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} else return value;\n\t};\n\n\tModelBase.prototype.has = function has ( key ) {\n\t\tif ( this._link ) return this._link.has( key );\n\n\t\tvar value = this.get();\n\t\tif ( !value ) return false;\n\n\t\tkey = unescapeKey( key );\n\t\tif ( hasProp.call( value, key ) ) return true;\n\n\t\t// We climb up the constructor chain to find if one of them contains the key\n\t\tvar constructor = value.constructor;\n\t\twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n\t\t\tif ( hasProp.call( constructor.prototype, key ) ) return true;\n\t\t\tconstructor = constructor.constructor;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tModelBase.prototype.joinAll = function joinAll ( keys, opts ) {\n\t\tvar model = this;\n\t\tfor ( var i = 0; i < keys.length; i += 1 ) {\n\t\t\tif ( opts && opts.lastLink === false && i + 1 === keys.length && model.childByKey[keys[i]] && model.childByKey[keys[i]]._link ) return model.childByKey[keys[i]];\n\t\t\tmodel = model.joinKey( keys[i], opts );\n\t\t}\n\n\t\treturn model;\n\t};\n\n\tModelBase.prototype.notifyUpstream = function notifyUpstream () {\n\t\tvar parent = this.parent, path = [ this.key ];\n\t\twhile ( parent ) {\n\t\t\tif ( parent.patternObservers.length ) parent.patternObservers.forEach( function ( o ) { return o.notify( path.slice() ); } );\n\t\t\tpath.unshift( parent.key );\n\t\t\tparent.links.forEach( notifiedUpstream );\n\t\t\tparent.deps.forEach( handleChange );\n\t\t\tparent = parent.parent;\n\t\t}\n\t};\n\n\tModelBase.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t// tell the deps to move to the new target\n\t\tvar this$1 = this;\n\n\t\t\tvar i = this.deps.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( this$1.deps[i].rebinding ) this$1.deps[i].rebinding( next, previous, safe );\n\t\t}\n\n\t\ti = this.links.length;\n\t\twhile ( i-- ) {\n\t\t\tvar link = this$1.links[i];\n\t\t\t// only relink the root of the link tree\n\t\t\tif ( link.owner._link ) link.relinking( next, true, safe );\n\t\t}\n\n\t\ti = this.children.length;\n\t\twhile ( i-- ) {\n\t\t\tvar child = this$1.children[i];\n\t\t\tchild.rebinding( next ? next.joinKey( child.key ) : undefined, child, safe );\n\t\t}\n\n\t\ti = this.unresolved.length;\n\t\twhile ( i-- ) {\n\t\t\tvar unresolved = this$1.unresolvedByKey[ this$1.unresolved[i] ];\n\t\t\tvar c = unresolved.length;\n\t\t\twhile ( c-- ) {\n\t\t\t\tunresolved[c].rebinding( next, previous );\n\t\t\t}\n\t\t}\n\n\t\tif ( this.keypathModel ) this.keypathModel.rebinding( next, previous, false );\n\n\t\ti = this.bindings.length;\n\t\twhile ( i-- ) {\n\t\t\tthis$1.bindings[i].rebinding( next, previous, safe );\n\t\t}\n\t};\n\n\tModelBase.prototype.register = function register ( dep ) {\n\t\tthis.deps.push( dep );\n\t};\n\n\tModelBase.prototype.registerChange = function registerChange ( key, value ) {\n\t\tif ( !this.isRoot ) {\n\t\t\tthis.root.registerChange( key, value );\n\t\t} else {\n\t\t\tthis.changes[ key ] = value;\n\t\t\trunloop.addInstance( this.root.ractive );\n\t\t}\n\t};\n\n\tModelBase.prototype.registerLink = function registerLink ( link ) {\n\t\taddToArray( this.links, link );\n\t};\n\n\tModelBase.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {\n\t\tthis.patternObservers.push( observer );\n\t\tthis.register( observer );\n\t};\n\n\tModelBase.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {\n\t\tthis.bindings.push( binding );\n\t};\n\n\tModelBase.prototype.removeUnresolved = function removeUnresolved ( key, resolver ) {\n\t\tvar resolvers = this.unresolvedByKey[ key ];\n\n\t\tif ( resolvers ) {\n\t\t\tremoveFromArray( resolvers, resolver );\n\t\t}\n\t};\n\n\tModelBase.prototype.shuffled = function shuffled () {\n\t\tvar this$1 = this;\n\n\t\t\tvar i = this.children.length;\n\t\twhile ( i-- ) {\n\t\t\tthis$1.children[i].shuffled();\n\t\t}\n\t\tif ( this.wrapper ) {\n\t\t\tthis.wrapper.teardown();\n\t\t\tthis.wrapper = null;\n\t\t\tthis.rewrap = true;\n\t\t}\n\t};\n\n\tModelBase.prototype.unregister = function unregister ( dependant ) {\n\t\tremoveFromArray( this.deps, dependant );\n\t};\n\n\tModelBase.prototype.unregisterLink = function unregisterLink ( link ) {\n\t\tremoveFromArray( this.links, link );\n\t};\n\n\tModelBase.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {\n\t\tremoveFromArray( this.patternObservers, observer );\n\t\tthis.unregister( observer );\n\t};\n\n\tModelBase.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {\n\t\tremoveFromArray( this.bindings, binding );\n\t};\n\n\tModelBase.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar i = this.bindings.length;\n\t\twhile ( i-- ) {\n\t\t\tvar value = this$1.bindings[i].getValue();\n\t\t\tif ( value !== this$1.value ) this$1.set( value );\n\t\t}\n\n\t\t// check for one-way bindings if there are no two-ways\n\t\tif ( !this.bindings.length ) {\n\t\t\tvar oneway = findBoundValue( this.deps );\n\t\t\tif ( oneway && oneway.value !== this.value ) this.set( oneway.value );\n\t\t}\n\n\t\tif ( cascade ) {\n\t\t\tthis.children.forEach( updateFromBindings );\n\t\t\tthis.links.forEach( updateFromBindings );\n\t\t\tif ( this._link ) this._link.updateFromBindings( cascade );\n\t\t}\n\t};\n\n\tfunction updateFromBindings ( model ) {\n\t\tmodel.updateFromBindings( true );\n\t}\n\n\tfunction findBoundValue( list ) {\n\t\tvar i = list.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( list[i].bound ) {\n\t\t\t\tvar owner = list[i].owner;\n\t\t\t\tif ( owner ) {\n\t\t\t\t\tvar value = owner.name === 'checked' ?\n\t\t\t\t\t\towner.node.checked :\n\t\t\t\t\t\towner.node.value;\n\t\t\t\t\treturn { value: value };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction fireShuffleTasks ( stage ) {\n\t\tif ( !stage ) {\n\t\t\tfireShuffleTasks( 'early' );\n\t\t\tfireShuffleTasks( 'mark' );\n\t\t} else {\n\t\t\tvar tasks = shuffleTasks[stage];\n\t\t\tshuffleTasks[stage] = [];\n\t\t\tvar i = tasks.length;\n\t\t\twhile ( i-- ) tasks[i]();\n\n\t\t\tvar register = registerQueue[stage];\n\t\t\tregisterQueue[stage] = [];\n\t\t\ti = register.length;\n\t\t\twhile ( i-- ) register[i].model.register( register[i].item );\n\t\t}\n\t}\n\n\tKeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n\tKeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n\tKeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n\tKeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n\n\t// this is the dry method of checking to see if a rebind applies to\n\t// a particular keypath because in some cases, a dep may be bound\n\t// directly to a particular keypath e.g. foo.bars.0.baz and need\n\t// to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\n\tfunction rebindMatch ( template, next, previous ) {\n\t\tvar keypath = template.r || template;\n\n\t\t// no valid keypath, go with next\n\t\tif ( !keypath || typeof keypath !== 'string' ) return next;\n\n\t\t// completely contextual ref, go with next\n\t\tif ( keypath === '.' || keypath[0] === '@' || (next || previous).isKey || (next || previous).isKeypath ) return next;\n\n\t\tvar parts = keypath.split( '/' );\n\t\tvar keys = splitKeypathI( parts[ parts.length - 1 ] );\n\n\t\t// check the keypath against the model keypath to see if it matches\n\t\tvar model = next || previous;\n\t\tvar i = keys.length;\n\t\tvar match = true, shuffling = false;\n\n\t\twhile ( model && i-- ) {\n\t\t\tif ( model.shuffling ) shuffling = true;\n\t\t\t// non-strict comparison to account for indices in keypaths\n\t\t\tif ( keys[i] != model.key ) match = false;\n\t\t\tmodel = model.parent;\n\t\t}\n\n\t\t// next is undefined, but keypath is shuffling and previous matches\n\t\tif ( !next && match && shuffling ) return previous;\n\t\t// next is defined, but doesn't match the keypath\n\t\telse if ( next && !match && shuffling ) return previous;\n\t\telse return next;\n\t}\n\n\tvar LinkModel = (function (ModelBase) {\n\t\tfunction LinkModel ( parent, owner, target, key ) {\n\t\t\tModelBase.call( this, parent );\n\n\t\t\tthis.owner = owner;\n\t\t\tthis.target = target;\n\t\t\tthis.key = key === undefined ? owner.key : key;\n\t\t\tif ( owner.isLink ) this.sourcePath = \"\" + (owner.sourcePath) + \".\" + (this.key);\n\n\t\t\ttarget.registerLink( this );\n\n\t\t\tthis.isReadonly = parent.isReadonly;\n\n\t\t\tthis.isLink = true;\n\t\t}\n\n\t\tLinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n\t\tLinkModel.prototype.constructor = LinkModel;\n\n\t\tLinkModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n\t\t\treturn this.target.animate( from, to, options, interpolator );\n\t\t};\n\n\t\tLinkModel.prototype.applyValue = function applyValue ( value ) {\n\t\t\tthis.target.applyValue( value );\n\t\t};\n\n\t\tLinkModel.prototype.get = function get ( shouldCapture, opts ) {\n\t\t\tif ( shouldCapture ) {\n\t\t\t\tcapture( this );\n\n\t\t\t\t// may need to tell the target to unwrap\n\t\t\t\topts = opts || {};\n\t\t\t\topts.unwrap = true;\n\t\t\t}\n\n\t\t\treturn this.target.get( false, opts );\n\t\t};\n\n\t\tLinkModel.prototype.getKeypath = function getKeypath ( ractive ) {\n\t\t\tif ( ractive && ractive !== this.root.ractive ) return this.target.getKeypath( ractive );\n\n\t\t\treturn ModelBase.prototype.getKeypath.call( this, ractive );\n\t\t};\n\n\t\tLinkModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n\t\t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n\t\t\tif ( ractive && ractive !== this.root.ractive ) return this.keypathModel.getChild( ractive );\n\t\t\treturn this.keypathModel;\n\t\t};\n\n\t\tLinkModel.prototype.handleChange = function handleChange$1 () {\n\t\t\tthis.deps.forEach( handleChange );\n\t\t\tthis.links.forEach( handleChange );\n\t\t\tthis.notifyUpstream();\n\t\t};\n\n\t\tLinkModel.prototype.joinKey = function joinKey ( key ) {\n\t\t\t// TODO: handle nested links\n\t\t\tif ( key === undefined || key === '' ) return this;\n\n\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar child = new LinkModel( this, this, this.target.joinKey( key ), key );\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t}\n\n\t\t\treturn this.childByKey[ key ];\n\t\t};\n\n\t\tLinkModel.prototype.mark = function mark () {\n\t\t\tthis.target.mark();\n\t\t};\n\n\t\tLinkModel.prototype.marked = function marked$1 () {\n\t\t\tthis.links.forEach( marked );\n\n\t\t\tthis.deps.forEach( handleChange );\n\t\t\tthis.clearUnresolveds();\n\t\t};\n\n\t\tLinkModel.prototype.notifiedUpstream = function notifiedUpstream$1 () {\n\t\t\tthis.links.forEach( notifiedUpstream );\n\t\t\tthis.deps.forEach( handleChange );\n\t\t};\n\n\t\tLinkModel.prototype.relinked = function relinked () {\n\t\t\tthis.target.registerLink( this );\n\t\t\tthis.children.forEach( function ( c ) { return c.relinked(); } );\n\t\t};\n\n\t\tLinkModel.prototype.relinking = function relinking ( target, root, safe ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( root && this.sourcePath ) target = rebindMatch( this.sourcePath, target, this.target );\n\t\t\tif ( !target || this.target === target ) return;\n\n\t\t\tthis.target.unregisterLink( this );\n\t\t\tif ( this.keypathModel ) this.keypathModel.rebindChildren( target );\n\n\t\t\tthis.target = target;\n\t\t\tthis.children.forEach( function ( c ) {\n\t\t\t\tc.relinking( target.joinKey( c.key ), false, safe );\n\t\t\t});\n\n\t\t\tif ( root ) this.addShuffleTask( function () {\n\t\t\t\tthis$1.relinked();\n\t\t\t\tif ( !safe ) this$1.notifyUpstream();\n\t\t\t});\n\t\t};\n\n\t\tLinkModel.prototype.set = function set ( value ) {\n\t\t\tthis.target.set( value );\n\t\t};\n\n\t\tLinkModel.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\t// watch for extra shuffles caused by a shuffle in a downstream link\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( this.shuffling ) return;\n\n\t\t\t// let the real model handle firing off shuffles\n\t\t\tif ( !this.target.shuffling ) {\n\t\t\t\tthis.target.shuffle( newIndices );\n\t\t\t} else {\n\t\t\t\tthis.shuffling = true;\n\n\t\t\t\tvar i = newIndices.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar idx = newIndices[ i ];\n\t\t\t\t\t// nothing is actually changing, so move in the index and roll on\n\t\t\t\t\tif ( i === idx ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// rebind the children on i to idx\n\t\t\t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\n\t\t\t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n\t\t\t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n\t\t\t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar upstream = this.source().length !== this.source().value.length;\n\n\t\t\t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n\n\t\t\t\ti = this.deps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n\t\t\t\t}\n\n\t\t\t\tthis.marked();\n\n\t\t\t\tif ( upstream ) this.notifyUpstream();\n\n\t\t\t\tthis.shuffling = false;\n\t\t\t}\n\n\t\t};\n\n\t\tLinkModel.prototype.source = function source () {\n\t\t\tif ( this.target.source ) return this.target.source();\n\t\t\telse return this.target;\n\t\t};\n\n\t\tLinkModel.prototype.teardown = function teardown$1 () {\n\t\t\tif ( this._link ) this._link.teardown();\n\t\t\tthis.children.forEach( teardown );\n\t\t};\n\n\t\treturn LinkModel;\n\t}(ModelBase));\n\n\tModelBase.prototype.link = function link ( model, keypath ) {\n\t\tvar lnk = this._link || new LinkModel( this.parent, this, model, this.key );\n\t\tlnk.sourcePath = keypath;\n\t\tif ( this._link ) this._link.relinking( model, true, false );\n\t\tthis.rebinding( lnk, this, false );\n\t\tfireShuffleTasks();\n\n\t\tvar unresolved = !this._link;\n\t\tthis._link = lnk;\n\t\tif ( unresolved ) this.parent.clearUnresolveds();\n\t\tlnk.marked();\n\t\treturn lnk;\n\t};\n\n\tModelBase.prototype.unlink = function unlink () {\n\t\tif ( this._link ) {\n\t\t\tvar ln = this._link;\n\t\t\tthis._link = undefined;\n\t\t\tln.rebinding( this, this._link );\n\t\t\tfireShuffleTasks();\n\t\t\tln.teardown();\n\t\t}\n\t};\n\n\tvar requestAnimationFrame;\n\n\t// If window doesn't exist, we don't need requestAnimationFrame\n\tif ( !win ) {\n\t\trequestAnimationFrame = null;\n\t} else {\n\t\t// https://gist.github.com/paulirish/1579671\n\t\t(function(vendors, lastTime, win) {\n\n\t\t\tvar x, setTimeout;\n\n\t\t\tif ( win.requestAnimationFrame ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor ( x = 0; x < vendors.length && !win.requestAnimationFrame; ++x ) {\n\t\t\t\twin.requestAnimationFrame = win[vendors[x]+'RequestAnimationFrame'];\n\t\t\t}\n\n\t\t\tif ( !win.requestAnimationFrame ) {\n\t\t\t\tsetTimeout = win.setTimeout;\n\n\t\t\t\twin.requestAnimationFrame = function(callback) {\n\t\t\t\t\tvar currTime, timeToCall, id;\n\n\t\t\t\t\tcurrTime = Date.now();\n\t\t\t\t\ttimeToCall = Math.max( 0, 16 - (currTime - lastTime ) );\n\t\t\t\t\tid = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );\n\n\t\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\t\treturn id;\n\t\t\t\t};\n\t\t\t}\n\n\t\t}( vendors, 0, win ));\n\n\t\trequestAnimationFrame = win.requestAnimationFrame;\n\t}\n\n\tvar rAF = requestAnimationFrame;\n\n\tvar getTime = ( win && win.performance && typeof win.performance.now === 'function' ) ?\n\t\tfunction () { return win.performance.now(); } :\n\t\tfunction () { return Date.now(); };\n\n\t// TODO what happens if a transition is aborted?\n\n\tvar tickers = [];\n\tvar running = false;\n\n\tfunction tick () {\n\t\trunloop.start();\n\n\t\tvar now = getTime();\n\n\t\tvar i;\n\t\tvar ticker;\n\n\t\tfor ( i = 0; i < tickers.length; i += 1 ) {\n\t\t\tticker = tickers[i];\n\n\t\t\tif ( !ticker.tick( now ) ) {\n\t\t\t\t// ticker is complete, remove it from the stack, and decrement i so we don't miss one\n\t\t\t\ttickers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\n\t\trunloop.end();\n\n\t\tif ( tickers.length ) {\n\t\t\trAF( tick );\n\t\t} else {\n\t\t\trunning = false;\n\t\t}\n\t}\n\n\tvar Ticker = function Ticker ( options ) {\n\t\tthis.duration = options.duration;\n\t\tthis.step = options.step;\n\t\tthis.complete = options.complete;\n\t\tthis.easing = options.easing;\n\n\t\tthis.start = getTime();\n\t\tthis.end = this.start + this.duration;\n\n\t\tthis.running = true;\n\n\t\ttickers.push( this );\n\t\tif ( !running ) rAF( tick );\n\t};\n\n\tTicker.prototype.tick = function tick$1 ( now ) {\n\t\tif ( !this.running ) return false;\n\n\t\tif ( now > this.end ) {\n\t\t\tif ( this.step ) this.step( 1 );\n\t\t\tif ( this.complete ) this.complete( 1 );\n\n\t\t\treturn false;\n\t\t}\n\n\t\tvar elapsed = now - this.start;\n\t\tvar eased = this.easing( elapsed / this.duration );\n\n\t\tif ( this.step ) this.step( eased );\n\n\t\treturn true;\n\t};\n\n\tTicker.prototype.stop = function stop () {\n\t\tif ( this.abort ) this.abort();\n\t\tthis.running = false;\n\t};\n\n\tvar prefixers = {};\n\n\t// TODO this is legacy. sooner we can replace the old adaptor API the better\n\tfunction prefixKeypath ( obj, prefix ) {\n\t\tvar prefixed = {}, key;\n\n\t\tif ( !prefix ) {\n\t\t\treturn obj;\n\t\t}\n\n\t\tprefix += '.';\n\n\t\tfor ( key in obj ) {\n\t\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t\t}\n\t\t}\n\n\t\treturn prefixed;\n\t}\n\n\tfunction getPrefixer ( rootKeypath ) {\n\t\tvar rootDot;\n\n\t\tif ( !prefixers[ rootKeypath ] ) {\n\t\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n\t\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\t\tvar obj;\n\n\t\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\t\tobj = {};\n\t\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\n\t\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\treturn prefixers[ rootKeypath ];\n\t}\n\n\tvar Model = (function (ModelBase) {\n\t\tfunction Model ( parent, key ) {\n\t\t\tModelBase.call( this, parent );\n\n\t\t\tthis.ticker = null;\n\n\t\t\tif ( parent ) {\n\t\t\t\tthis.key = unescapeKey( key );\n\t\t\t\tthis.isReadonly = parent.isReadonly;\n\n\t\t\t\tif ( parent.value ) {\n\t\t\t\t\tthis.value = parent.value[ this.key ];\n\t\t\t\t\tif ( isArray( this.value ) ) this.length = this.value.length;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n\t\tModel.prototype.constructor = Model;\n\n\t\tModel.prototype.adapt = function adapt () {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar adaptors = this.root.adaptors;\n\t\t\tvar len = adaptors.length;\n\n\t\t\tthis.rewrap = false;\n\n\t\t\t// Exit early if no adaptors\n\t\t\tif ( len === 0 ) return;\n\n\t\t\tvar value = this.wrapper ? ( 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue ) : this.value;\n\n\t\t\t// TODO remove this legacy nonsense\n\t\t\tvar ractive = this.root.ractive;\n\t\t\tvar keypath = this.getKeypath();\n\n\t\t\t// tear previous adaptor down if present\n\t\t\tif ( this.wrapper ) {\n\t\t\t\tvar shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset( value ) === false;\n\n\t\t\t\tif ( shouldTeardown ) {\n\t\t\t\t\tthis.wrapper.teardown();\n\t\t\t\t\tthis.wrapper = null;\n\n\t\t\t\t\t// don't branch for undefined values\n\t\t\t\t\tif ( this.value !== undefined ) {\n\t\t\t\t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n\t\t\t\t\t\tif ( parentValue[ this.key ] !== value ) parentValue[ this.key ] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.newWrapperValue;\n\t\t\t\t\tthis.wrapperValue = value;\n\t\t\t\t\tthis.value = this.wrapper.get();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar adaptor = adaptors[i];\n\t\t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\tthis$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\t\t\tthis$1.wrapperValue = value;\n\t\t\t\t\tthis$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor\n\n\t\t\t\t\tthis$1.value = this$1.wrapper.get();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( this.ticker ) this.ticker.stop();\n\n\t\t\tvar fulfilPromise;\n\t\t\tvar promise = new Promise$1( function ( fulfil ) { return fulfilPromise = fulfil; } );\n\n\t\t\tthis.ticker = new Ticker({\n\t\t\t\tduration: options.duration,\n\t\t\t\teasing: options.easing,\n\t\t\t\tstep: function ( t ) {\n\t\t\t\t\tvar value = interpolator( t );\n\t\t\t\t\tthis$1.applyValue( value );\n\t\t\t\t\tif ( options.step ) options.step( t, value );\n\t\t\t\t},\n\t\t\t\tcomplete: function () {\n\t\t\t\t\tthis$1.applyValue( to );\n\t\t\t\t\tif ( options.complete ) options.complete( to );\n\n\t\t\t\t\tthis$1.ticker = null;\n\t\t\t\t\tfulfilPromise();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpromise.stop = this.ticker.stop;\n\t\t\treturn promise;\n\t\t};\n\n\t\tModel.prototype.applyValue = function applyValue ( value ) {\n\t\t\tif ( isEqual( value, this.value ) ) return;\n\n\t\t\t// TODO deprecate this nonsense\n\t\t\tthis.registerChange( this.getKeypath(), value );\n\n\t\t\tif ( this.parent.wrapper && this.parent.wrapper.set ) {\n\t\t\t\tthis.parent.wrapper.set( this.key, value );\n\t\t\t\tthis.parent.value = this.parent.wrapper.get();\n\n\t\t\t\tthis.value = this.parent.value[ this.key ];\n\t\t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t\t\t\tthis.adapt();\n\t\t\t} else if ( this.wrapper ) {\n\t\t\t\tthis.newWrapperValue = value;\n\t\t\t\tthis.adapt();\n\t\t\t} else {\n\t\t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n\t\t\t\tparentValue[ this.key ] = value;\n\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.adapt();\n\t\t\t}\n\n\t\t\tthis.parent.clearUnresolveds();\n\t\t\tthis.clearUnresolveds();\n\n\t\t\t// keep track of array stuff\n\t\t\tif ( isArray( value ) ) {\n\t\t\t\tthis.length = value.length;\n\t\t\t\tthis.isArray = true;\n\t\t\t} else {\n\t\t\t\tthis.isArray = false;\n\t\t\t}\n\n\t\t\t// notify dependants\n\t\t\tthis.links.forEach( handleChange );\n\t\t\tthis.children.forEach( mark );\n\t\t\tthis.deps.forEach( handleChange );\n\n\t\t\tthis.notifyUpstream();\n\n\t\t\tif ( this.parent.isArray ) {\n\t\t\t\tif ( this.key === 'length' ) this.parent.length = value;\n\t\t\t\telse this.parent.joinKey( 'length' ).mark();\n\t\t\t}\n\t\t};\n\n\t\tModel.prototype.createBranch = function createBranch ( key ) {\n\t\t\tvar branch = isNumeric( key ) ? [] : {};\n\t\t\tthis.set( branch );\n\n\t\t\treturn branch;\n\t\t};\n\n\t\tModel.prototype.get = function get ( shouldCapture, opts ) {\n\t\t\tif ( this._link ) return this._link.get( shouldCapture, opts );\n\t\t\tif ( shouldCapture ) capture( this );\n\t\t\t// if capturing, this value needs to be unwrapped because it's for external use\n\t\t\tif ( opts && opts.virtual ) return this.getVirtual( false );\n\t\t\treturn ( shouldCapture || ( opts && opts.unwrap ) ) && this.wrapper ? this.wrapperValue : this.value;\n\t\t};\n\n\t\tModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n\t\t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n\t\t\treturn this.keypathModel;\n\t\t};\n\n\t\tModel.prototype.joinKey = function joinKey ( key, opts ) {\n\t\t\tif ( this._link ) {\n\t\t\t\tif ( opts && !opts.lastLink === false && ( key === undefined || key === '' ) ) return this;\n\t\t\t\treturn this._link.joinKey( key );\n\t\t\t}\n\n\t\t\tif ( key === undefined || key === '' ) return this;\n\n\n\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar child = new Model( this, key );\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t}\n\n\t\t\tif ( this.childByKey[ key ]._link ) return this.childByKey[ key ]._link;\n\t\t\treturn this.childByKey[ key ];\n\t\t};\n\n\t\tModel.prototype.mark = function mark$1 () {\n\t\t\tif ( this._link ) return this._link.mark();\n\n\t\t\tvar value = this.retrieve();\n\n\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\tvar old = this.value;\n\t\t\t\tthis.value = value;\n\n\t\t\t\t// make sure the wrapper stays in sync\n\t\t\t\tif ( old !== value || this.rewrap ) {\n\t\t\t\t\tif ( this.wrapper ) this.newWrapperValue = value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t}\n\n\t\t\t\t// keep track of array stuff\n\t\t\t\tif ( isArray( value ) ) {\n\t\t\t\t\tthis.length = value.length;\n\t\t\t\t\tthis.isArray = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.isArray = false;\n\t\t\t\t}\n\n\t\t\t\tthis.children.forEach( mark );\n\t\t\t\tthis.links.forEach( marked );\n\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t\tthis.clearUnresolveds();\n\t\t\t}\n\t\t};\n\n\t\tModel.prototype.merge = function merge ( array, comparator ) {\n\t\t\tvar oldArray = this.value, newArray = array;\n\t\t\tif ( oldArray === newArray ) oldArray = recreateArray( this );\n\t\t\tif ( comparator ) {\n\t\t\t\toldArray = oldArray.map( comparator );\n\t\t\t\tnewArray = newArray.map( comparator );\n\t\t\t}\n\n\t\t\tvar oldLength = oldArray.length;\n\n\t\t\tvar usedIndices = {};\n\t\t\tvar firstUnusedIndex = 0;\n\n\t\t\tvar newIndices = oldArray.map( function ( item ) {\n\t\t\t\tvar index;\n\t\t\t\tvar start = firstUnusedIndex;\n\n\t\t\t\tdo {\n\t\t\t\t\tindex = newArray.indexOf( item, start );\n\n\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tstart = index + 1;\n\t\t\t\t} while ( ( usedIndices[ index ] === true ) && start < oldLength );\n\n\t\t\t\t// keep track of the first unused index, so we don't search\n\t\t\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\t\t\tif ( index === firstUnusedIndex ) {\n\t\t\t\t\tfirstUnusedIndex += 1;\n\t\t\t\t}\n\t\t\t\t// allow next instance of next \"equal\" to be found item\n\t\t\t\tusedIndices[ index ] = true;\n\t\t\t\treturn index;\n\t\t\t});\n\n\t\t\tthis.parent.value[ this.key ] = array;\n\t\t\tthis.shuffle( newIndices );\n\t\t};\n\n\t\tModel.prototype.retrieve = function retrieve () {\n\t\t\treturn this.parent.value ? this.parent.value[ this.key ] : undefined;\n\t\t};\n\n\t\tModel.prototype.set = function set ( value ) {\n\t\t\tif ( this.ticker ) this.ticker.stop();\n\t\t\tthis.applyValue( value );\n\t\t};\n\n\t\tModel.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tthis.shuffling = true;\n\t\t\tvar i = newIndices.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar idx = newIndices[ i ];\n\t\t\t\t// nothing is actually changing, so move in the index and roll on\n\t\t\t\tif ( i === idx ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// rebind the children on i to idx\n\t\t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\n\t\t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n\t\t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n\t\t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n\t\t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar upstream = this.length !== this.value.length;\n\n\t\t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n\t\t\tfireShuffleTasks( 'early' );\n\n\t\t\ti = this.deps.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n\t\t\t}\n\n\t\t\tthis.mark();\n\t\t\tfireShuffleTasks( 'mark' );\n\n\t\t\tif ( upstream ) this.notifyUpstream();\n\t\t\tthis.shuffling = false;\n\t\t};\n\n\t\tModel.prototype.teardown = function teardown$1 () {\n\t\t\tif ( this._link ) this._link.teardown();\n\t\t\tthis.children.forEach( teardown );\n\t\t\tif ( this.wrapper ) this.wrapper.teardown();\n\t\t\tif ( this.keypathModel ) this.keypathModel.teardown();\n\t\t};\n\n\t\treturn Model;\n\t}(ModelBase));\n\n\tfunction recreateArray( model ) {\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < model.length; i++ ) {\n\t\t\tarray[ i ] = (model.childByKey[i] || {}).value;\n\t\t}\n\n\t\treturn array;\n\t}\n\n\tvar GlobalModel = (function (Model) {\n\t\tfunction GlobalModel ( ) {\n\t\t\tModel.call( this, null, '@global' );\n\t\t\tthis.value = typeof global !== 'undefined' ? global : window;\n\t\t\tthis.isRoot = true;\n\t\t\tthis.root = this;\n\t\t\tthis.adaptors = [];\n\t\t}\n\n\t\tGlobalModel.prototype = Object.create( Model && Model.prototype );\n\t\tGlobalModel.prototype.constructor = GlobalModel;\n\n\t\tGlobalModel.prototype.getKeypath = function getKeypath() {\n\t\t\treturn '@global';\n\t\t};\n\n\t\t// global model doesn't contribute changes events because it has no instance\n\t\tGlobalModel.prototype.registerChange = function registerChange () {};\n\n\t\treturn GlobalModel;\n\t}(Model));\n\n\tvar GlobalModel$1 = new GlobalModel();\n\n\tvar keypathExpr = /^@[^\\(]+\\(([^\\)]+)\\)/;\n\n\tfunction resolveReference ( fragment, ref ) {\n\t\tvar context = fragment.findContext();\n\n\t\t// special references\n\t\t// TODO does `this` become `.` at parse time?\n\t\tif ( ref === '.' || ref === 'this' ) return context;\n\t\tif ( ref.indexOf( '@keypath' ) === 0 ) {\n\t\t\tvar match = keypathExpr.exec( ref );\n\t\t\tif ( match && match[1] ) {\n\t\t\t\tvar model = resolveReference( fragment, match[1] );\n\t\t\t\tif ( model ) return model.getKeypathModel();\n\t\t\t}\n\t\t\treturn context.getKeypathModel();\n\t\t}\n\t\tif ( ref.indexOf( '@rootpath' ) === 0 ) {\n\t\t\t// check to see if this is an empty component root\n\t\t\twhile ( context.isRoot && context.ractive.component ) {\n\t\t\t\tcontext = context.ractive.component.parentFragment.findContext();\n\t\t\t}\n\n\t\t\tvar match$1 = keypathExpr.exec( ref );\n\t\t\tif ( match$1 && match$1[1] ) {\n\t\t\t\tvar model$1 = resolveReference( fragment, match$1[1] );\n\t\t\t\tif ( model$1 ) return model$1.getKeypathModel( fragment.ractive.root );\n\t\t\t}\n\t\t\treturn context.getKeypathModel( fragment.ractive.root );\n\t\t}\n\t\tif ( ref === '@index' || ref === '@key' ) {\n\t\t\tvar repeater = fragment.findRepeatingFragment();\n\t\t\t// make sure the found fragment is actually an iteration\n\t\t\tif ( !repeater.isIteration ) return;\n\t\t\treturn repeater.context.getKeyModel( repeater[ ref[1] === 'i' ? 'index' : 'key' ] );\n\t\t}\n\t\tif ( ref === '@this' ) {\n\t\t\treturn fragment.ractive.viewmodel.getRactiveModel();\n\t\t}\n\t\tif ( ref === '@global' ) {\n\t\t\treturn GlobalModel$1;\n\t\t}\n\n\t\t// ancestor references\n\t\tif ( ref[0] === '~' ) return fragment.ractive.viewmodel.joinAll( splitKeypathI( ref.slice( 2 ) ) );\n\t\tif ( ref[0] === '.' ) {\n\t\t\tvar parts = ref.split( '/' );\n\n\t\t\twhile ( parts[0] === '.' || parts[0] === '..' ) {\n\t\t\t\tvar part = parts.shift();\n\n\t\t\t\tif ( part === '..' ) {\n\t\t\t\t\tcontext = context.parent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tref = parts.join( '/' );\n\n\t\t\t// special case - `{{.foo}}` means the same as `{{./foo}}`\n\t\t\tif ( ref[0] === '.' ) ref = ref.slice( 1 );\n\t\t\treturn context.joinAll( splitKeypathI( ref ) );\n\t\t}\n\n\t\treturn resolveAmbiguousReference( fragment, ref );\n\t}\n\n\tfunction Ractive$get ( keypath, opts ) {\n\t\tif ( typeof keypath !== 'string' ) return this.viewmodel.get( true, keypath );\n\n\t\tvar keys = splitKeypathI( keypath );\n\t\tvar key = keys[0];\n\n\t\tvar model;\n\n\t\tif ( !this.viewmodel.has( key ) ) {\n\t\t\t// if this is an inline component, we may need to create\n\t\t\t// an implicit mapping\n\t\t\tif ( this.component && !this.isolated ) {\n\t\t\t\tmodel = resolveReference( this.component.parentFragment, key );\n\n\t\t\t\tif ( model ) {\n\t\t\t\t\tthis.viewmodel.map( key, model );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmodel = this.viewmodel.joinAll( keys );\n\t\treturn model.get( true, opts );\n\t}\n\n\tfunction gatherRefs( fragment ) {\n\t\tvar key = {}, index = {};\n\n\t\t// walk up the template gather refs as we go\n\t\twhile ( fragment ) {\n\t\t\tif ( fragment.parent && ( fragment.parent.indexRef || fragment.parent.keyRef ) ) {\n\t\t\t\tvar ref = fragment.parent.indexRef;\n\t\t\t\tif ( ref && !( ref in index ) ) index[ref] = fragment.index;\n\t\t\t\tref = fragment.parent.keyRef;\n\t\t\t\tif ( ref && !( ref in key ) ) key[ref] = fragment.key;\n\t\t\t}\n\n\t\t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n\t\t\t\tfragment = fragment.componentParent;\n\t\t\t} else {\n\t\t\t\tfragment = fragment.parent;\n\t\t\t}\n\t\t}\n\n\t\treturn { key: key, index: index };\n\t}\n\n\t// This function takes an array, the name of a mutator method, and the\n\t// arguments to call that mutator method with, and returns an array that\n\t// maps the old indices to their new indices.\n\n\t// So if you had something like this...\n\t//\n\t//     array = [ 'a', 'b', 'c', 'd' ];\n\t//     array.push( 'e' );\n\t//\n\t// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n\t// have changed. If you then did this...\n\t//\n\t//     array.unshift( 'z' );\n\t//\n\t// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n\t// one higher to make room for the 'z'. If you removed an item, the new index\n\t// would be -1...\n\t//\n\t//     array.splice( 2, 2 );\n\t//\n\t// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n\t//\n\t// This information is used to enable fast, non-destructive shuffling of list\n\t// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\n\tfunction getNewIndices ( length, methodName, args ) {\n\t\tvar spliceArguments, newIndices = [], removeStart, removeEnd, balance, i;\n\n\t\tspliceArguments = getSpliceEquivalent( length, methodName, args );\n\n\t\tif ( !spliceArguments ) {\n\t\t\treturn null; // TODO support reverse and sort?\n\t\t}\n\n\t\tbalance = ( spliceArguments.length - 2 ) - spliceArguments[1];\n\n\t\tremoveStart = Math.min( length, spliceArguments[0] );\n\t\tremoveEnd = removeStart + spliceArguments[1];\n\t\tnewIndices.startIndex = removeStart;\n\n\t\tfor ( i = 0; i < removeStart; i += 1 ) {\n\t\t\tnewIndices.push( i );\n\t\t}\n\n\t\tfor ( ; i < removeEnd; i += 1 ) {\n\t\t\tnewIndices.push( -1 );\n\t\t}\n\n\t\tfor ( ; i < length; i += 1 ) {\n\t\t\tnewIndices.push( i + balance );\n\t\t}\n\n\t\t// there is a net shift for the rest of the array starting with index + balance\n\t\tif ( balance !== 0 ) {\n\t\t\tnewIndices.touchedFrom = spliceArguments[0];\n\t\t} else {\n\t\t\tnewIndices.touchedFrom = length;\n\t\t}\n\n\t\treturn newIndices;\n\t}\n\n\n\t// The pop, push, shift an unshift methods can all be represented\n\t// as an equivalent splice\n\tfunction getSpliceEquivalent ( length, methodName, args ) {\n\t\tswitch ( methodName ) {\n\t\t\tcase 'splice':\n\t\t\t\tif ( args[0] !== undefined && args[0] < 0 ) {\n\t\t\t\t\targs[0] = length + Math.max( args[0], -length );\n\t\t\t\t}\n\n\t\t\t\tif ( args[0] === undefined ) args[0] = 0;\n\n\t\t\t\twhile ( args.length < 2 ) {\n\t\t\t\t\targs.push( length - args[0] );\n\t\t\t\t}\n\n\t\t\t\tif ( typeof args[1] !== 'number' ) {\n\t\t\t\t\targs[1] = length - args[0];\n\t\t\t\t}\n\n\t\t\t\t// ensure we only remove elements that exist\n\t\t\t\targs[1] = Math.min( args[1], length - args[0] );\n\n\t\t\t\treturn args;\n\n\t\t\tcase 'sort':\n\t\t\tcase 'reverse':\n\t\t\t\treturn null;\n\n\t\t\tcase 'pop':\n\t\t\t\tif ( length ) {\n\t\t\t\t\treturn [ length - 1, 1 ];\n\t\t\t\t}\n\t\t\t\treturn [ 0, 0 ];\n\n\t\t\tcase 'push':\n\t\t\t\treturn [ length, 0 ].concat( args );\n\n\t\t\tcase 'shift':\n\t\t\t\treturn [ 0, length ? 1 : 0 ];\n\n\t\t\tcase 'unshift':\n\t\t\t\treturn [ 0, 0 ].concat( args );\n\t\t}\n\t}\n\n\tvar arrayProto = Array.prototype;\n\n\tfunction makeArrayMethod ( methodName ) {\n\t\tfunction path ( keypath ) {\n\t\t\tvar args = [], len = arguments.length - 1;\n\t\t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t\t\treturn model( this.viewmodel.joinAll( splitKeypathI( keypath ) ), args );\n\t\t}\n\n\t\tfunction model ( mdl, args ) {\n\t\t\tvar array = mdl.get();\n\n\t\t\tif ( !isArray( array ) ) {\n\t\t\t\tif ( array === undefined ) {\n\t\t\t\t\tarray = [];\n\t\t\t\t\tvar result$1 = arrayProto[ methodName ].apply( array, args );\n\t\t\t\t\tvar promise$1 = runloop.start( this, true ).then( function () { return result$1; } );\n\t\t\t\t\tmdl.set( array );\n\t\t\t\t\trunloop.end();\n\t\t\t\t\treturn promise$1;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( (\"shuffle array method \" + methodName + \" called on non-array at \" + (mdl.getKeypath())) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar newIndices = getNewIndices( array.length, methodName, args );\n\t\t\tvar result = arrayProto[ methodName ].apply( array, args );\n\n\t\t\tvar promise = runloop.start( this, true ).then( function () { return result; } );\n\t\t\tpromise.result = result;\n\n\t\t\tif ( newIndices ) {\n\t\t\t\tmdl.shuffle( newIndices );\n\t\t\t} else {\n\t\t\t\tmdl.set( result );\n\t\t\t}\n\n\t\t\trunloop.end();\n\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn { path: path, model: model };\n\t}\n\n\tvar comparators = {};\n\n\tfunction getComparator ( option ) {\n\t\tif ( !option ) return null; // use existing arrays\n\t\tif ( option === true ) return JSON.stringify;\n\t\tif ( typeof option === 'function' ) return option;\n\n\t\tif ( typeof option === 'string' ) {\n\t\t\treturn comparators[ option ] || ( comparators[ option ] = function ( thing ) { return thing[ option ]; } );\n\t\t}\n\n\t\tthrow new Error( 'If supplied, options.compare must be a string, function, or `true`' ); // TODO link to docs\n\t}\n\n\tfunction merge$1 ( ractive, model, array, options ) {\n\t\tvar promise = runloop.start( ractive, true );\n\t\tvar value = model.get();\n\n\t\tif ( !isArray( value ) || !isArray( array ) ) {\n\t\t\tthrow new Error( 'You cannot merge an array with a non-array' );\n\t\t}\n\n\t\tvar comparator = getComparator( options && options.compare );\n\t\tmodel.merge( array, comparator );\n\n\t\trunloop.end();\n\t\treturn promise;\n\t}\n\n\tfunction thisRactive$merge ( keypath, array, options ) {\n\t\treturn merge$1( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), array, options );\n\t}\n\n\tvar updateHook = new Hook( 'update' );\n\n\tfunction update$2 ( ractive, model ) {\n\t\t// if the parent is wrapped, the adaptor will need to be updated before\n\t\t// updating on this keypath\n\t\tif ( model.parent && model.parent.wrapper ) {\n\t\t\tmodel.parent.adapt();\n\t\t}\n\n\t\tvar promise = runloop.start( ractive, true );\n\n\t\tmodel.mark();\n\t\tmodel.registerChange( model.getKeypath(), model.get() );\n\n\t\tif ( !model.isRoot ) {\n\t\t\t// there may be unresolved refs that are now resolvable up the context tree\n\t\t\tvar parent = model.parent, key = model.key;\n\t\t\twhile ( parent && !parent.isRoot ) {\n\t\t\t\tif ( parent.clearUnresolveds ) parent.clearUnresolveds( key );\n\t\t\t\tkey = parent.key;\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\t// notify upstream of changes\n\t\tmodel.notifyUpstream();\n\n\t\trunloop.end();\n\n\t\tupdateHook.fire( ractive, model );\n\n\t\treturn promise;\n\t}\n\n\tfunction Ractive$update ( keypath ) {\n\t\tif ( keypath ) keypath = splitKeypathI( keypath );\n\n\t\treturn update$2( this, keypath ? this.viewmodel.joinAll( keypath ) : this.viewmodel );\n\t}\n\n\tvar modelPush = makeArrayMethod( 'push' ).model;\n\tvar modelPop = makeArrayMethod( 'pop' ).model;\n\tvar modelShift = makeArrayMethod( 'shift' ).model;\n\tvar modelUnshift = makeArrayMethod( 'unshift' ).model;\n\tvar modelSort = makeArrayMethod( 'sort' ).model;\n\tvar modelSplice = makeArrayMethod( 'splice' ).model;\n\tvar modelReverse = makeArrayMethod( 'reverse' ).model;\n\n\t// TODO: at some point perhaps this could support relative * keypaths?\n\tfunction build$1 ( el, keypath, value ) {\n\t\tvar sets = [];\n\n\t\t// set multiple keypaths in one go\n\t\tif ( isObject( keypath ) ) {\n\t\t\tfor ( var k in keypath ) {\n\t\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\t\tsets.push( [ findModel( el, k ).model, keypath[k] ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t// set a single keypath\n\t\telse {\n\t\t\tsets.push( [ findModel( el, keypath ).model, value ] );\n\t\t}\n\n\t\treturn sets;\n\t}\n\n\t// get relative keypaths and values\n\tfunction get ( keypath ) {\n\t\tif ( !keypath ) return this._element.parentFragment.findContext().get( true );\n\n\t\tvar model = resolveReference( this._element.parentFragment, keypath );\n\n\t\treturn model ? model.get( true ) : undefined;\n\t}\n\n\tfunction resolve$1 ( path, ractive ) {\n\t\tvar ref = findModel( this, path ), model = ref.model, instance = ref.instance;\n\t\treturn model ? model.getKeypath( ractive || instance ) : path;\n\t}\n\n\tfunction findModel ( el, path ) {\n\t\tvar frag = el._element.parentFragment;\n\n\t\tif ( typeof path !== 'string' ) {\n\t\t\treturn { model: frag.findContext(), instance: path };\n\t\t}\n\n\t\treturn { model: resolveReference( frag, path ), instance: frag.ractive };\n\t}\n\n\t// the usual mutation suspects\n\tfunction add$1 ( keypath, value ) {\n\t\tif ( value === undefined ) value = 1;\n\t\tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n\t\treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n\t\t\tvar model = pair[0], val = pair[1], value = model.get();\n\t\t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n\t\t\treturn [ model, value + val ];\n\t\t}) );\n\t}\n\n\tfunction animate ( keypath, value, options ) {\n\t\tvar model = findModel( this, keypath ).model;\n\t\treturn protoAnimate( this.ractive, model, value, options );\n\t}\n\n\tfunction link ( source, dest ) {\n\t\tvar there = findModel( this, source ).model, here = findModel( this, dest ).model;\n\t\tvar promise = runloop.start( this.ractive, true );\n\t\there.link( there, source );\n\t\trunloop.end();\n\t\treturn promise;\n\t}\n\n\tfunction merge ( keypath, array, options ) {\n\t\treturn merge$1( this.ractive, findModel( this, keypath ).model, array, options );\n\t}\n\n\tfunction pop ( keypath ) {\n\t\treturn modelPop( findModel( this, keypath ).model, [] );\n\t}\n\n\tfunction push ( keypath ) {\n\t\tvar values = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n\t\treturn modelPush( findModel( this, keypath ).model, values );\n\t}\n\n\tfunction reverse ( keypath ) {\n\t\treturn modelReverse( findModel( this, keypath ).model, [] );\n\t}\n\n\tfunction set$1 ( keypath, value ) {\n\t\treturn set( this.ractive, build$1( this, keypath, value ) );\n\t}\n\n\tfunction shift ( keypath ) {\n\t\treturn modelShift( findModel( this, keypath ).model, [] );\n\t}\n\n\tfunction splice ( keypath, index, drop ) {\n\t\tvar add = [], len = arguments.length - 3;\n\t\twhile ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];\n\n\t\tadd.unshift( index, drop );\n\t\treturn modelSplice( findModel( this, keypath ).model, add );\n\t}\n\n\tfunction sort ( keypath ) {\n\t\treturn modelSort( findModel( this, keypath ).model, [] );\n\t}\n\n\tfunction subtract ( keypath, value ) {\n\t\tif ( value === undefined ) value = 1;\n\t\tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n\t\treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n\t\t\tvar model = pair[0], val = pair[1], value = model.get();\n\t\t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n\t\t\treturn [ model, value - val ];\n\t\t}) );\n\t}\n\n\tfunction toggle ( keypath ) {\n\t\tvar ref = findModel( this, keypath ), model = ref.model;\n\t\treturn set( this.ractive, [ [ model, !model.get() ] ] );\n\t}\n\n\tfunction unlink ( dest ) {\n\t\tvar here = findModel( this, dest ).model;\n\t\tvar promise = runloop.start( this.ractive, true );\n\t\tif ( here.owner && here.owner._link ) here.owner.unlink();\n\t\trunloop.end();\n\t\treturn promise;\n\t}\n\n\tfunction unshift ( keypath ) {\n\t\tvar add = [], len = arguments.length - 1;\n\t\twhile ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];\n\n\t\treturn modelUnshift( findModel( this, keypath ).model, add );\n\t}\n\n\tfunction update$1 ( keypath ) {\n\t\treturn update$2( this.ractive, findModel( this, keypath ).model );\n\t}\n\n\tfunction updateModel ( keypath, cascade ) {\n\t\tvar ref = findModel( this, keypath ), model = ref.model;\n\t\tvar promise = runloop.start( this.ractive, true );\n\t\tmodel.updateFromBindings( cascade );\n\t\trunloop.end();\n\t\treturn promise;\n\t}\n\n\t// two-way binding related helpers\n\tfunction isBound () {\n\t\tvar ref = getBindingModel( this ), model = ref.model;\n\t\treturn !!model;\n\t}\n\n\tfunction getBindingPath ( ractive ) {\n\t\tvar ref = getBindingModel( this ), model = ref.model, instance = ref.instance;\n\t\tif ( model ) return model.getKeypath( ractive || instance );\n\t}\n\n\tfunction getBinding () {\n\t\tvar ref = getBindingModel( this ), model = ref.model;\n\t\tif ( model ) return model.get( true );\n\t}\n\n\tfunction getBindingModel ( ctx ) {\n\t\tvar el = ctx._element;\n\t\treturn { model: el.binding && el.binding.model, instance: el.parentFragment.ractive };\n\t}\n\n\tfunction setBinding ( value ) {\n\t\tvar ref = getBindingModel( this ), model = ref.model;\n\t\treturn set( this.ractive, [ [ model, value ] ] );\n\t}\n\n\t// deprecated getters\n\tfunction keypath () {\n\t\twarnOnceIfDebug( (\"Object property keypath is deprecated, please use resolve() instead.\") );\n\t\treturn this.resolve();\n\t}\n\n\tfunction rootpath () {\n\t\twarnOnceIfDebug( (\"Object property rootpath is deprecated, please use resolve( ractive.root ) instead.\") );\n\t\treturn this.resolve( this.ractive.root );\n\t}\n\n\tfunction context () {\n\t\twarnOnceIfDebug( (\"Object property context is deprecated, please use get() instead.\") );\n\t\treturn this.get();\n\t}\n\n\tfunction index () {\n\t\twarnOnceIfDebug( (\"Object property index is deprecated, you can use get( \\\"indexName\\\" ) instead.\") );\n\t\treturn gatherRefs( this._element.parentFragment ).index;\n\t}\n\n\tfunction key () {\n\t\twarnOnceIfDebug( (\"Object property key is deprecated, you can use get( \\\"keyName\\\" ) instead.\") );\n\t\treturn gatherRefs( this._element.parentFragment ).key;\n\t}\n\n\tfunction addHelpers ( obj, element ) {\n\t\tdefineProperties( obj, {\n\t\t\t_element: { value: element },\n\t\t\tractive: { value: element.parentFragment.ractive },\n\t\t\tresolve: { value: resolve$1 },\n\t\t\tget: { value: get },\n\n\t\t\tadd: { value: add$1 },\n\t\t\tanimate: { value: animate },\n\t\t\tlink: { value: link },\n\t\t\tmerge: { value: merge },\n\t\t\tpop: { value: pop },\n\t\t\tpush: { value: push },\n\t\t\treverse: { value: reverse },\n\t\t\tset: { value: set$1 },\n\t\t\tshift: { value: shift },\n\t\t\tsort: { value: sort },\n\t\t\tsplice: { value: splice },\n\t\t\tsubtract: { value: subtract },\n\t\t\ttoggle: { value: toggle },\n\t\t\tunlink: { value: unlink },\n\t\t\tunshift: { value: unshift },\n\t\t\tupdate: { value: update$1 },\n\t\t\tupdateModel: { value: updateModel },\n\n\t\t\tisBound: { value: isBound },\n\t\t\tgetBindingPath: { value: getBindingPath },\n\t\t\tgetBinding: { value: getBinding },\n\t\t\tsetBinding: { value: setBinding },\n\n\t\t\tkeypath: { get: keypath },\n\t\t\trootpath: { get: rootpath },\n\t\t\tcontext: { get: context },\n\t\t\tindex: { get: index },\n\t\t\tkey: { get: key }\n\t\t});\n\n\t\treturn obj;\n\t}\n\n\tvar query = doc && doc.querySelector;\n\n\tfunction staticInfo( node ) {\n\t\tif ( typeof node === 'string' && query ) {\n\t\t\tnode = query.call( document, node );\n\t\t}\n\n\t\tif ( !node || !node._ractive ) return {};\n\n\t\tvar storage = node._ractive;\n\n\t\treturn addHelpers( {}, storage.proxy );\n\t}\n\n\tfunction getNodeInfo( node ) {\n\t\tif ( typeof node === 'string' ) {\n\t\t\tnode = this.find( node );\n\t\t}\n\n\t\treturn staticInfo( node );\n\t}\n\n\tvar insertHook = new Hook( 'insert' );\n\n\tfunction Ractive$insert ( target, anchor ) {\n\t\tif ( !this.fragment.rendered ) {\n\t\t\t// TODO create, and link to, documentation explaining this\n\t\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t\t}\n\n\t\ttarget = getElement( target );\n\t\tanchor = getElement( anchor ) || null;\n\n\t\tif ( !target ) {\n\t\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t\t}\n\n\t\ttarget.insertBefore( this.detach(), anchor );\n\t\tthis.el = target;\n\n\t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\t\tthis.isDetached = false;\n\n\t\tfireInsertHook( this );\n\t}\n\n\tfunction fireInsertHook( ractive ) {\n\t\tinsertHook.fire( ractive );\n\n\t\tractive.findAllComponents('*').forEach( function ( child ) {\n\t\t\tfireInsertHook( child.instance );\n\t\t});\n\t}\n\n\tfunction link$1( there, here ) {\n\t\tif ( here === there || (there + '.').indexOf( here + '.' ) === 0 || (here + '.').indexOf( there + '.' ) === 0 ) {\n\t\t\tthrow new Error( 'A keypath cannot be linked to itself.' );\n\t\t}\n\n\t\tvar promise = runloop.start();\n\t\tvar model;\n\n\t\t// may need to allow a mapping to resolve implicitly\n\t\tvar sourcePath = splitKeypathI( there );\n\t\tif ( !this.viewmodel.has( sourcePath[0] ) && this.component ) {\n\t\t\tmodel = resolveReference( this.component.parentFragment, sourcePath[0] );\n\t\t\tmodel = model.joinAll( sourcePath.slice( 1 ) );\n\t\t}\n\n\t\tthis.viewmodel.joinAll( splitKeypathI( here ) ).link( model || this.viewmodel.joinAll( sourcePath ), there );\n\n\t\trunloop.end();\n\n\t\treturn promise;\n\t}\n\n\tvar ReferenceResolver = function ReferenceResolver ( fragment, reference, callback ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.fragment = fragment;\n\t\tthis.reference = normalise( reference );\n\t\tthis.callback = callback;\n\n\t\tthis.keys = splitKeypathI( reference );\n\t\tthis.resolved = false;\n\n\t\tthis.contexts = [];\n\n\t\t// TODO the consumer should take care of addUnresolved\n\t\t// we attach to all the contexts between here and the root\n\t\t// - whenever their values change, they can quickly\n\t\t// check to see if we can resolve\n\t\twhile ( fragment ) {\n\t\t\tif ( fragment.context ) {\n\t\t\t\tfragment.context.addUnresolved( this$1.keys[0], this$1 );\n\t\t\t\tthis$1.contexts.push( fragment.context );\n\t\t\t}\n\n\t\t\tfragment = fragment.componentParent || fragment.parent;\n\t\t}\n\t};\n\n\tReferenceResolver.prototype.attemptResolution = function attemptResolution () {\n\t\tif ( this.resolved ) return;\n\n\t\tvar model = resolveAmbiguousReference( this.fragment, this.reference );\n\n\t\tif ( model ) {\n\t\t\tthis.resolved = true;\n\t\t\tthis.callback( model );\n\t\t}\n\t};\n\n\tReferenceResolver.prototype.forceResolution = function forceResolution () {\n\t\tif ( this.resolved ) return;\n\n\t\tvar model = this.fragment.findContext().joinAll( this.keys );\n\t\tthis.callback( model );\n\t\tthis.resolved = true;\n\t};\n\n\tReferenceResolver.prototype.rebinding = function rebinding ( next, previous ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( previous ) previous.removeUnresolved( this.keys[0], this );\n\t\tif ( next ) runloop.scheduleTask( function () { return next.addUnresolved( this$1.keys[0], this$1 ); } );\n\t};\n\n\tReferenceResolver.prototype.unbind = function unbind () {\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.fragment ) removeFromArray( this.fragment.unresolved, this );\n\n\t\tif ( this.resolved ) return;\n\n\t\tthis.contexts.forEach( function ( c ) { return c.removeUnresolved( this$1.keys[0], this$1 ); } );\n\t};\n\n\tfunction observe ( keypath, callback, options ) {\n\t\tvar this$1 = this;\n\n\t\tvar observers = [];\n\t\tvar map;\n\n\t\tif ( isObject( keypath ) ) {\n\t\t\tmap = keypath;\n\t\t\toptions = callback || {};\n\n\t\t\tObject.keys( map ).forEach( function ( keypath ) {\n\t\t\t\tvar callback = map[ keypath ];\n\n\t\t\t\tvar keypaths = keypath.split( ' ' );\n\t\t\t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\n\t\t\t\tkeypaths.forEach( function ( keypath ) {\n\t\t\t\t\tobservers.push( createObserver( this$1, keypath, callback, options ) );\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\telse {\n\t\t\tvar keypaths;\n\n\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\toptions = callback;\n\t\t\t\tcallback = keypath;\n\t\t\t\tkeypaths = [ '' ];\n\t\t\t} else {\n\t\t\t\tkeypaths = keypath.split( ' ' );\n\t\t\t}\n\n\t\t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\n\t\t\tkeypaths.forEach( function ( keypath ) {\n\t\t\t\tobservers.push( createObserver( this$1, keypath, callback, options || {} ) );\n\t\t\t});\n\t\t}\n\n\t\t// add observers to the Ractive instance, so they can be\n\t\t// cancelled on ractive.teardown()\n\t\tthis._observers.push.apply( this._observers, observers );\n\n\t\treturn {\n\t\t\tcancel: function () {\n\t\t\t\tobservers.forEach( function ( observer ) {\n\t\t\t\t\tremoveFromArray ( this$1._observers, observer );\n\t\t\t\t\tobserver.cancel();\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction createObserver ( ractive, keypath, callback, options ) {\n\t\tvar viewmodel = ractive.viewmodel;\n\n\t\tvar keys = splitKeypathI( keypath );\n\t\tvar wildcardIndex = keys.indexOf( '*' );\n\t\toptions.keypath = keypath;\n\n\t\t// normal keypath - no wildcards\n\t\tif ( !~wildcardIndex ) {\n\t\t\tvar key = keys[0];\n\t\t\tvar model;\n\n\t\t\t// if not the root model itself, check if viewmodel has key.\n\t\t\tif ( key !== '' && !viewmodel.has( key ) ) {\n\t\t\t\t// if this is an inline component, we may need to create an implicit mapping\n\t\t\t\tif ( ractive.component && !ractive.isolated ) {\n\t\t\t\t\tmodel = resolveReference( ractive.component.parentFragment, key );\n\t\t\t\t\tif ( model ) {\n\t\t\t\t\t\tviewmodel.map( key, model );\n\t\t\t\t\t\tmodel = viewmodel.joinAll( keys );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmodel = viewmodel.joinAll( keys );\n\t\t\t}\n\n\t\t\treturn new Observer( ractive, model, callback, options );\n\t\t}\n\n\t\t// pattern observers - more complex case\n\t\tvar baseModel = wildcardIndex === 0 ?\n\t\t\tviewmodel :\n\t\t\tviewmodel.joinAll( keys.slice( 0, wildcardIndex ) );\n\n\t\treturn new PatternObserver( ractive, baseModel, keys.splice( wildcardIndex ), callback, options );\n\t}\n\n\tvar Observer = function Observer ( ractive, model, callback, options ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.context = options.context || ractive;\n\t\tthis.callback = callback;\n\t\tthis.ractive = ractive;\n\n\t\tif ( model ) this.resolved( model );\n\t\telse {\n\t\t\tthis.keypath = options.keypath;\n\t\t\tthis.resolver = new ReferenceResolver( ractive.fragment, options.keypath, function ( model ) {\n\t\t\t\tthis$1.resolved( model );\n\t\t\t});\n\t\t}\n\n\t\tif ( options.init !== false ) {\n\t\t\tthis.dirty = true;\n\t\t\tthis.dispatch();\n\t\t} else {\n\t\t\tthis.oldValue = this.newValue;\n\t\t}\n\n\t\tthis.defer = options.defer;\n\t\tthis.once = options.once;\n\t\tthis.strict = options.strict;\n\n\t\tthis.dirty = false;\n\t};\n\n\tObserver.prototype.cancel = function cancel () {\n\t\tthis.cancelled = true;\n\t\tif ( this.model ) {\n\t\t\tthis.model.unregister( this );\n\t\t} else {\n\t\t\tthis.resolver.unbind();\n\t\t}\n\t};\n\n\tObserver.prototype.dispatch = function dispatch () {\n\t\tif ( !this.cancelled ) {\n\t\t\tthis.callback.call( this.context, this.newValue, this.oldValue, this.keypath );\n\t\t\tthis.oldValue = this.model ? this.model.get() : this.newValue;\n\t\t\tthis.dirty = false;\n\t\t}\n\t};\n\n\tObserver.prototype.handleChange = function handleChange () {\n\t\tvar this$1 = this;\n\n\t\t\tif ( !this.dirty ) {\n\t\t\tvar newValue = this.model.get();\n\t\t\tif ( isEqual( newValue, this.oldValue ) ) return;\n\n\t\t\tthis.newValue = newValue;\n\n\t\t\tif ( this.strict && this.newValue === this.oldValue ) return;\n\n\t\t\trunloop.addObserver( this, this.defer );\n\t\t\tthis.dirty = true;\n\n\t\t\tif ( this.once ) runloop.scheduleTask( function () { return this$1.cancel(); } );\n\t\t}\n\t};\n\n\tObserver.prototype.rebinding = function rebinding ( next, previous ) {\n\t\tvar this$1 = this;\n\n\t\t\tnext = rebindMatch( this.keypath, next, previous );\n\t\t// TODO: set up a resolver if next is undefined?\n\t\tif ( next === this.model ) return false;\n\n\t\tif ( this.model ) this.model.unregister( this );\n\t\tif ( next ) next.addShuffleTask( function () { return this$1.resolved( next ); } );\n\t};\n\n\tObserver.prototype.resolved = function resolved ( model ) {\n\t\tthis.model = model;\n\t\tthis.keypath = model.getKeypath( this.ractive );\n\n\t\tthis.oldValue = undefined;\n\t\tthis.newValue = model.get();\n\n\t\tmodel.register( this );\n\t};\n\n\tvar PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.context = options.context || ractive;\n\t\tthis.ractive = ractive;\n\t\tthis.baseModel = baseModel;\n\t\tthis.keys = keys;\n\t\tthis.callback = callback;\n\n\t\tvar pattern = keys.join( '\\\\.' ).replace( /\\*/g, '(.+)' );\n\t\tvar baseKeypath = baseModel.getKeypath( ractive );\n\t\tthis.pattern = new RegExp( (\"^\" + (baseKeypath ? baseKeypath + '\\\\.' : '') + \"\" + pattern + \"$\") );\n\n\t\tthis.oldValues = {};\n\t\tthis.newValues = {};\n\n\t\tthis.defer = options.defer;\n\t\tthis.once = options.once;\n\t\tthis.strict = options.strict;\n\n\t\tthis.dirty = false;\n\t\tthis.changed = [];\n\t\tthis.partial = false;\n\n\t\tvar models = baseModel.findMatches( this.keys );\n\n\t\tmodels.forEach( function ( model ) {\n\t\t\tthis$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();\n\t\t});\n\n\t\tif ( options.init !== false ) {\n\t\t\tthis.dispatch();\n\t\t} else {\n\t\t\tthis.oldValues = this.newValues;\n\t\t}\n\n\t\tbaseModel.registerPatternObserver( this );\n\t};\n\n\tPatternObserver.prototype.cancel = function cancel () {\n\t\tthis.baseModel.unregisterPatternObserver( this );\n\t};\n\n\tPatternObserver.prototype.dispatch = function dispatch () {\n\t\tvar this$1 = this;\n\n\t\t\tvar newValues = this.newValues;\n\t\tthis.newValues = {};\n\t\tObject.keys( newValues ).forEach( function ( keypath ) {\n\t\t\tif ( this$1.newKeys && !this$1.newKeys[ keypath ] ) return;\n\n\t\t\tvar newValue = newValues[ keypath ];\n\t\t\tvar oldValue = this$1.oldValues[ keypath ];\n\n\t\t\tif ( this$1.strict && newValue === oldValue ) return;\n\t\t\tif ( isEqual( newValue, oldValue ) ) return;\n\n\t\t\tvar args = [ newValue, oldValue, keypath ];\n\t\t\tif ( keypath ) {\n\t\t\t\tvar wildcards = this$1.pattern.exec( keypath );\n\t\t\t\tif ( wildcards ) {\n\t\t\t\t\targs = args.concat( wildcards.slice( 1 ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis$1.callback.apply( this$1.context, args );\n\t\t});\n\n\t\tif ( this.partial ) {\n\t\t\tfor ( var k in newValues ) {\n\t\t\t\tthis.oldValues[k] = newValues[k];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.oldValues = newValues;\n\t\t}\n\n\t\tthis.newKeys = null;\n\t\tthis.dirty = false;\n\t};\n\n\tPatternObserver.prototype.notify = function notify ( key ) {\n\t\tthis.changed.push( key );\n\t};\n\n\tPatternObserver.prototype.shuffle = function shuffle ( newIndices ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( !isArray( this.baseModel.value ) ) return;\n\n\t\tvar base = this.baseModel.getKeypath( this.ractive );\n\t\tvar max = this.baseModel.value.length;\n\t\tvar suffix = this.keys.length > 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : '';\n\n\t\tthis.newKeys = {};\n\t\tfor ( var i = 0; i < newIndices.length; i++ ) {\n\t\t\tif ( newIndices[ i ] === -1 || newIndices[ i ] === i ) continue;\n\t\t\tthis$1.newKeys[ (\"\" + base + \".\" + i + \"\" + suffix) ] = true;\n\t\t}\n\n\t\tfor ( var i$1 = newIndices.touchedFrom; i$1 < max; i$1++ ) {\n\t\t\tthis$1.newKeys[ (\"\" + base + \".\" + i$1 + \"\" + suffix) ] = true;\n\t\t}\n\t};\n\n\tPatternObserver.prototype.handleChange = function handleChange () {\n\t\tvar this$1 = this;\n\n\t\t\tif ( !this.dirty || this.changed.length ) {\n\t\t\tif ( !this.dirty ) this.newValues = {};\n\n\t\t\t// handle case where previously extant keypath no longer exists -\n\t\t\t// observer should still fire, with undefined as new value\n\t\t\t// TODO huh. according to the test suite that's not the case...\n\t\t\t// NOTE: I don't think this will work with partial updates\n\t\t\t// Object.keys( this.oldValues ).forEach( keypath => {\n\t\t\t// this.newValues[ keypath ] = undefined;\n\t\t\t// });\n\n\t\t\tif ( !this.changed.length ) {\n\t\t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n\t\t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n\t\t\t\t\tthis$1.newValues[ keypath ] = model.get();\n\t\t\t\t});\n\t\t\t\tthis.partial = false;\n\t\t\t} else {\n\t\t\t\tvar count = 0;\n\t\t\t\tvar ok = this.baseModel.isRoot ?\n\t\t\t\t\tthis.changed.map( function ( keys ) { return keys.map( escapeKey ).join( '.' ); } ) :\n\t\t\t\t\tthis.changed.map( function ( keys ) { return this$1.baseModel.getKeypath( this$1.ractive ) + '.' + keys.map( escapeKey ).join( '.' ); } );\n\n\t\t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n\t\t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n\t\t\t\t\tvar check = function ( k ) {\n\t\t\t\t\t\treturn ( k.indexOf( keypath ) === 0 && ( k.length === keypath.length || k[ keypath.length ] === '.' ) ) ||\n\t\t\t\t\t\t\t\t   ( keypath.indexOf( k ) === 0 && ( k.length === keypath.length || keypath[ k.length ] === '.' ) );\n\t\t\t\t\t};\n\n\t\t\t\t\t// is this model on a changed keypath?\n\t\t\t\t\tif ( ok.filter( check ).length ) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tthis$1.newValues[ keypath ] = model.get();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// no valid change triggered, so bail to avoid breakage\n\t\t\t\tif ( !count ) return;\n\n\t\t\t\tthis.partial = true;\n\t\t\t}\n\n\t\t\trunloop.addObserver( this, this.defer );\n\t\t\tthis.dirty = true;\n\t\t\tthis.changed.length = 0;\n\n\t\t\tif ( this.once ) this.cancel();\n\t\t}\n\t};\n\n\tfunction observeList ( keypath, callback, options ) {\n\t\tif ( typeof keypath !== 'string' ) {\n\t\t\tthrow new Error( 'ractive.observeList() must be passed a string as its first argument' );\n\t\t}\n\n\t\tvar model = this.viewmodel.joinAll( splitKeypathI( keypath ) );\n\t\tvar observer = new ListObserver( this, model, callback, options || {} );\n\n\t\t// add observer to the Ractive instance, so it can be\n\t\t// cancelled on ractive.teardown()\n\t\tthis._observers.push( observer );\n\n\t\treturn {\n\t\t\tcancel: function () {\n\t\t\t\tobserver.cancel();\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction negativeOne () {\n\t\treturn -1;\n\t}\n\n\tvar ListObserver = function ListObserver ( context, model, callback, options ) {\n\t\tthis.context = context;\n\t\tthis.model = model;\n\t\tthis.keypath = model.getKeypath();\n\t\tthis.callback = callback;\n\n\t\tthis.pending = null;\n\n\t\tmodel.register( this );\n\n\t\tif ( options.init !== false ) {\n\t\t\tthis.sliced = [];\n\t\t\tthis.shuffle([]);\n\t\t\tthis.handleChange();\n\t\t} else {\n\t\t\tthis.sliced = this.slice();\n\t\t}\n\t};\n\n\tListObserver.prototype.handleChange = function handleChange () {\n\t\tif ( this.pending ) {\n\t\t\t// post-shuffle\n\t\t\tthis.callback( this.pending );\n\t\t\tthis.pending = null;\n\t\t}\n\n\t\telse {\n\t\t\t// entire array changed\n\t\t\tthis.shuffle( this.sliced.map( negativeOne ) );\n\t\t\tthis.handleChange();\n\t\t}\n\t};\n\n\tListObserver.prototype.shuffle = function shuffle ( newIndices ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar newValue = this.slice();\n\n\t\tvar inserted = [];\n\t\tvar deleted = [];\n\t\tvar start;\n\n\t\tvar hadIndex = {};\n\n\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\thadIndex[ newIndex ] = true;\n\n\t\t\tif ( newIndex !== oldIndex && start === undefined ) {\n\t\t\t\tstart = oldIndex;\n\t\t\t}\n\n\t\t\tif ( newIndex === -1 ) {\n\t\t\t\tdeleted.push( this$1.sliced[ oldIndex ] );\n\t\t\t}\n\t\t});\n\n\t\tif ( start === undefined ) start = newIndices.length;\n\n\t\tvar len = newValue.length;\n\t\tfor ( var i = 0; i < len; i += 1 ) {\n\t\t\tif ( !hadIndex[i] ) inserted.push( newValue[i] );\n\t\t}\n\n\t\tthis.pending = { inserted: inserted, deleted: deleted, start: start };\n\t\tthis.sliced = newValue;\n\t};\n\n\tListObserver.prototype.slice = function slice () {\n\t\tvar value = this.model.get();\n\t\treturn isArray( value ) ? value.slice() : [];\n\t};\n\n\tvar onceOptions = { init: false, once: true };\n\n\tfunction observeOnce ( keypath, callback, options ) {\n\t\tif ( isObject( keypath ) || typeof keypath === 'function' ) {\n\t\t\toptions = extendObj( callback || {}, onceOptions );\n\t\t\treturn this.observe( keypath, options );\n\t\t}\n\n\t\toptions = extendObj( options || {}, onceOptions );\n\t\treturn this.observe( keypath, callback, options );\n\t}\n\n\tfunction trim ( str ) { return str.trim(); };\n\n\tfunction notEmptyString ( str ) { return str !== ''; };\n\n\tfunction Ractive$off ( eventName, callback ) {\n\t\t// if no arguments specified, remove all callbacks\n\t\tvar this$1 = this;\n\n\t\tif ( !eventName ) {\n\t\t\t// TODO use this code instead, once the following issue has been resolved\n\t\t\t// in PhantomJS (tests are unpassable otherwise!)\n\t\t\t// https://github.com/ariya/phantomjs/issues/11856\n\t\t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t\t\tfor ( eventName in this._subs ) {\n\t\t\t\tdelete this._subs[ eventName ];\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Handle multiple space-separated event names\n\t\t\tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n\t\t\teventNames.forEach( function ( eventName ) {\n\t\t\t\tvar subscribers = this$1._subs[ eventName ];\n\n\t\t\t\t// If we have subscribers for this event...\n\t\t\t\tif ( subscribers ) {\n\t\t\t\t\t// ...if a callback was specified, only remove that\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t// flag this callback as off so that any in-flight firings don't call\n\t\t\t\t\t\t// a cancelled handler - this is _slightly_ hacky\n\t\t\t\t\t\tcallback.off = true;\n\t\t\t\t\t\tvar index = subscribers.indexOf( callback );\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// ...otherwise remove all callbacks\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis$1._subs[ eventName ] = [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfunction Ractive$on ( eventName, callback ) {\n\t\t// allow multiple listeners to be bound in one go\n\t\tvar this$1 = this;\n\n\t\tif ( typeof eventName === 'object' ) {\n\t\t\tvar listeners = [];\n\t\t\tvar n;\n\n\t\t\tfor ( n in eventName ) {\n\t\t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t\t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcancel: function () {\n\t\t\t\t\tvar listener;\n\t\t\t\t\twhile ( listener = listeners.pop() ) listener.cancel();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple space-separated event names\n\t\tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n\t\teventNames.forEach( function ( eventName ) {\n\t\t\t( this$1._subs[ eventName ] || ( this$1._subs[ eventName ] = [] ) ).push( callback );\n\t\t});\n\n\t\treturn {\n\t\t\tcancel: function () { return this$1.off( eventName, callback ); }\n\t\t};\n\t}\n\n\tfunction Ractive$once ( eventName, handler ) {\n\t\tvar listener = this.on( eventName, function () {\n\t\t\thandler.apply( this, arguments );\n\t\t\tlistener.cancel();\n\t\t});\n\n\t\t// so we can still do listener.cancel() manually\n\t\treturn listener;\n\t}\n\n\tvar pop$1 = makeArrayMethod( 'pop' ).path;\n\n\tvar push$1 = makeArrayMethod( 'push' ).path;\n\n\tvar PREFIX = '/* Ractive.js component styles */';\n\n\t// Holds current definitions of styles.\n\tvar styleDefinitions = [];\n\n\t// Flag to tell if we need to update the CSS\n\tvar isDirty = false;\n\n\t// These only make sense on the browser. See additional setup below.\n\tvar styleElement = null;\n\tvar useCssText = null;\n\n\tfunction addCSS( styleDefinition ) {\n\t\tstyleDefinitions.push( styleDefinition );\n\t\tisDirty = true;\n\t}\n\n\tfunction applyCSS() {\n\n\t\t// Apply only seems to make sense when we're in the DOM. Server-side renders\n\t\t// can call toCSS to get the updated CSS.\n\t\tif ( !doc || !isDirty ) return;\n\n\t\tif ( useCssText ) {\n\t\t\tstyleElement.styleSheet.cssText = getCSS( null );\n\t\t} else {\n\t\t\tstyleElement.innerHTML = getCSS( null );\n\t\t}\n\n\t\tisDirty = false;\n\t}\n\n\tfunction getCSS( cssIds ) {\n\n\t\tvar filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function ( style ) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;\n\n\t\treturn filteredStyleDefinitions.reduce( function ( styles, style ) { return (\"\" + styles + \"\\n\\n/* {\" + (style.id) + \"} */\\n\" + (style.styles)); }, PREFIX );\n\n\t}\n\n\t// If we're on the browser, additional setup needed.\n\tif ( doc && ( !styleElement || !styleElement.parentNode ) ) {\n\n\t\tstyleElement = doc.createElement( 'style' );\n\t\tstyleElement.type = 'text/css';\n\n\t\tdoc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );\n\n\t\tuseCssText = !!styleElement.styleSheet;\n\t}\n\n\tvar renderHook = new Hook( 'render' );\n\tvar completeHook = new Hook( 'complete' );\n\n\tfunction render$1 ( ractive, target, anchor, occupants ) {\n\t\t// if `noIntro` is `true`, temporarily disable transitions\n\t\tvar transitionsEnabled = ractive.transitionsEnabled;\n\t\tif ( ractive.noIntro ) ractive.transitionsEnabled = false;\n\n\t\tvar promise = runloop.start( ractive, true );\n\t\trunloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );\n\n\t\tif ( ractive.fragment.rendered ) {\n\t\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t\t}\n\n\t\tanchor = getElement( anchor ) || ractive.anchor;\n\n\t\tractive.el = target;\n\t\tractive.anchor = anchor;\n\n\t\t// ensure encapsulated CSS is up-to-date\n\t\tif ( ractive.cssId ) applyCSS();\n\n\t\tif ( target ) {\n\t\t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );\n\n\t\t\tif ( anchor ) {\n\t\t\t\tvar docFrag = doc.createDocumentFragment();\n\t\t\t\tractive.fragment.render( docFrag );\n\t\t\t\ttarget.insertBefore( docFrag, anchor );\n\t\t\t} else {\n\t\t\t\tractive.fragment.render( target, occupants );\n\t\t\t}\n\t\t}\n\n\t\trunloop.end();\n\t\tractive.transitionsEnabled = transitionsEnabled;\n\n\t\treturn promise.then( function () { return completeHook.fire( ractive ); } );\n\t}\n\n\tfunction Ractive$render ( target, anchor ) {\n\t\tif ( this.torndown ) {\n\t\t\twarnIfDebug( 'ractive.render() was called on a Ractive instance that was already torn down' );\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\ttarget = getElement( target ) || this.el;\n\n\t\tif ( !this.append && target ) {\n\t\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t\t// avoids certain weird bugs\n\t\t\tvar others = target.__ractive_instances__;\n\t\t\tif ( others ) others.forEach( teardown );\n\n\t\t\t// make sure we are the only occupants\n\t\t\tif ( !this.enhance ) {\n\t\t\t\ttarget.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n\t\t\t}\n\t\t}\n\n\t\tvar occupants = this.enhance ? toArray( target.childNodes ) : null;\n\t\tvar promise = render$1( this, target, anchor, occupants );\n\n\t\tif ( occupants ) {\n\t\t\twhile ( occupants.length ) target.removeChild( occupants.pop() );\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tvar adaptConfigurator = {\n\t\textend: function ( Parent, proto, options ) {\n\t\t\tproto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );\n\t\t},\n\n\t\tinit: function () {}\n\t};\n\n\tfunction combine ( a, b ) {\n\t\tvar c = a.slice();\n\t\tvar i = b.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\t\tc.push( b[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn c;\n\t}\n\n\tvar selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g;\n\tvar commentsPattern = /\\/\\*[\\s\\S]*?\\*\\//g;\n\tvar selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\n\tvar excludePattern = /^(?:@|\\d+%)/;\n\tvar dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\n\tfunction trim$1 ( str ) {\n\t\treturn str.trim();\n\t}\n\n\tfunction extractString ( unit ) {\n\t\treturn unit.str;\n\t}\n\n\tfunction transformSelector ( selector, parent ) {\n\t\tvar selectorUnits = [];\n\t\tvar match;\n\n\t\twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t\t\tselectorUnits.push({\n\t\t\t\tstr: match[0],\n\t\t\t\tbase: match[1],\n\t\t\t\tmodifiers: match[2]\n\t\t\t});\n\t\t}\n\n\t\t// For each simple selector within the selector, we need to create a version\n\t\t// that a) combines with the id, and b) is inside the id\n\t\tvar base = selectorUnits.map( extractString );\n\n\t\tvar transformed = [];\n\t\tvar i = selectorUnits.length;\n\n\t\twhile ( i-- ) {\n\t\t\tvar appended = base.slice();\n\n\t\t\t// Pseudo-selectors should go after the attribute selector\n\t\t\tvar unit = selectorUnits[i];\n\t\t\tappended[i] = unit.base + parent + unit.modifiers || '';\n\n\t\t\tvar prepended = base.slice();\n\t\t\tprepended[i] = parent + ' ' + prepended[i];\n\n\t\t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t\t}\n\n\t\treturn transformed.join( ', ' );\n\t}\n\n\tfunction transformCss ( css, id ) {\n\t\tvar dataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n\t\tvar transformed;\n\n\t\tif ( dataRvcGuidPattern.test( css ) ) {\n\t\t\ttransformed = css.replace( dataRvcGuidPattern, dataAttr );\n\t\t} else {\n\t\t\ttransformed = css\n\t\t\t.replace( commentsPattern, '' )\n\t\t\t.replace( selectorsPattern, function ( match, $1 ) {\n\t\t\t\t// don't transform at-rules and keyframe declarations\n\t\t\t\tif ( excludePattern.test( $1 ) ) return match;\n\n\t\t\t\tvar selectors = $1.split( ',' ).map( trim$1 );\n\t\t\t\tvar transformed = selectors\n\t\t\t\t\t.map( function ( selector ) { return transformSelector( selector, dataAttr ); } )\n\t\t\t\t\t.join( ', ' ) + ' ';\n\n\t\t\t\treturn match.replace( $1, transformed );\n\t\t\t});\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\tfunction s4() {\n\t\treturn Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t}\n\n\tfunction uuid() {\n\t\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t}\n\n\tvar cssConfigurator = {\n\t\tname: 'css',\n\n\t\t// Called when creating a new component definition\n\t\textend: function ( Parent, proto, options ) {\n\t\t\tif ( !options.css ) return;\n\n\t\t\tvar id = uuid();\n\t\t\tvar styles = options.noCssTransform ? options.css : transformCss( options.css, id );\n\n\t\t\tproto.cssId = id;\n\n\t\t\taddCSS( { id: id, styles: styles } );\n\n\t\t},\n\n\t\t// Called when creating a new component instance\n\t\tinit: function ( Parent, target, options ) {\n\t\t\tif ( !options.css ) return;\n\n\t\t\twarnIfDebug( (\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\") );\n\t\t}\n\n\t};\n\n\tfunction validate ( data ) {\n\t\t// Warn if userOptions.data is a non-POJO\n\t\tif ( data && data.constructor !== Object ) {\n\t\t\tif ( typeof data === 'function' ) {\n\t\t\t\t// TODO do we need to support this in the new Ractive() case?\n\t\t\t} else if ( typeof data !== 'object' ) {\n\t\t\t\tfatal( (\"data option must be an object or a function, `\" + data + \"` is not valid\") );\n\t\t\t} else {\n\t\t\t\twarnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );\n\t\t\t}\n\t\t}\n\t}\n\n\tvar dataConfigurator = {\n\t\tname: 'data',\n\n\t\textend: function ( Parent, proto, options ) {\n\t\t\tvar key;\n\t\t\tvar value;\n\n\t\t\t// check for non-primitives, which could cause mutation-related bugs\n\t\t\tif ( options.data && isObject( options.data ) ) {\n\t\t\t\tfor ( key in options.data ) {\n\t\t\t\t\tvalue = options.data[ key ];\n\n\t\t\t\t\tif ( value && typeof value === 'object' ) {\n\t\t\t\t\t\tif ( isObject( value ) || isArray( value ) ) {\n\t\t\t\t\t\t\twarnIfDebug( (\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\") );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproto.data = combine$1( proto.data, options.data );\n\t\t},\n\n\t\tinit: function ( Parent, ractive, options ) {\n\t\t\tvar result = combine$1( Parent.prototype.data, options.data );\n\n\t\t\tif ( typeof result === 'function' ) result = result.call( ractive );\n\n\t\t\t// bind functions to the ractive instance at the top level,\n\t\t\t// unless it's a non-POJO (in which case alarm bells should ring)\n\t\t\tif ( result && result.constructor === Object ) {\n\t\t\t\tfor ( var prop in result ) {\n\t\t\t\t\tif ( typeof result[ prop ] === 'function' ) result[ prop ] = bind( result[ prop ], ractive );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result || {};\n\t\t},\n\n\t\treset: function ( ractive ) {\n\t\t\tvar result = this.init( ractive.constructor, ractive, ractive.viewmodel );\n\t\t\tractive.viewmodel.root.set( result );\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tfunction combine$1 ( parentValue, childValue ) {\n\t\tvalidate( childValue );\n\n\t\tvar parentIsFn = typeof parentValue === 'function';\n\t\tvar childIsFn = typeof childValue === 'function';\n\n\t\t// Very important, otherwise child instance can become\n\t\t// the default data object on Ractive or a component.\n\t\t// then ractive.set() ends up setting on the prototype!\n\t\tif ( !childValue && !parentIsFn ) {\n\t\t\tchildValue = {};\n\t\t}\n\n\t\t// Fast path, where we just need to copy properties from\n\t\t// parent to child\n\t\tif ( !parentIsFn && !childIsFn ) {\n\t\t\treturn fromProperties( childValue, parentValue );\n\t\t}\n\n\t\treturn function () {\n\t\t\tvar child = childIsFn ? callDataFunction( childValue, this ) : childValue;\n\t\t\tvar parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;\n\n\t\t\treturn fromProperties( child, parent );\n\t\t};\n\t}\n\n\tfunction callDataFunction ( fn, context ) {\n\t\tvar data = fn.call( context );\n\n\t\tif ( !data ) return;\n\n\t\tif ( typeof data !== 'object' ) {\n\t\t\tfatal( 'Data function must return an object' );\n\t\t}\n\n\t\tif ( data.constructor !== Object ) {\n\t\t\twarnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tfunction fromProperties ( primary, secondary ) {\n\t\tif ( primary && secondary ) {\n\t\t\tfor ( var key in secondary ) {\n\t\t\t\tif ( !( key in primary ) ) {\n\t\t\t\t\tprimary[ key ] = secondary[ key ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn primary;\n\t\t}\n\n\t\treturn primary || secondary;\n\t}\n\n\tvar TEMPLATE_VERSION = 4;\n\n\tvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\n\tfunction fromExpression ( body, length ) {\n\t\tif ( length === void 0 ) length = 0;\n\n\t\tvar args = new Array( length );\n\n\t\twhile ( length-- ) {\n\t\t\targs[length] = \"_\" + length;\n\t\t}\n\n\t\t// Functions created directly with new Function() look like this:\n\t\t//     function anonymous (_0 /**/) { return _0*2 }\n\t\t//\n\t\t// With this workaround, we get a little more compact:\n\t\t//     function (_0){return _0*2}\n\t\treturn new Function( [], (\"return function (\" + (args.join(',')) + \"){return(\" + body + \");};\") )();\n\t}\n\n\tfunction fromComputationString ( str, bindTo ) {\n\t\tvar hasThis;\n\n\t\tvar functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {\n\t\t\thasThis = true;\n\t\t\treturn (\"__ractive.get(\\\"\" + keypath + \"\\\")\");\n\t\t}) + ');';\n\n\t\tif ( hasThis ) functionBody = \"var __ractive = this; \" + functionBody;\n\t\tvar fn = new Function( functionBody );\n\t\treturn hasThis ? fn.bind( bindTo ) : fn;\n\t}\n\n\tvar functions = create( null );\n\n\tfunction getFunction ( str, i ) {\n\t\tif ( functions[ str ] ) return functions[ str ];\n\t\treturn functions[ str ] = createFunction( str, i );\n\t}\n\n\tfunction addFunctions( template ) {\n\t\tif ( !template ) return;\n\n\t\tvar exp = template.e;\n\n\t\tif ( !exp ) return;\n\n\t\tObject.keys( exp ).forEach( function ( str ) {\n\t\t\tif ( functions[ str ] ) return;\n\t\t\tfunctions[ str ] = exp[ str ];\n\t\t});\n\t}\n\n\tvar Parser;\n\tvar ParseError;\n\tvar leadingWhitespace = /^\\s+/;\n\tParseError = function ( message ) {\n\t\tthis.name = 'ParseError';\n\t\tthis.message = message;\n\t\ttry {\n\t\t\tthrow new Error(message);\n\t\t} catch (e) {\n\t\t\tthis.stack = e.stack;\n\t\t}\n\t};\n\n\tParseError.prototype = Error.prototype;\n\n\tParser = function ( str, options ) {\n\t\tvar this$1 = this;\n\n\t\tvar items, item, lineStart = 0;\n\n\t\tthis.str = str;\n\t\tthis.options = options || {};\n\t\tthis.pos = 0;\n\n\t\tthis.lines = this.str.split( '\\n' );\n\t\tthis.lineEnds = this.lines.map( function ( line ) {\n\t\t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n\t\t\tlineStart = lineEnd;\n\t\t\treturn lineEnd;\n\t\t}, 0 );\n\n\t\t// Custom init logic\n\t\tif ( this.init ) this.init( str, options );\n\n\t\titems = [];\n\n\t\twhile ( ( this$1.pos < this$1.str.length ) && ( item = this$1.read() ) ) {\n\t\t\titems.push( item );\n\t\t}\n\n\t\tthis.leftover = this.remaining();\n\t\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n\t};\n\n\tParser.prototype = {\n\t\tread: function ( converters ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar pos, i, len, item;\n\n\t\t\tif ( !converters ) converters = this.converters;\n\n\t\t\tpos = this.pos;\n\n\t\t\tlen = converters.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tthis$1.pos = pos; // reset for each attempt\n\n\t\t\t\tif ( item = converters[i]( this$1 ) ) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tgetContextMessage: function ( pos, message ) {\n\t\t\tvar ref = this.getLinePos( pos ), lineNum = ref[0], columnNum = ref[1];\n\t\t\tif ( this.options.contextLines === -1 ) {\n\t\t\t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum) ];\n\t\t\t}\n\n\t\t\tvar line = this.lines[ lineNum - 1 ];\n\n\t\t\tvar contextUp = '';\n\t\t\tvar contextDown = '';\n\t\t\tif ( this.options.contextLines ) {\n\t\t\t\tvar start = lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n\t\t\t\tcontextUp = this.lines.slice( start, lineNum - 1 - start ).join( '\\n' ).replace( /\\t/g, '  ' );\n\t\t\t\tcontextDown = this.lines.slice( lineNum, lineNum + this.options.contextLines ).join( '\\n' ).replace( /\\t/g, '  ' );\n\t\t\t\tif ( contextUp ) {\n\t\t\t\t\tcontextUp += '\\n';\n\t\t\t\t}\n\t\t\t\tif ( contextDown ) {\n\t\t\t\t\tcontextDown = '\\n' + contextDown;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar numTabs = 0;\n\t\t\tvar annotation = contextUp + line.replace( /\\t/g, function ( match, char ) {\n\t\t\t\tif ( char < columnNum ) {\n\t\t\t\t\tnumTabs += 1;\n\t\t\t\t}\n\n\t\t\t\treturn '  ';\n\t\t\t}) + '\\n' + new Array( columnNum + numTabs ).join( ' ' ) + '^----' + contextDown;\n\n\t\t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation) ];\n\t\t},\n\n\t\tgetLinePos: function ( char ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar lineNum = 0, lineStart = 0, columnNum;\n\n\t\t\twhile ( char >= this$1.lineEnds[ lineNum ] ) {\n\t\t\t\tlineStart = this$1.lineEnds[ lineNum ];\n\t\t\t\tlineNum += 1;\n\t\t\t}\n\n\t\t\tcolumnNum = char - lineStart;\n\t\t\treturn [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!\n\t\t},\n\n\t\terror: function ( message ) {\n\t\t\tvar ref = this.getContextMessage( this.pos, message ), lineNum = ref[0], columnNum = ref[1], msg = ref[2];\n\n\t\t\tvar error = new ParseError( msg );\n\n\t\t\terror.line = lineNum;\n\t\t\terror.character = columnNum;\n\t\t\terror.shortMessage = message;\n\n\t\t\tthrow error;\n\t\t},\n\n\t\tmatchString: function ( string ) {\n\t\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\t\tthis.pos += string.length;\n\t\t\t\treturn string;\n\t\t\t}\n\t\t},\n\n\t\tmatchPattern: function ( pattern ) {\n\t\t\tvar match;\n\n\t\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\t\tthis.pos += match[0].length;\n\t\t\t\treturn match[1] || match[0];\n\t\t\t}\n\t\t},\n\n\t\tallowWhitespace: function () {\n\t\t\tthis.matchPattern( leadingWhitespace );\n\t\t},\n\n\t\tremaining: function () {\n\t\t\treturn this.str.substring( this.pos );\n\t\t},\n\n\t\tnextChar: function () {\n\t\t\treturn this.str.charAt( this.pos );\n\t\t}\n\t};\n\n\tParser.extend = function ( proto ) {\n\t\tvar Parent = this, Child, key;\n\n\t\tChild = function ( str, options ) {\n\t\t\tParser.call( this, str, options );\n\t\t};\n\n\t\tChild.prototype = create( Parent.prototype );\n\n\t\tfor ( key in proto ) {\n\t\t\tif ( hasOwn.call( proto, key ) ) {\n\t\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t\t}\n\t\t}\n\n\t\tChild.extend = Parser.extend;\n\t\treturn Child;\n\t};\n\n\tvar Parser$1 = Parser;\n\n\tvar TEXT              = 1;\n\tvar INTERPOLATOR      = 2;\n\tvar TRIPLE            = 3;\n\tvar SECTION           = 4;\n\tvar INVERTED          = 5;\n\tvar CLOSING           = 6;\n\tvar ELEMENT           = 7;\n\tvar PARTIAL           = 8;\n\tvar COMMENT           = 9;\n\tvar DELIMCHANGE       = 10;\n\tvar ATTRIBUTE         = 13;\n\tvar CLOSING_TAG       = 14;\n\tvar COMPONENT         = 15;\n\tvar YIELDER           = 16;\n\tvar INLINE_PARTIAL    = 17;\n\tvar DOCTYPE           = 18;\n\tvar ALIAS             = 19;\n\n\tvar NUMBER_LITERAL    = 20;\n\tvar STRING_LITERAL    = 21;\n\tvar ARRAY_LITERAL     = 22;\n\tvar OBJECT_LITERAL    = 23;\n\tvar BOOLEAN_LITERAL   = 24;\n\tvar REGEXP_LITERAL    = 25;\n\n\tvar GLOBAL            = 26;\n\tvar KEY_VALUE_PAIR    = 27;\n\n\n\tvar REFERENCE         = 30;\n\tvar REFINEMENT        = 31;\n\tvar MEMBER            = 32;\n\tvar PREFIX_OPERATOR   = 33;\n\tvar BRACKETED         = 34;\n\tvar CONDITIONAL       = 35;\n\tvar INFIX_OPERATOR    = 36;\n\n\tvar INVOCATION        = 40;\n\n\tvar SECTION_IF        = 50;\n\tvar SECTION_UNLESS    = 51;\n\tvar SECTION_EACH      = 52;\n\tvar SECTION_WITH      = 53;\n\tvar SECTION_IF_WITH   = 54;\n\n\tvar ELSE              = 60;\n\tvar ELSEIF            = 61;\n\n\tvar EVENT             = 70;\n\tvar DECORATOR         = 71;\n\tvar TRANSITION        = 72;\n\tvar BINDING_FLAG      = 73;\n\n\tvar delimiterChangePattern = /^[^\\s=]+/;\n\tvar whitespacePattern = /^\\s+/;\n\tfunction readDelimiterChange ( parser ) {\n\t\tvar start, opening, closing;\n\n\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstart = parser.pos;\n\n\t\t// allow whitespace before new opening delimiter\n\t\tparser.allowWhitespace();\n\n\t\topening = parser.matchPattern( delimiterChangePattern );\n\t\tif ( !opening ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\t// allow whitespace (in fact, it's necessary...)\n\t\tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tclosing = parser.matchPattern( delimiterChangePattern );\n\t\tif ( !closing ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\t// allow whitespace before closing '='\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn [ opening, closing ];\n\t}\n\n\tvar regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\n\tfunction readNumberLiteral ( parser ) {\n\t\tvar result;\n\n\t\tif ( result = parser.matchPattern( regexpPattern ) ) {\n\t\t\treturn {\n\t\t\t\tt: REGEXP_LITERAL,\n\t\t\t\tv: result\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tvar pattern$1 = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\n\tfunction escapeRegExp ( str ) {\n\t\treturn str.replace( pattern$1, '\\\\$&' );\n\t}\n\n\tvar regExpCache = {};\n\n\tfunction getLowestIndex ( haystack, needles ) {\n\t\treturn haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) );\n\t}\n\n\t// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n\tvar booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n\tvar voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n\tvar htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830\t};\n\tvar controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];\n\tvar entityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\tvar codePointSupport = typeof String.fromCodePoint === 'function';\n\tvar codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\n\tfunction decodeCharacterReferences ( html ) {\n\t\treturn html.replace( entityPattern, function ( match, entity ) {\n\t\t\tvar code;\n\n\t\t\t// Handle named entities\n\t\t\tif ( entity[0] !== '#' ) {\n\t\t\t\tcode = htmlEntities[ entity ];\n\t\t\t} else if ( entity[1] === 'x' ) {\n\t\t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t\t\t} else {\n\t\t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t\t\t}\n\n\t\t\tif ( !code ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\treturn codeToChar( validateCode( code ) );\n\t\t});\n\t}\n\n\tvar lessThan = /</g;\n\tvar greaterThan = />/g;\n\tvar amp = /&/g;\n\tvar invalid = 65533;\n\n\tfunction escapeHtml ( str ) {\n\t\treturn str\n\t\t\t.replace( amp, '&amp;' )\n\t\t\t.replace( lessThan, '&lt;' )\n\t\t\t.replace( greaterThan, '&gt;' );\n\t}\n\n\t// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n\t// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n\t// to replace them ourselves\n\t//\n\t// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\tfunction validateCode ( code ) {\n\t\tif ( !code ) {\n\t\t\treturn invalid;\n\t\t}\n\n\t\t// line feed becomes generic whitespace\n\t\tif ( code === 10 ) {\n\t\t\treturn 32;\n\t\t}\n\n\t\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\t\tif ( code < 128 ) {\n\t\t\treturn code;\n\t\t}\n\n\t\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t\t// to correct the mistake or we'll end up with missing  signs and so on\n\t\tif ( code <= 159 ) {\n\t\t\treturn controlCharacters[ code - 128 ];\n\t\t}\n\n\t\t// basic multilingual plane\n\t\tif ( code < 55296 ) {\n\t\t\treturn code;\n\t\t}\n\n\t\t// UTF-16 surrogate halves\n\t\tif ( code <= 57343 ) {\n\t\t\treturn invalid;\n\t\t}\n\n\t\t// rest of the basic multilingual plane\n\t\tif ( code <= 65535 ) {\n\t\t\treturn code;\n\t\t} else if ( !codePointSupport ) {\n\t\t\treturn invalid;\n\t\t}\n\n\t\t// supplementary multilingual plane 0x10000 - 0x1ffff\n\t\tif ( code >= 65536 && code <= 131071 ) {\n\t\t\treturn code;\n\t\t}\n\n\t\t// supplementary ideographic plane 0x20000 - 0x2ffff\n\t\tif ( code >= 131072 && code <= 196607 ) {\n\t\t\treturn code;\n\t\t}\n\n\t\treturn invalid;\n\t}\n\n\tvar expectedExpression = 'Expected a JavaScript expression';\n\tvar expectedParen = 'Expected closing paren';\n\n\t// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\n\tvar numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\n\tfunction readNumberLiteral$1 ( parser ) {\n\t\tvar result;\n\n\t\tif ( result = parser.matchPattern( numberPattern ) ) {\n\t\t\treturn {\n\t\t\t\tt: NUMBER_LITERAL,\n\t\t\t\tv: result\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction readBooleanLiteral ( parser ) {\n\t\tvar remaining = parser.remaining();\n\n\t\tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t\t\tparser.pos += 4;\n\t\t\treturn {\n\t\t\t\tt: BOOLEAN_LITERAL,\n\t\t\t\tv: 'true'\n\t\t\t};\n\t\t}\n\n\t\tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t\t\tparser.pos += 5;\n\t\t\treturn {\n\t\t\t\tt: BOOLEAN_LITERAL,\n\t\t\t\tv: 'false'\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tvar stringMiddlePattern;\n\tvar escapeSequencePattern;\n\tvar lineContinuationPattern;\n\t// Match one or more characters until: \", ', \\, or EOL/EOF.\n\t// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n\tstringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n\t// Match one escape sequence, including the backslash.\n\tescapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n\t// Match one ES5 line continuation (backslash + line terminator).\n\tlineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n\t// Helper for defining getDoubleQuotedString and getSingleQuotedString.\n\tfunction makeQuotedStringMatcher ( okQuote ) {\n\t\treturn function ( parser ) {\n\t\t\tvar literal = '\"';\n\t\t\tvar done = false;\n\t\t\tvar next;\n\n\t\t\twhile ( !done ) {\n\t\t\t\tnext = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||\n\t\t\t\t\tparser.matchString( okQuote ) );\n\t\t\t\tif ( next ) {\n\t\t\t\t\tif ( next === (\"\\\"\") ) {\n\t\t\t\t\t\tliteral += \"\\\\\\\"\";\n\t\t\t\t\t} else if ( next === (\"\\\\'\") ) {\n\t\t\t\t\t\tliteral += \"'\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tliteral += next;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t\t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tliteral += '\"';\n\n\t\t\t// use JSON.parse to interpret escapes\n\t\t\treturn JSON.parse( literal );\n\t\t};\n\t}\n\n\tvar getSingleQuotedString = makeQuotedStringMatcher( (\"\\\"\") );\n\tvar getDoubleQuotedString = makeQuotedStringMatcher( (\"'\") );\n\n\tfunction readStringLiteral ( parser ) {\n\t\tvar start, string;\n\n\t\tstart = parser.pos;\n\n\t\tif ( parser.matchString( '\"' ) ) {\n\t\t\tstring = getDoubleQuotedString( parser );\n\n\t\t\tif ( !parser.matchString( '\"' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tt: STRING_LITERAL,\n\t\t\t\tv: string\n\t\t\t};\n\t\t}\n\n\t\tif ( parser.matchString( (\"'\") ) ) {\n\t\t\tstring = getSingleQuotedString( parser );\n\n\t\t\tif ( !parser.matchString( (\"'\") ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tt: STRING_LITERAL,\n\t\t\t\tv: string\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tvar namePattern = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n\tvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n\t// http://mathiasbynens.be/notes/javascript-properties\n\t// can be any name, string literal, or number literal\n\tfunction readKey ( parser ) {\n\t\tvar token;\n\n\t\tif ( token = readStringLiteral( parser ) ) {\n\t\t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t\t}\n\n\t\tif ( token = readNumberLiteral$1( parser ) ) {\n\t\t\treturn token.v;\n\t\t}\n\n\t\tif ( token = parser.matchPattern( namePattern ) ) {\n\t\t\treturn token;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction readKeyValuePair ( parser ) {\n\t\tvar start, key, value;\n\n\t\tstart = parser.pos;\n\n\t\t// allow whitespace between '{' and key\n\t\tparser.allowWhitespace();\n\n\t\tvar refKey = parser.nextChar() !== '\\'' && parser.nextChar() !== '\"';\n\n\t\tkey = readKey( parser );\n\t\tif ( key === null ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\t// allow whitespace between key and ':'\n\t\tparser.allowWhitespace();\n\n\t\t// es2015 shorthand property\n\t\tif ( refKey && ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {\n\t\t\tif ( !namePattern.test( key ) ) {\n\t\t\t\tparser.error( (\"Expected a valid reference, but found '\" + key + \"' instead.\") );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tt: KEY_VALUE_PAIR,\n\t\t\t\tk: key,\n\t\t\t\tv: {\n\t\t\t\t\tt: REFERENCE,\n\t\t\t\t\tn: key\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// next character must be ':'\n\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\t// allow whitespace between ':' and value\n\t\tparser.allowWhitespace();\n\n\t\t// next expression must be a, well... expression\n\t\tvalue = readExpression( parser );\n\t\tif ( value === null ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: KEY_VALUE_PAIR,\n\t\t\tk: key,\n\t\t\tv: value\n\t\t};\n\t}\n\n\tfunction readKeyValuePairs ( parser ) {\n\t\tvar start, pairs, pair, keyValuePairs;\n\n\t\tstart = parser.pos;\n\n\t\tpair = readKeyValuePair( parser );\n\t\tif ( pair === null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpairs = [ pair ];\n\n\t\tif ( parser.matchString( ',' ) ) {\n\t\t\tkeyValuePairs = readKeyValuePairs( parser );\n\n\t\t\tif ( !keyValuePairs ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn pairs.concat( keyValuePairs );\n\t\t}\n\n\t\treturn pairs;\n\t}\n\n\tfunction readObjectLiteral ( parser ) {\n\t\tvar start, keyValuePairs;\n\n\t\tstart = parser.pos;\n\n\t\t// allow whitespace\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tkeyValuePairs = readKeyValuePairs( parser );\n\n\t\t// allow whitespace between final value and '}'\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( '}' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: OBJECT_LITERAL,\n\t\t\tm: keyValuePairs\n\t\t};\n\t}\n\n\tfunction readExpressionList ( parser ) {\n\t\tparser.allowWhitespace();\n\n\t\tvar expr = readExpression( parser );\n\n\t\tif ( expr === null ) return null;\n\n\t\tvar expressions = [ expr ];\n\n\t\t// allow whitespace between expression and ','\n\t\tparser.allowWhitespace();\n\n\t\tif ( parser.matchString( ',' ) ) {\n\t\t\tvar next = readExpressionList( parser );\n\t\t\tif ( next === null ) parser.error( expectedExpression );\n\n\t\t\texpressions.push.apply( expressions, next );\n\t\t}\n\n\t\treturn expressions;\n\t}\n\n\tfunction readArrayLiteral ( parser ) {\n\t\tvar start, expressionList;\n\n\t\tstart = parser.pos;\n\n\t\t// allow whitespace before '['\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\texpressionList = readExpressionList( parser );\n\n\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: ARRAY_LITERAL,\n\t\t\tm: expressionList\n\t\t};\n\t}\n\n\tfunction readLiteral ( parser ) {\n\t\treturn readNumberLiteral$1( parser )  ||\n\t\t       readBooleanLiteral( parser ) ||\n\t\t       readStringLiteral( parser )  ||\n\t\t       readObjectLiteral( parser )  ||\n\t\t       readArrayLiteral( parser )   ||\n\t\t       readNumberLiteral( parser );\n\t}\n\n\tvar prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\n\tvar globals;\n\tvar keywords;\n\t// if a reference is a browser global, we don't deference it later, so it needs special treatment\n\tglobals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/;\n\n\t// keywords are not valid references, with the exception of `this`\n\tkeywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n\tvar legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n\tvar relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*/;\n\tvar specials = /^@(?:keypath|rootpath|index|key|this|global)/;\n\tvar specialCall = /^\\s*\\(/;\n\tvar spreadPattern = /^\\s*\\.{3}/;\n\n\tfunction readReference ( parser ) {\n\t\tvar startPos, prefix, name, global, reference, fullLength, lastDotIndex, spread;\n\n\t\tstartPos = parser.pos;\n\n\t\tname = parser.matchPattern( specials );\n\n\t\tif ( name === '@keypath' || name === '@rootpath' ) {\n\t\t\tif ( parser.matchPattern( specialCall ) ) {\n\t\t\t\tvar ref = readReference( parser );\n\t\t\t\tif ( !ref ) parser.error( (\"Expected a valid reference for a keypath expression\") );\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( !parser.matchString( ')' ) ) parser.error( (\"Unclosed keypath expression\") );\n\t\t\t\tname += \"(\" + (ref.n) + \")\";\n\t\t\t}\n\t\t}\n\n\t\tspread = !name && parser.spreadArgs && parser.matchPattern( spreadPattern );\n\n\t\tif ( !name ) {\n\t\t\tprefix = parser.matchPattern( prefixPattern ) || '';\n\t\t\tname = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||\n\t\t\t       parser.matchPattern( legalReference );\n\n\t\t\tif ( !name && prefix === '.' ) {\n\t\t\t\tprefix = '';\n\t\t\t\tname = '.';\n\t\t\t} else if ( !name && prefix ) {\n\t\t\t\tname = prefix;\n\t\t\t\tprefix = '';\n\t\t\t}\n\t\t}\n\n\t\tif ( !name ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n\t\tif ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {\n\t\t\tparser.pos = startPos;\n\t\t\treturn null;\n\t\t}\n\n\t\t// if this is a browser global, stop here\n\t\tif ( !prefix && globals.test( name ) ) {\n\t\t\tglobal = globals.exec( name )[0];\n\t\t\tparser.pos = startPos + global.length;\n\n\t\t\treturn {\n\t\t\t\tt: GLOBAL,\n\t\t\t\tv: ( spread ? '...' : '' ) + global\n\t\t\t};\n\t\t}\n\n\t\tfullLength = ( spread ? 3 : 0 ) + ( prefix || '' ).length + name.length;\n\t\treference = ( prefix || '' ) + normalise( name );\n\n\t\tif ( parser.matchString( '(' ) ) {\n\t\t\t// if this is a method invocation (as opposed to a function) we need\n\t\t\t// to strip the method name from the reference combo, else the context\n\t\t\t// will be wrong\n\t\t\t// but only if the reference was actually a member and not a refinement\n\t\t\tlastDotIndex = reference.lastIndexOf( '.' );\n\t\t\tif ( lastDotIndex !== -1 && name[ name.length - 1 ] !== ']' ) {\n\t\t\t\tvar refLength = reference.length;\n\t\t\t\treference = reference.substr( 0, lastDotIndex );\n\t\t\t\tparser.pos = startPos + (fullLength - ( refLength - lastDotIndex ) );\n\t\t\t} else {\n\t\t\t\tparser.pos -= 1;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tt: REFERENCE,\n\t\t\tn: ( spread ? '...' : '' ) + reference.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t\t};\n\t}\n\n\tfunction readBracketedExpression ( parser ) {\n\t\tif ( !parser.matchString( '(' ) ) return null;\n\n\t\tparser.allowWhitespace();\n\n\t\tvar expr = readExpression( parser );\n\n\t\tif ( !expr ) parser.error( expectedExpression );\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( ')' ) ) parser.error( expectedParen );\n\n\t\treturn {\n\t\t\tt: BRACKETED,\n\t\t\tx: expr\n\t\t};\n\t}\n\n\tfunction readPrimary ( parser ) {\n\t\treturn readLiteral( parser )\n\t\t\t|| readReference( parser )\n\t\t\t|| readBracketedExpression( parser );\n\t}\n\n\tfunction readRefinement ( parser ) {\n\t\t// some things call for strict refinement (partial names), meaning no space between reference and refinement\n\t\tif ( !parser.strictRefinement ) {\n\t\t\tparser.allowWhitespace();\n\t\t}\n\n\t\t// \".\" name\n\t\tif ( parser.matchString( '.' ) ) {\n\t\t\tparser.allowWhitespace();\n\n\t\t\tvar name = parser.matchPattern( namePattern );\n\t\t\tif ( name ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: REFINEMENT,\n\t\t\t\t\tn: name\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tparser.error( 'Expected a property name' );\n\t\t}\n\n\t\t// \"[\" expression \"]\"\n\t\tif ( parser.matchString( '[' ) ) {\n\t\t\tparser.allowWhitespace();\n\n\t\t\tvar expr = readExpression( parser );\n\t\t\tif ( !expr ) parser.error( expectedExpression );\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( !parser.matchString( ']' ) ) parser.error( (\"Expected ']'\") );\n\n\t\t\treturn {\n\t\t\t\tt: REFINEMENT,\n\t\t\t\tx: expr\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction readMemberOrInvocation ( parser ) {\n\t\tvar expression = readPrimary( parser );\n\n\t\tif ( !expression ) return null;\n\n\t\twhile ( expression ) {\n\t\t\tvar refinement = readRefinement( parser );\n\t\t\tif ( refinement ) {\n\t\t\t\texpression = {\n\t\t\t\t\tt: MEMBER,\n\t\t\t\t\tx: expression,\n\t\t\t\t\tr: refinement\n\t\t\t\t};\n\t\t\t}\n\n\t\t\telse if ( parser.matchString( '(' ) ) {\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tvar start = parser.spreadArgs;\n\t\t\t\tparser.spreadArgs = true;\n\t\t\t\tvar expressionList = readExpressionList( parser );\n\t\t\t\tparser.spreadArgs = start;\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\t\tparser.error( expectedParen );\n\t\t\t\t}\n\n\t\t\t\texpression = {\n\t\t\t\t\tt: INVOCATION,\n\t\t\t\t\tx: expression\n\t\t\t\t};\n\n\t\t\t\tif ( expressionList ) expression.o = expressionList;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn expression;\n\t}\n\n\tvar readTypeOf;\n\tvar makePrefixSequenceMatcher;\n\tmakePrefixSequenceMatcher = function ( symbol, fallthrough ) {\n\t\treturn function ( parser ) {\n\t\t\tvar expression;\n\n\t\t\tif ( expression = fallthrough( parser ) ) {\n\t\t\t\treturn expression;\n\t\t\t}\n\n\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\texpression = readExpression( parser );\n\t\t\tif ( !expression ) {\n\t\t\t\tparser.error( expectedExpression );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ts: symbol,\n\t\t\t\to: expression,\n\t\t\t\tt: PREFIX_OPERATOR\n\t\t\t};\n\t\t};\n\t};\n\n\t// create all prefix sequence matchers, return readTypeOf\n\t(function() {\n\t\tvar i, len, matcher, prefixOperators, fallthrough;\n\n\t\tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\n\t\tfallthrough = readMemberOrInvocation;\n\t\tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );\n\t\t\tfallthrough = matcher;\n\t\t}\n\n\t\t// typeof operator is higher precedence than multiplication, so provides the\n\t\t// fallthrough for the multiplication sequence matcher we're about to create\n\t\t// (we're skipping void and delete)\n\t\treadTypeOf = fallthrough;\n\t}());\n\n\tvar readTypeof = readTypeOf;\n\n\tvar readLogicalOr;\n\tvar makeInfixSequenceMatcher;\n\tmakeInfixSequenceMatcher = function ( symbol, fallthrough ) {\n\t\treturn function ( parser ) {\n\t\t\tvar start, left, right;\n\n\t\t\tleft = fallthrough( parser );\n\t\t\tif ( !left ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t\t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t\t\t// to parse `left` because that would be infinite regress.\n\t\t\twhile ( true ) {\n\t\t\t\tstart = parser.pos;\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn left;\n\t\t\t\t}\n\n\t\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn left;\n\t\t\t\t}\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\t// right operand must also consist of only higher-precedence operators\n\t\t\t\tright = fallthrough( parser );\n\t\t\t\tif ( !right ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn left;\n\t\t\t\t}\n\n\t\t\t\tleft = {\n\t\t\t\t\tt: INFIX_OPERATOR,\n\t\t\t\t\ts: symbol,\n\t\t\t\t\to: [ left, right ]\n\t\t\t\t};\n\n\t\t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n\t\t\t\t// we'll return left.\n\t\t\t}\n\t\t};\n\t};\n\n\t// create all infix sequence matchers, and return readLogicalOr\n\t(function() {\n\t\tvar i, len, matcher, infixOperators, fallthrough;\n\n\t\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t\t// Each sequence matcher will initially fall through to its higher precedence\n\t\t// neighbour, and only attempt to match if one of the higher precedence operators\n\t\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\t\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\n\t\t// A typeof operator is higher precedence than multiplication\n\t\tfallthrough = readTypeof;\n\t\tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t\t\tmatcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );\n\t\t\tfallthrough = matcher;\n\t\t}\n\n\t\t// Logical OR is the fallthrough for the conditional matcher\n\t\treadLogicalOr = fallthrough;\n\t}());\n\n\tvar readLogicalOr$1 = readLogicalOr;\n\n\t// The conditional operator is the lowest precedence operator, so we start here\n\tfunction getConditional ( parser ) {\n\t\tvar start, expression, ifTrue, ifFalse;\n\n\t\texpression = readLogicalOr$1( parser );\n\t\tif ( !expression ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstart = parser.pos;\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( '?' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn expression;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tifTrue = readExpression( parser );\n\t\tif ( !ifTrue ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\tparser.error( 'Expected \":\"' );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tifFalse = readExpression( parser );\n\t\tif ( !ifFalse ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\treturn {\n\t\t\tt: CONDITIONAL,\n\t\t\to: [ expression, ifTrue, ifFalse ]\n\t\t};\n\t}\n\n\tfunction readExpression ( parser ) {\n\t\t// The conditional operator is the lowest precedence operator (except yield,\n\t\t// assignment operators, and commas, none of which are supported), so we\n\t\t// start there. If it doesn't match, it 'falls through' to progressively\n\t\t// higher precedence operators, until it eventually matches (or fails to\n\t\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\t\treturn getConditional( parser );\n\t}\n\n\tfunction flattenExpression ( expression ) {\n\t\tvar refs, count = 0, stringified;\n\n\t\textractRefs( expression, refs = [] );\n\t\tstringified = stringify( expression );\n\n\t\trefs = refs.map( function ( r ) { return r.indexOf( '...' ) === 0 ? r.substr( 3 ) : r; } );\n\n\t\treturn {\n\t\t\tr: refs,\n\t\t\ts: getVars(stringified)\n\t\t};\n\n\t\tfunction getVars(expr) {\n\t\t\tvar vars = [];\n\t\t\tfor ( var i = count - 1; i >= 0; i-- ) {\n\t\t\t\tvars.push( (\"spread$\" + i) );\n\t\t\t}\n\t\t\treturn vars.length ? (\"(function(){var \" + (vars.join(',')) + \";return(\" + expr + \");})()\") : expr;\n\t\t}\n\n\t\tfunction stringify ( node ) {\n\t\t\tswitch ( node.t ) {\n\t\t\t\tcase BOOLEAN_LITERAL:\n\t\t\t\tcase GLOBAL:\n\t\t\t\tcase NUMBER_LITERAL:\n\t\t\t\tcase REGEXP_LITERAL:\n\t\t\t\t\treturn node.v;\n\n\t\t\t\tcase STRING_LITERAL:\n\t\t\t\t\treturn JSON.stringify( String( node.v ) );\n\n\t\t\t\tcase ARRAY_LITERAL:\n\t\t\t\t\treturn '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';\n\n\t\t\t\tcase OBJECT_LITERAL:\n\t\t\t\t\treturn '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';\n\n\t\t\t\tcase KEY_VALUE_PAIR:\n\t\t\t\t\treturn node.k + ':' + stringify( node.v );\n\n\t\t\t\tcase PREFIX_OPERATOR:\n\t\t\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );\n\n\t\t\t\tcase INFIX_OPERATOR:\n\t\t\t\t\treturn stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );\n\n\t\t\t\tcase INVOCATION:\n\t\t\t\t\tif ( node.spread ) {\n\t\t\t\t\t\tvar id = count++;\n\t\t\t\t\t\treturn (\"(spread$\" + id + \" = \" + (stringify(node.x)) + \").apply(spread$\" + id + \", [].concat(\" + (node.o ? node.o.map( function ( a ) { return a.n && a.n.indexOf( '...' ) === 0 ? stringify( a ) : '[' + stringify(a) + ']'; } ).join( ',' ) : '') + \") )\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';\n\t\t\t\t\t}\n\n\t\t\t\tcase BRACKETED:\n\t\t\t\t\treturn '(' + stringify( node.x ) + ')';\n\n\t\t\t\tcase MEMBER:\n\t\t\t\t\treturn stringify( node.x ) + stringify( node.r );\n\n\t\t\t\tcase REFINEMENT:\n\t\t\t\t\treturn ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );\n\n\t\t\t\tcase CONDITIONAL:\n\t\t\t\t\treturn stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );\n\n\t\t\t\tcase REFERENCE:\n\t\t\t\t\treturn '_' + refs.indexOf( node.n );\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Expected legal JavaScript' );\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO maybe refactor this?\n\tfunction extractRefs ( node, refs ) {\n\t\tvar i, list;\n\n\t\tif ( node.t === REFERENCE ) {\n\t\t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t\t\t\trefs.unshift( node.n );\n\t\t\t}\n\t\t}\n\n\t\tlist = node.o || node.m;\n\t\tif ( list ) {\n\t\t\tif ( isObject( list ) ) {\n\t\t\t\textractRefs( list, refs );\n\t\t\t} else {\n\t\t\t\ti = list.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( list[i].n && list[i].n.indexOf('...') === 0 ) {\n\t\t\t\t\t\tnode.spread = true;\n\t\t\t\t\t}\n\t\t\t\t\textractRefs( list[i], refs );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( node.x ) {\n\t\t\textractRefs( node.x, refs );\n\t\t}\n\n\t\tif ( node.r ) {\n\t\t\textractRefs( node.r, refs );\n\t\t}\n\n\t\tif ( node.v ) {\n\t\t\textractRefs( node.v, refs );\n\t\t}\n\t}\n\n\t// simple JSON parser, without the restrictions of JSON parse\n\t// (i.e. having to double-quote keys).\n\t//\n\t// If passed a hash of values as the second argument, ${placeholders}\n\t// will be replaced with those values\n\n\tvar specials$1 = {\n\t\t'true': true,\n\t\t'false': false,\n\t\t'null': null,\n\t\tundefined: undefined\n\t};\n\n\tvar specialsPattern = new RegExp( '^(?:' + Object.keys( specials$1 ).join( '|' ) + ')' );\n\tvar numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\tvar placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n\tvar placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n\tvar onlyWhitespace = /^\\s*$/;\n\n\tvar JsonParser = Parser$1.extend({\n\t\tinit: function ( str, options ) {\n\t\t\tthis.values = options.values;\n\t\t\tthis.allowWhitespace();\n\t\t},\n\n\t\tpostProcess: function ( result ) {\n\t\t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn { value: result[0].v };\n\t\t},\n\n\t\tconverters: [\n\t\t\tfunction getPlaceholder ( parser ) {\n\t\t\t\tif ( !parser.values ) return null;\n\n\t\t\t\tvar placeholder = parser.matchPattern( placeholderAtStartPattern );\n\n\t\t\t\tif ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {\n\t\t\t\t\treturn { v: parser.values[ placeholder ] };\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfunction getSpecial ( parser ) {\n\t\t\t\tvar special = parser.matchPattern( specialsPattern );\n\t\t\t\tif ( special ) return { v: specials$1[ special ] };\n\t\t\t},\n\n\t\t\tfunction getNumber ( parser ) {\n\t\t\t\tvar number = parser.matchPattern( numberPattern$1 );\n\t\t\t\tif ( number ) return { v: +number };\n\t\t\t},\n\n\t\t\tfunction getString ( parser ) {\n\t\t\t\tvar stringLiteral = readStringLiteral( parser );\n\t\t\t\tvar values = parser.values;\n\n\t\t\t\tif ( stringLiteral && values ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn stringLiteral;\n\t\t\t},\n\n\t\t\tfunction getObject ( parser ) {\n\t\t\t\tif ( !parser.matchString( '{' ) ) return null;\n\n\t\t\t\tvar result = {};\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\treturn { v: result };\n\t\t\t\t}\n\n\t\t\t\tvar pair;\n\t\t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t\t\t\t\tresult[ pair.key ] = pair.value;\n\n\t\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\treturn { v: result };\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\n\t\t\tfunction getArray ( parser ) {\n\t\t\t\tif ( !parser.matchString( '[' ) ) return null;\n\n\t\t\t\tvar result = [];\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\treturn { v: result };\n\t\t\t\t}\n\n\t\t\t\tvar valueToken;\n\t\t\t\twhile ( valueToken = parser.read() ) {\n\t\t\t\t\tresult.push( valueToken.v );\n\n\t\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\treturn { v: result };\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t]\n\t});\n\n\tfunction getKeyValuePair ( parser ) {\n\t\tparser.allowWhitespace();\n\n\t\tvar key = readKey( parser );\n\n\t\tif ( !key ) return null;\n\n\t\tvar pair = { key: key };\n\n\t\tparser.allowWhitespace();\n\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tparser.allowWhitespace();\n\n\t\tvar valueToken = parser.read();\n\n\t\tif ( !valueToken ) return null;\n\n\t\tpair.value = valueToken.v;\n\t\treturn pair;\n\t}\n\n\tfunction parseJSON ( str, values ) {\n\t\tvar parser = new JsonParser( str, { values: values });\n\t\treturn parser.result;\n\t}\n\n\tvar methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*\\)\\s*$/;\n\tvar ExpressionParser;\n\tExpressionParser = Parser$1.extend({\n\t\tconverters: [ readExpression ],\n\t\tspreadArgs: true\n\t});\n\n\t// TODO clean this up, it's shocking\n\tfunction processDirective ( tokens, parentParser, type ) {\n\t\tvar result,\n\t\t\tmatch,\n\t\t\ttoken,\n\t\t\tcolonIndex,\n\t\t\tdirectiveName,\n\t\t\tdirectiveArgs,\n\t\t\tparsed;\n\n\t\tif ( typeof tokens === 'string' ) {\n\t\t\tvar pos = parentParser.pos - tokens.length;\n\t\t\tif ( type === DECORATOR || type === TRANSITION ) {\n\t\t\t\tvar parser = new ExpressionParser( (\"[\" + tokens + \"]\") );\n\t\t\t\treturn { a: flattenExpression( parser.result[0] ) };\n\t\t\t}\n\n\t\t\tif ( type === EVENT && ( match = methodCallPattern.exec( tokens ) ) ) {\n\t\t\t\twarnIfDebug( parentParser.getContextMessage( pos, (\"Unqualified method events are deprecated. Prefix methods with '@this.' to call methods on the current Ractive instance.\") )[2] );\n\t\t\t\ttokens = \"@this.\" + (match[1]) + \"\" + (tokens.substr(match[1].length));\n\t\t\t}\n\n\t\t\tif ( type === EVENT && ~tokens.indexOf( '(' ) ) {\n\t\t\t\tvar parser$1 = new ExpressionParser( '[' + tokens + ']' );\n\t\t\t\tif ( parser$1.result && parser$1.result[0] ) {\n\t\t\t\t\tif ( parser$1.remaining().length ) {\n\t\t\t\t\t\tparentParser.pos = pos + tokens.length - parser$1.remaining().length;\n\t\t\t\t\t\tparentParser.error( (\"Invalid input after event expression '\" + (parser$1.remaining()) + \"'\") );\n\t\t\t\t\t}\n\t\t\t\t\treturn { x: flattenExpression( parser$1.result[0] ) };\n\t\t\t\t}\n\n\t\t\t\tif ( tokens.indexOf( ':' ) > tokens.indexOf( '(' ) || !~tokens.indexOf( ':' ) ) {\n\t\t\t\t\tparentParser.pos = pos;\n\t\t\t\t\tparentParser.error( (\"Invalid input in event expression '\" + tokens + \"'\") );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t\t\t\treturn tokens.trim();\n\t\t\t}\n\n\t\t\ttokens = [ tokens ];\n\t\t}\n\n\t\tresult = {};\n\n\t\tdirectiveName = [];\n\t\tdirectiveArgs = [];\n\n\t\tif ( tokens ) {\n\t\t\twhile ( tokens.length ) {\n\t\t\t\ttoken = tokens.shift();\n\n\t\t\t\tif ( typeof token === 'string' ) {\n\t\t\t\t\tcolonIndex = token.indexOf( ':' );\n\n\t\t\t\t\tif ( colonIndex === -1 ) {\n\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// is the colon the first character?\n\t\t\t\t\t\tif ( colonIndex ) {\n\t\t\t\t\t\t\t// no\n\t\t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if there is anything after the colon in this token, treat\n\t\t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t\t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t\t\t\t\t\t\tdirectiveArgs[0] = token.substring( colonIndex + 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t\t}\n\n\t\tif ( !directiveName.length ) {\n\t\t\tresult = '';\n\t\t} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t\t\tresult = {\n\t\t\t\t// TODO is this really necessary? just use the array\n\t\t\t\tn: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )\n\t\t\t};\n\n\t\t\tif ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {\n\t\t\t\tparsed = parseJSON( '[' + directiveArgs[0] + ']' );\n\t\t\t\tresult.a = parsed ? parsed.value : [ directiveArgs[0].trim() ];\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tresult.d = directiveArgs;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = directiveName;\n\t\t}\n\n\t\tif ( directiveArgs.length && type ) {\n\t\t\twarnIfDebug( parentParser.getContextMessage( parentParser.pos, (\"Proxy events with arguments are deprecated. You can fire events with arguments using \\\"@this.fire('eventName', arg1, arg2, ...)\\\".\") )[2] );\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvar attributeNamePattern = /^[^\\s\"'>\\/=]+/;\n\tvar onPattern = /^on/;\n\tvar proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/;\n\tvar reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/;\n\tvar decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\n\tvar transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\n\tvar directives = {\n\t\t\t\t\t   'intro-outro': { t: TRANSITION, v: 't0' },\n\t\t\t\t\t   intro: { t: TRANSITION, v: 't1' },\n\t\t\t\t\t   outro: { t: TRANSITION, v: 't2' },\n\t\t\t\t\t   lazy: { t: BINDING_FLAG, v: 'l' },\n\t\t\t\t\t   twoway: { t: BINDING_FLAG, v: 't' },\n\t\t\t\t\t   decorator: { t: DECORATOR }\n\t\t\t\t\t };\n\tvar unquotedAttributeValueTextPattern = /^[^\\s\"'=<>\\/`]+/;\n\tfunction readAttribute ( parser ) {\n\t\tvar attr, name, value, i, nearest, idx;\n\n\t\tparser.allowWhitespace();\n\n\t\tname = parser.matchPattern( attributeNamePattern );\n\t\tif ( !name ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n\t\tnearest = name.length;\n\t\tfor ( i = 0; i < parser.tags.length; i++ ) {\n\t\t\tif ( ~( idx = name.indexOf( parser.tags[ i ].open ) ) ) {\n\t\t\t\tif ( idx < nearest ) nearest = idx;\n\t\t\t}\n\t\t}\n\t\tif ( nearest < name.length ) {\n\t\t\tparser.pos -= name.length - nearest;\n\t\t\tname = name.substr( 0, nearest );\n\t\t\tif ( !name ) return null;\n\t\t\telse return { n: name };\n\t\t}\n\n\t\tattr = { n: name };\n\n\t\tvalue = readAttributeValue( parser );\n\t\tif ( value != null ) { // not null/undefined\n\t\t\tattr.f = value;\n\t\t}\n\n\t\treturn attr;\n\t}\n\n\tfunction readAttributeValue ( parser ) {\n\t\tvar start, valueStart, startDepth, value;\n\n\t\tstart = parser.pos;\n\n\t\t// next character must be `=`, `/`, `>` or whitespace\n\t\tif ( !/[=\\/>\\s]/.test( parser.nextChar() ) ) {\n\t\t\tparser.error( 'Expected `=`, `/`, `>` or whitespace' );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tvalueStart = parser.pos;\n\t\tstartDepth = parser.sectionDepth;\n\n\t\tvalue = readQuotedAttributeValue( parser, (\"'\") ) ||\n\t\t\t\treadQuotedAttributeValue( parser, (\"\\\"\") ) ||\n\t\t\t\treadUnquotedAttributeValue( parser );\n\n\t\tif ( value === null ) {\n\t\t\tparser.error( 'Expected valid attribute value' );\n\t\t}\n\n\t\tif ( parser.sectionDepth !== startDepth ) {\n\t\t\tparser.pos = valueStart;\n\t\t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t\t}\n\n\t\tif ( !value.length ) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif ( value.length === 1 && typeof value[0] === 'string' ) {\n\t\t\treturn decodeCharacterReferences( value[0] );\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tfunction readUnquotedAttributeValueToken ( parser ) {\n\t\tvar start, text, haystack, needles, index;\n\n\t\tstart = parser.pos;\n\n\t\ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\n\t\tif ( !text ) {\n\t\t\treturn null;\n\t\t}\n\n\t\thaystack = text;\n\t\tneedles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n\n\t\tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t\t\ttext = text.substr( 0, index );\n\t\t\tparser.pos = start + text.length;\n\t\t}\n\n\t\treturn text;\n\t}\n\n\tfunction readUnquotedAttributeValue ( parser ) {\n\t\tvar tokens, token;\n\n\t\tparser.inAttribute = true;\n\n\t\ttokens = [];\n\n\t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t\twhile ( token ) {\n\t\t\ttokens.push( token );\n\t\t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t\t}\n\n\t\tif ( !tokens.length ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.inAttribute = false;\n\t\treturn tokens;\n\t}\n\n\tfunction readQuotedAttributeValue ( parser, quoteMark ) {\n\t\tvar start, tokens, token;\n\n\t\tstart = parser.pos;\n\n\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.inAttribute = quoteMark;\n\n\t\ttokens = [];\n\n\t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t\twhile ( token !== null ) {\n\t\t\ttokens.push( token );\n\t\t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t\t}\n\n\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.inAttribute = false;\n\n\t\treturn tokens;\n\t}\n\n\tfunction readQuotedStringToken ( parser, quoteMark ) {\n\t\tvar haystack = parser.remaining();\n\n\t\tvar needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n\t\tneedles.push( quoteMark );\n\n\t\tvar index = getLowestIndex( haystack, needles );\n\n\t\tif ( index === -1 ) {\n\t\t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t\t}\n\n\t\tif ( !index ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.pos += index;\n\t\treturn haystack.substr( 0, index );\n\t}\n\n\tfunction readAttributeOrDirective ( parser ) {\n\t\t\tvar match,\n\t\t\t\tattribute,\n\t\t\t    directive;\n\n\t\t\tattribute = readAttribute( parser );\n\n\t\t\tif ( !attribute ) return null;\n\n\t\t\t// intro, outro, decorator\n\t\t\tif ( directive = directives[ attribute.n ] ) {\n\t\t\t\tattribute.t = directive.t;\n\t\t\t\tif ( directive.v ) attribute.v = directive.v;\n\t\t\t\tdelete attribute.n; // no name necessary\n\n\t\t\t\tif ( directive.t === TRANSITION || directive.t === DECORATOR ) attribute.f = processDirective( attribute.f, parser );\n\n\t\t\t\tif ( directive.t === TRANSITION ) {\n\t\t\t\t\twarnOnceIfDebug( (\"\" + (directive.v === 't0' ? 'intro-outro' : directive.v === 't1' ? 'intro' : 'outro') + \" is deprecated. To specify tranisitions, use the transition name suffixed with '-in', '-out', or '-in-out' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n\t\t\t\t} else if ( directive.t === DECORATOR ) {\n\t\t\t\t\twarnOnceIfDebug( (\"decorator is deprecated. To specify decorators, use the decorator name prefixed with 'as-' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// decorators\n\t\t\telse if ( match = decoratorPattern.exec( attribute.n ) ) {\n\t\t\t\tdelete attribute.n;\n\t\t\t\tattribute.t = DECORATOR;\n\t\t\t\tattribute.f = processDirective( attribute.f, parser, DECORATOR );\n\t\t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n\t\t\t\telse attribute.f = match[1];\n\t\t\t}\n\n\t\t\t// transitions\n\t\t\telse if ( match = transitionPattern.exec( attribute.n ) ) {\n\t\t\t\tdelete attribute.n;\n\t\t\t\tattribute.t = TRANSITION;\n\t\t\t\tattribute.f = processDirective( attribute.f, parser, TRANSITION );\n\t\t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n\t\t\t\telse attribute.f = match[1];\n\t\t\t\tattribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n\t\t\t}\n\n\t\t\t// on-click etc\n\t\t\telse if ( match = proxyEventPattern.exec( attribute.n ) ) {\n\t\t\t\tattribute.n = match[1];\n\t\t\t\tattribute.t = EVENT;\n\t\t\t\tattribute.f = processDirective( attribute.f, parser, EVENT );\n\n\t\t\t\tif ( reservedEventNames.test( attribute.f.n || attribute.f ) ) {\n\t\t\t\t\tparser.pos -= ( attribute.f.n || attribute.f ).length;\n\t\t\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif ( parser.sanitizeEventAttributes && onPattern.test( attribute.n ) ) {\n\t\t\t\t\treturn { exclude: true };\n\t\t\t\t} else {\n\t\t\t\t\tattribute.f = attribute.f || ( attribute.f === '' ? '' : 0 );\n\t\t\t\t\tattribute.t = ATTRIBUTE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn attribute;\n\t}\n\n\tvar delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\n\tfunction readMustache ( parser ) {\n\t\tvar mustache, i;\n\n\t\t// If we're inside a <script> or <style> tag, and we're not\n\t\t// interpolating, bug out\n\t\tif ( parser.interpolate[ parser.inside ] === false ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor ( i = 0; i < parser.tags.length; i += 1 ) {\n\t\t\tif ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {\n\t\t\t\treturn mustache;\n\t\t\t}\n\t\t}\n\n\t\tif ( parser.inTag && !parser.inAttribute ) {\n\t\t\tmustache = readAttributeOrDirective( parser );\n\t\t\tif ( mustache ) {\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\treturn mustache;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction readMustacheOfType ( parser, tag ) {\n\t\tvar start, mustache, reader, i;\n\n\t\tstart = parser.pos;\n\n\t\tif ( parser.matchString( '\\\\' + tag.open ) ) {\n\t\t\tif ( start === 0 || parser.str[ start - 1 ] !== '\\\\' ) {\n\t\t\t\treturn tag.open;\n\t\t\t}\n\t\t} else if ( !parser.matchString( tag.open ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// delimiter change?\n\t\tif ( mustache = readDelimiterChange( parser ) ) {\n\t\t\t// find closing delimiter or abort...\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// ...then make the switch\n\t\t\ttag.open = mustache[0];\n\t\t\ttag.close = mustache[1];\n\t\t\tparser.sortMustacheTags();\n\n\t\t\treturn delimiterChangeToken;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\t// illegal section closer\n\t\tif ( parser.matchString( '/' ) ) {\n\t\t\tparser.pos -= 1;\n\t\t\tvar rewind = parser.pos;\n\t\t\tif ( !readNumberLiteral( parser ) ) {\n\t\t\t\tparser.pos = rewind - ( tag.close.length );\n\t\t\t\tif ( parser.inAttribute ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparser.pos = rewind;\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = 0; i < tag.readers.length; i += 1 ) {\n\t\t\treader = tag.readers[i];\n\n\t\t\tif ( mustache = reader( parser, tag ) ) {\n\t\t\t\tif ( tag.isStatic ) {\n\t\t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n\t\t\t\t}\n\n\t\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\t\tmustache.p = parser.getLinePos( start );\n\t\t\t\t}\n\n\t\t\t\treturn mustache;\n\t\t\t}\n\t\t}\n\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tfunction refineExpression ( expression, mustache ) {\n\t\tvar referenceExpression;\n\n\t\tif ( expression ) {\n\t\t\twhile ( expression.t === BRACKETED && expression.x ) {\n\t\t\t\texpression = expression.x;\n\t\t\t}\n\n\t\t\tif ( expression.t === REFERENCE ) {\n\t\t\t\tmustache.r = expression.n;\n\t\t\t} else {\n\t\t\t\tif ( referenceExpression = getReferenceExpression( expression ) ) {\n\t\t\t\t\tmustache.rx = referenceExpression;\n\t\t\t\t} else {\n\t\t\t\t\tmustache.x = flattenExpression( expression );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mustache;\n\t\t}\n\t}\n\n\t// TODO refactor this! it's bewildering\n\tfunction getReferenceExpression ( expression ) {\n\t\tvar members = [], refinement;\n\n\t\twhile ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {\n\t\t\trefinement = expression.r;\n\n\t\t\tif ( refinement.x ) {\n\t\t\t\tif ( refinement.x.t === REFERENCE ) {\n\t\t\t\t\tmembers.unshift( refinement.x );\n\t\t\t\t} else {\n\t\t\t\t\tmembers.unshift( flattenExpression( refinement.x ) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmembers.unshift( refinement.n );\n\t\t\t}\n\n\t\t\texpression = expression.x;\n\t\t}\n\n\t\tif ( expression.t !== REFERENCE ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tr: expression.n,\n\t\t\tm: members\n\t\t};\n\t}\n\n\tfunction readTriple ( parser, tag ) {\n\t\tvar expression = readExpression( parser ), triple;\n\n\t\tif ( !expression ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t}\n\n\t\ttriple = { t: TRIPLE };\n\t\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n\t\treturn triple;\n\t}\n\n\tfunction readUnescaped ( parser, tag ) {\n\t\tvar expression, triple;\n\n\t\tif ( !parser.matchString( '&' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\texpression = readExpression( parser );\n\n\t\tif ( !expression ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t}\n\n\t\ttriple = { t: TRIPLE };\n\t\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n\t\treturn triple;\n\t}\n\n\tvar legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n\tvar asRE = /^as/i;\n\n\tfunction readAliases( parser ) {\n\t\tvar aliases = [], alias, start = parser.pos;\n\n\t\tparser.allowWhitespace();\n\n\t\talias = readAlias( parser );\n\n\t\tif ( alias ) {\n\t\t\talias.x = refineExpression( alias.x, {} );\n\t\t\taliases.push( alias );\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\twhile ( parser.matchString(',') ) {\n\t\t\t\talias = readAlias( parser );\n\n\t\t\t\tif ( !alias ) {\n\t\t\t\t\tparser.error( 'Expected another alias.' );\n\t\t\t\t}\n\n\t\t\t\talias.x = refineExpression( alias.x, {} );\n\t\t\t\taliases.push( alias );\n\n\t\t\t\tparser.allowWhitespace();\n\t\t\t}\n\n\t\t\treturn aliases;\n\t\t}\n\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tfunction readAlias( parser ) {\n\t\tvar expr, alias, start = parser.pos;\n\n\t\tparser.allowWhitespace();\n\n\t\texpr = readExpression( parser, [] );\n\n\t\tif ( !expr ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchPattern( asRE ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\talias = parser.matchPattern( legalAlias );\n\n\t\tif ( !alias ) {\n\t\t\tparser.error( 'Expected a legal alias name.' );\n\t\t}\n\n\t\treturn { n: alias, x: expr };\n\t}\n\n\tfunction readPartial ( parser, tag ) {\n\t\tif ( !parser.matchString( '>' ) ) return null;\n\n\t\tparser.allowWhitespace();\n\n\t\t// Partial names can include hyphens, so we can't use readExpression\n\t\t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n\t\t// `foo-bar` should be read as a single name, rather than 'subtract\n\t\t// bar from foo'\n\t\tparser.relaxedNames = parser.strictRefinement = true;\n\t\tvar expression = readExpression( parser );\n\t\tparser.relaxedNames = parser.strictRefinement = false;\n\n\t\tif ( !expression ) return null;\n\n\t\tvar partial = { t: PARTIAL };\n\t\trefineExpression( expression, partial ); // TODO...\n\n\t\tparser.allowWhitespace();\n\n\t\t// check for alias context e.g. `{{>foo bar as bat, bip as bop}}` then\n\t\t// turn it into `{{#with bar as bat, bip as bop}}{{>foo}}{{/with}}`\n\t\tvar aliases = readAliases( parser );\n\t\tif ( aliases ) {\n\t\t\tpartial = {\n\t\t\t\tt: ALIAS,\n\t\t\t\tz: aliases,\n\t\t\t\tf: [ partial ]\n\t\t\t};\n\t\t}\n\n\t\t// otherwise check for literal context e.g. `{{>foo bar}}` then\n\t\t// turn it into `{{#with bar}}{{>foo}}{{/with}}`\n\t\telse {\n\t\t\tvar context = readExpression( parser );\n\t\t\tif ( context) {\n\t\t\t\tpartial = {\n\t\t\t\t\tt: SECTION,\n\t\t\t\t\tn: SECTION_WITH,\n\t\t\t\t\tf: [ partial ]\n\t\t\t\t};\n\n\t\t\t\trefineExpression( context, partial );\n\t\t\t}\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t}\n\n\t\treturn partial;\n\t}\n\n\tfunction readComment ( parser, tag ) {\n\t\tvar index;\n\n\t\tif ( !parser.matchString( '!' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tindex = parser.remaining().indexOf( tag.close );\n\n\t\tif ( index !== -1 ) {\n\t\t\tparser.pos += index + tag.close.length;\n\t\t\treturn { t: COMMENT };\n\t\t}\n\t}\n\n\tfunction readExpressionOrReference ( parser, expectedFollowers ) {\n\t\tvar start, expression, i;\n\n\t\tstart = parser.pos;\n\t\texpression = readExpression( parser );\n\n\t\tif ( !expression ) {\n\t\t\t// valid reference but invalid expression e.g. `{{new}}`?\n\t\t\tvar ref = parser.matchPattern( /^(\\w+)/ );\n\t\t\tif ( ref ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: REFERENCE,\n\t\t\t\t\tn: ref\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tfor ( i = 0; i < expectedFollowers.length; i += 1 ) {\n\t\t\tif ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {\n\t\t\t\treturn expression;\n\t\t\t}\n\t\t}\n\n\t\tparser.pos = start;\n\t\treturn readReference( parser );\n\t}\n\n\tfunction readInterpolator ( parser, tag ) {\n\t\tvar start, expression, interpolator, err;\n\n\t\tstart = parser.pos;\n\n\t\t// TODO would be good for perf if we could do away with the try-catch\n\t\ttry {\n\t\t\texpression = readExpressionOrReference( parser, [ tag.close ]);\n\t\t} catch ( e ) {\n\t\t\terr = e;\n\t\t}\n\n\t\tif ( !expression ) {\n\t\t\tif ( parser.str.charAt( start ) === '!' ) {\n\t\t\t\t// special case - comment\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( err ) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"' after reference\") );\n\n\t\t\tif ( !expression ) {\n\t\t\t\t// special case - comment\n\t\t\t\tif ( parser.nextChar() === '!' ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tparser.error( (\"Expected expression or legal reference\") );\n\t\t\t}\n\t\t}\n\n\t\tinterpolator = { t: INTERPOLATOR };\n\t\trefineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious\n\n\t\treturn interpolator;\n\t}\n\n\tvar yieldPattern = /^yield\\s*/;\n\n\tfunction readYielder ( parser, tag ) {\n\t\tif ( !parser.matchPattern( yieldPattern ) ) return null;\n\n\t\tvar name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"expected legal partial name\") );\n\t\t}\n\n\t\tvar yielder = { t: YIELDER };\n\t\tif ( name ) yielder.n = name;\n\n\t\treturn yielder;\n\t}\n\n\tfunction readClosing ( parser, tag ) {\n\t\tvar start, remaining, index, closing;\n\n\t\tstart = parser.pos;\n\n\t\tif ( !parser.matchString( tag.open ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( '/' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tremaining = parser.remaining();\n\t\tindex = remaining.indexOf( tag.close );\n\n\t\tif ( index !== -1 ) {\n\t\t\tclosing = {\n\t\t\t\tt: CLOSING,\n\t\t\t\tr: remaining.substr( 0, index ).split( ' ' )[0]\n\t\t\t};\n\n\t\t\tparser.pos += index;\n\n\t\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t\t}\n\n\t\t\treturn closing;\n\t\t}\n\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tvar elsePattern = /^\\s*else\\s*/;\n\n\tfunction readElse ( parser, tag ) {\n\t\tvar start = parser.pos;\n\n\t\tif ( !parser.matchString( tag.open ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !parser.matchPattern( elsePattern ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t}\n\n\t\treturn {\n\t\t\tt: ELSE\n\t\t};\n\t}\n\n\tvar elsePattern$1 = /^\\s*elseif\\s+/;\n\n\tfunction readElseIf ( parser, tag ) {\n\t\tvar start = parser.pos;\n\n\t\tif ( !parser.matchString( tag.open ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !parser.matchPattern( elsePattern$1 ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tvar expression = readExpression( parser );\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t}\n\n\t\treturn {\n\t\t\tt: ELSEIF,\n\t\t\tx: expression\n\t\t};\n\t}\n\n\tvar handlebarsBlockCodes = {\n\t\t'each':    SECTION_EACH,\n\t\t'if':      SECTION_IF,\n\t\t'with':    SECTION_IF_WITH,\n\t\t'unless':  SECTION_UNLESS\n\t};\n\n\tvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n\tvar keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n\tvar handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' );\n\tfunction readSection ( parser, tag ) {\n\t\tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose, aliasOnly = false;\n\n\t\tstart = parser.pos;\n\n\t\tif ( parser.matchString( '^' ) ) {\n\t\t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n\t\t} else if ( parser.matchString( '#' ) ) {\n\t\t\tsection = { t: SECTION, f: [] };\n\n\t\t\tif ( parser.matchString( 'partial' ) ) {\n\t\t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n\t\t\t\tparser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );\n\t\t\t}\n\n\t\t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t\t\t\texpectedClose = block;\n\t\t\t\tsection.n = handlebarsBlockCodes[ block ];\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( block === 'with' ) {\n\t\t\tvar aliases = readAliases( parser );\n\t\t\tif ( aliases ) {\n\t\t\t\taliasOnly = true;\n\t\t\t\tsection.z = aliases;\n\t\t\t\tsection.t = ALIAS;\n\t\t\t}\n\t\t} else if ( block === 'each' ) {\n\t\t\tvar alias = readAlias( parser );\n\t\t\tif ( alias ) {\n\t\t\t\tsection.z = [ { n: alias.n, x: { r: '.' } } ];\n\t\t\t\texpression = alias.x;\n\t\t\t}\n\t\t}\n\n\t\tif ( !aliasOnly ) {\n\t\t\tif ( !expression ) expression = readExpression( parser );\n\n\t\t\tif ( !expression ) {\n\t\t\t\tparser.error( 'Expected expression' );\n\t\t\t}\n\n\t\t\t// optional index and key references\n\t\t\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t\t\t\tvar extra;\n\n\t\t\t\tif ( extra = parser.matchPattern( keyIndexRefPattern ) ) {\n\t\t\t\t\tsection.i = i + ',' + extra;\n\t\t\t\t} else {\n\t\t\t\t\tsection.i = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t\t}\n\n\t\tparser.sectionDepth += 1;\n\t\tchildren = section.f;\n\n\t\tconditions = [];\n\n\t\tvar pos;\n\t\tdo {\n\t\t\tpos = parser.pos;\n\t\t\tif ( child = readClosing( parser, tag ) ) {\n\t\t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\tparser.error( (\"Expected \" + (tag.open) + \"/\" + expectedClose + \"\" + (tag.close)) );\n\t\t\t\t}\n\n\t\t\t\tparser.sectionDepth -= 1;\n\t\t\t\tclosed = true;\n\t\t\t}\n\n\t\t\telse if ( !aliasOnly && ( child = readElseIf( parser, tag ) ) ) {\n\t\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t\t}\n\n\t\t\t\tif ( hasElse ) {\n\t\t\t\t\tparser.error( 'illegal {{elseif...}} after {{else}}' );\n\t\t\t\t}\n\n\t\t\t\tif ( !unlessBlock ) {\n\t\t\t\t\tunlessBlock = [];\n\t\t\t\t}\n\n\t\t\t\tvar mustache = {\n\t\t\t\t\tt: SECTION,\n\t\t\t\t\tn: SECTION_IF,\n\t\t\t\t\tf: children = []\n\t\t\t\t};\n\t\t\t\trefineExpression( child.x, mustache );\n\n\t\t\t\tunlessBlock.push( mustache );\n\t\t\t}\n\n\t\t\telse if ( !aliasOnly && ( child = readElse( parser, tag ) ) ) {\n\t\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t\t}\n\n\t\t\t\tif ( hasElse ) {\n\t\t\t\t\tparser.error( 'there can only be one {{else}} block, at the end of a section' );\n\t\t\t\t}\n\n\t\t\t\thasElse = true;\n\n\t\t\t\t// use an unless block if there's no elseif\n\t\t\t\tif ( !unlessBlock ) {\n\t\t\t\t\tunlessBlock = [];\n\t\t\t\t}\n\n\t\t\t\tunlessBlock.push({\n\t\t\t\t\tt: SECTION,\n\t\t\t\t\tn: SECTION_UNLESS,\n\t\t\t\t\tf: children = []\n\t\t\t\t});\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tchild = parser.read( READERS );\n\n\t\t\t\tif ( !child ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchildren.push( child );\n\t\t\t}\n\t\t} while ( !closed );\n\n\t\tif ( unlessBlock ) {\n\t\t\tsection.l = unlessBlock;\n\t\t}\n\n\t\tif ( !aliasOnly ) {\n\t\t\trefineExpression( expression, section );\n\t\t}\n\n\t\t// TODO if a section is empty it should be discarded. Don't do\n\t\t// that here though - we need to clean everything up first, as\n\t\t// it may contain removeable whitespace. As a temporary measure,\n\t\t// to pass the existing tests, remove empty `f` arrays\n\t\tif ( !section.f.length ) {\n\t\t\tdelete section.f;\n\t\t}\n\n\t\treturn section;\n\t}\n\n\tvar OPEN_COMMENT = '<!--';\n\tvar CLOSE_COMMENT = '-->';\n\tfunction readHtmlComment ( parser ) {\n\t\tvar start, content, remaining, endIndex, comment;\n\n\t\tstart = parser.pos;\n\n\t\tif ( parser.textOnlyMode || !parser.matchString( OPEN_COMMENT ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tremaining = parser.remaining();\n\t\tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\n\t\tif ( endIndex === -1 ) {\n\t\t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t\t}\n\n\t\tcontent = remaining.substr( 0, endIndex );\n\t\tparser.pos += endIndex + 3;\n\n\t\tcomment = {\n\t\t\tt: COMMENT,\n\t\t\tc: content\n\t\t};\n\n\t\tif ( parser.includeLinePositions ) {\n\t\t\tcomment.p = parser.getLinePos( start );\n\t\t}\n\n\t\treturn comment;\n\t}\n\n\tvar leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\n\tvar trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n\tfunction stripStandalones ( items ) {\n\t\tvar i, current, backOne, backTwo, lastSectionItem;\n\n\t\tfor ( i=1; i<items.length; i+=1 ) {\n\t\t\tcurrent = items[i];\n\t\t\tbackOne = items[i-1];\n\t\t\tbackTwo = items[i-2];\n\n\t\t\t// if we're at the end of a [text][comment][text] sequence...\n\t\t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\n\t\t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t\t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\n\t\t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t\t\t\t\titems[i-2] = backTwo.replace( trailingLinebreak, '\\n' );\n\n\t\t\t\t\t// and the leading line break of the second text token\n\t\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t\t\t// its first item is a linebreak...\n\t\t\tif ( isSection( current ) && isString( backOne ) ) {\n\t\t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {\n\t\t\t\t\titems[i-1] = backOne.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\tcurrent.f[0] = current.f[0].replace( leadingLinebreak, '' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if the last item was a section, and it is followed by a linebreak, and\n\t\t\t// its last item is a linebreak...\n\t\t\tif ( isString( current ) && isSection( backOne ) ) {\n\t\t\t\tlastSectionItem = lastItem( backOne.f );\n\n\t\t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tfunction isString ( item ) {\n\t\treturn typeof item === 'string';\n\t}\n\n\tfunction isComment ( item ) {\n\t\treturn item.t === COMMENT || item.t === DELIMCHANGE;\n\t}\n\n\tfunction isSection ( item ) {\n\t\treturn ( item.t === SECTION || item.t === INVERTED ) && item.f;\n\t}\n\n\tfunction trimWhitespace ( items, leadingPattern, trailingPattern ) {\n\t\tvar item;\n\n\t\tif ( leadingPattern ) {\n\t\t\titem = items[0];\n\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\titem = item.replace( leadingPattern, '' );\n\n\t\t\t\tif ( !item ) {\n\t\t\t\t\titems.shift();\n\t\t\t\t} else {\n\t\t\t\t\titems[0] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( trailingPattern ) {\n\t\t\titem = lastItem( items );\n\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\titem = item.replace( trailingPattern, '' );\n\n\t\t\t\tif ( !item ) {\n\t\t\t\t\titems.pop();\n\t\t\t\t} else {\n\t\t\t\t\titems[ items.length - 1 ] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n\tvar preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n\tvar leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\n\tvar trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\tvar leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n\tvar trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n\n\tfunction cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {\n\t\tif ( typeof items === 'string' ) return;\n\n\t\tvar i,\n\t\t\titem,\n\t\t\tpreviousItem,\n\t\t\tnextItem,\n\t\t\tpreserveWhitespaceInsideFragment,\n\t\t\tremoveLeadingWhitespaceInsideFragment,\n\t\t\tremoveTrailingWhitespaceInsideFragment,\n\t\t\tkey;\n\n\t\t// First pass - remove standalones and comments etc\n\t\tstripStandalones( items );\n\n\t\ti = items.length;\n\t\twhile ( i-- ) {\n\t\t\titem = items[i];\n\n\t\t\t// Remove delimiter changes, unsafe elements etc\n\t\t\tif ( item.exclude ) {\n\t\t\t\titems.splice( i, 1 );\n\t\t\t}\n\n\t\t\t// Remove comments, unless we want to keep them\n\t\t\telse if ( stripComments && item.t === COMMENT ) {\n\t\t\t\titems.splice( i, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// If necessary, remove leading and trailing whitespace\n\t\ttrimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );\n\n\t\ti = items.length;\n\t\twhile ( i-- ) {\n\t\t\titem = items[i];\n\n\t\t\t// Recurse\n\t\t\tif ( item.f ) {\n\t\t\t\tvar isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );\n\t\t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n\t\t\t\tif ( !preserveWhitespace && isPreserveWhitespaceElement ) {\n\t\t\t\t\ttrimWhitespace( item.f, leadingNewLine, trailingNewLine );\n\t\t\t\t}\n\n\t\t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t\t\t\t\tpreviousItem = items[ i - 1 ];\n\t\t\t\t\tnextItem = items[ i + 1 ];\n\n\t\t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t\t\t\t\t// remove leading whitespace inside the fragment\n\t\t\t\t\tif ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {\n\t\t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// and vice versa\n\t\t\t\t\tif ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace$1.test( nextItem ) ) ) {\n\t\t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\n\t\t\t\t// clean up name templates (events, decorators, etc)\n\t\t\t\tif ( isArray( item.f.n ) ) {\n\t\t\t\t\tcleanup( item.f.n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n\t\t\t\t}\n\n\t\t\t\t// clean up arg templates (events, decorators, etc)\n\t\t\t\tif ( isArray( item.f.d ) ) {\n\t\t\t\t\tcleanup( item.f.d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Split if-else blocks into two (an if, and an unless)\n\t\t\tif ( item.l ) {\n\t\t\t\tcleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\n\t\t\t\titem.l.forEach( function ( s ) { return s.l = 1; } );\n\t\t\t\titem.l.unshift( i + 1, 0 );\n\t\t\t\titems.splice.apply( items, item.l );\n\t\t\t\tdelete item.l; // TODO would be nice if there was a way around this\n\t\t\t}\n\n\t\t\t// Clean up element attributes\n\t\t\tif ( item.a ) {\n\t\t\t\tfor ( key in item.a ) {\n\t\t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t\t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Clean up conditional attributes\n\t\t\tif ( item.m ) {\n\t\t\t\tcleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\tif ( item.m.length < 1 ) delete item.m;\n\t\t\t}\n\t\t}\n\n\t\t// final pass - fuse text nodes together\n\t\ti = items.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( typeof items[i] === 'string' ) {\n\t\t\t\tif ( typeof items[i+1] === 'string' ) {\n\t\t\t\t\titems[i] = items[i] + items[i+1];\n\t\t\t\t\titems.splice( i + 1, 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( !preserveWhitespace ) {\n\t\t\t\t\titems[i] = items[i].replace( contiguousWhitespace, ' ' );\n\t\t\t\t}\n\n\t\t\t\tif ( items[i] === '' ) {\n\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\n\tfunction readClosingTag ( parser ) {\n\t\tvar start, tag;\n\n\t\tstart = parser.pos;\n\n\t\t// are we looking at a closing tag?\n\t\tif ( !parser.matchString( '</' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t\t\tif ( parser.inside && tag !== parser.inside ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tt: CLOSING_TAG,\n\t\t\t\te: tag\n\t\t\t};\n\t\t}\n\n\t\t// We have an illegal closing tag, report it\n\t\tparser.pos -= 2;\n\t\tparser.error( 'Illegal closing tag' );\n\t}\n\n\tvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\n\tvar validTagNameFollower = /^[\\s\\n\\/>]/;\n\tvar exclude = { exclude: true };\n\tvar disallowedContents;\n\t// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\tdisallowedContents = {\n\t\tli: [ 'li' ],\n\t\tdt: [ 'dt', 'dd' ],\n\t\tdd: [ 'dt', 'dd' ],\n\t\tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\t\trt: [ 'rt', 'rp' ],\n\t\trp: [ 'rt', 'rp' ],\n\t\toptgroup: [ 'optgroup' ],\n\t\toption: [ 'option', 'optgroup' ],\n\t\tthead: [ 'tbody', 'tfoot' ],\n\t\ttbody: [ 'tbody', 'tfoot' ],\n\t\ttfoot: [ 'tbody' ],\n\t\ttr: [ 'tr', 'tbody' ],\n\t\ttd: [ 'td', 'th', 'tr' ],\n\t\tth: [ 'td', 'th', 'tr' ]\n\t};\n\n\tfunction readElement ( parser ) {\n\t\tvar start,\n\t\t\telement,\n\t\t\tattribute,\n\t\t\tselfClosing,\n\t\t\tchildren,\n\t\t\tpartials,\n\t\t\thasPartials,\n\t\t\tchild,\n\t\t\tclosed,\n\t\t\tpos,\n\t\t\tremaining,\n\t\t\tclosingTag;\n\n\t\tstart = parser.pos;\n\n\t\tif ( parser.inside || parser.inAttribute || parser.textOnlyMode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !parser.matchString( '<' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// if this is a closing tag, abort straight away\n\t\tif ( parser.nextChar() === '/' ) {\n\t\t\treturn null;\n\t\t}\n\n\t\telement = {};\n\t\tif ( parser.includeLinePositions ) {\n\t\t\telement.p = parser.getLinePos( start );\n\t\t}\n\n\t\tif ( parser.matchString( '!' ) ) {\n\t\t\telement.t = DOCTYPE;\n\t\t\tif ( !parser.matchPattern( /^doctype/i ) ) {\n\t\t\t\tparser.error( 'Expected DOCTYPE declaration' );\n\t\t\t}\n\n\t\t\telement.a = parser.matchPattern( /^(.+?)>/ );\n\t\t\treturn element;\n\t\t}\n\n\t\telement.t = ELEMENT;\n\n\t\t// element name\n\t\telement.e = parser.matchPattern( tagNamePattern );\n\t\tif ( !element.e ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// next character must be whitespace, closing solidus or '>'\n\t\tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t\t\tparser.error( 'Illegal tag name' );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tparser.inTag = true;\n\n\t\t// directives and attributes\n\t\twhile ( attribute = readMustache( parser ) ) {\n\t\t\tif ( attribute !== false ) {\n\t\t\t\tif ( !element.m ) element.m = [];\n\t\t\t\telement.m.push( attribute );\n\t\t\t}\n\n\t\t\tparser.allowWhitespace();\n\t\t}\n\n\t\tparser.inTag = false;\n\n\t\t// allow whitespace before closing solidus\n\t\tparser.allowWhitespace();\n\n\t\t// self-closing solidus?\n\t\tif ( parser.matchString( '/' ) ) {\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\t// closing angle bracket\n\t\tif ( !parser.matchString( '>' ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar lowerCaseName = element.e.toLowerCase();\n\t\tvar preserveWhitespace = parser.preserveWhitespace;\n\n\t\tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t\t\tparser.elementStack.push( lowerCaseName );\n\n\t\t\t// Special case - if we open a script element, further tags should\n\t\t\t// be ignored unless they're a closing script element\n\t\t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' || lowerCaseName === 'textarea' ) {\n\t\t\t\tparser.inside = lowerCaseName;\n\t\t\t}\n\n\t\t\tchildren = [];\n\t\t\tpartials = create( null );\n\n\t\t\tdo {\n\t\t\t\tpos = parser.pos;\n\t\t\t\tremaining = parser.remaining();\n\n\t\t\t\tif ( !remaining ) {\n\t\t\t\t\tparser.error( (\"Missing end \" + (parser.elementStack.length > 1 ? 'tags' : 'tag') + \" (\" + (parser.elementStack.reverse().map( function ( x ) { return (\"</\" + x + \">\"); } ).join( '' )) + \")\") );\n\t\t\t\t}\n\n\t\t\t\t// if for example we're in an <li> element, and we see another\n\t\t\t\t// <li> tag, close the first so they become siblings\n\t\t\t\tif ( !canContain( lowerCaseName, remaining ) ) {\n\t\t\t\t\tclosed = true;\n\t\t\t\t}\n\n\t\t\t\t// closing tag\n\t\t\t\telse if ( closingTag = readClosingTag( parser ) ) {\n\t\t\t\t\tclosed = true;\n\n\t\t\t\t\tvar closingTagName = closingTag.e.toLowerCase();\n\n\t\t\t\t\t// if this *isn't* the closing tag for the current element...\n\t\t\t\t\tif ( closingTagName !== lowerCaseName ) {\n\t\t\t\t\t\t// rewind parser\n\t\t\t\t\t\tparser.pos = pos;\n\n\t\t\t\t\t\t// if it doesn't close a parent tag, error\n\t\t\t\t\t\tif ( !~parser.elementStack.indexOf( closingTagName ) ) {\n\t\t\t\t\t\t\tvar errorMessage = 'Unexpected closing tag';\n\n\t\t\t\t\t\t\t// add additional help for void elements, since component names\n\t\t\t\t\t\t\t// might clash with them\n\t\t\t\t\t\t\tif ( voidElementNames.test( closingTagName ) ) {\n\t\t\t\t\t\t\t\terrorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tparser.error( errorMessage );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// implicit close by closing section tag. TODO clean this up\n\t\t\t\telse if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {\n\t\t\t\t\tclosed = true;\n\t\t\t\t\tparser.pos = pos;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tif ( child = parser.read( PARTIAL_READERS ) ) {\n\t\t\t\t\t\tif ( partials[ child.n ] ) {\n\t\t\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\t\t\tparser.error( 'Duplicate partial definition' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\n\t\t\t\t\t\tpartials[ child.n ] = child.f;\n\t\t\t\t\t\thasPartials = true;\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ( child = parser.read( READERS ) ) {\n\t\t\t\t\t\t\tchildren.push( child );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while ( !closed );\n\n\t\t\tif ( children.length ) {\n\t\t\t\telement.f = children;\n\t\t\t}\n\n\t\t\tif ( hasPartials ) {\n\t\t\t\telement.p = partials;\n\t\t\t}\n\n\t\t\tparser.elementStack.pop();\n\t\t}\n\n\t\tparser.inside = null;\n\n\t\tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t\t\treturn exclude;\n\t\t}\n\n\t\treturn element;\n\t}\n\n\tfunction canContain ( name, remaining ) {\n\t\tvar match, disallowed;\n\n\t\tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\t\tdisallowed = disallowedContents[ name ];\n\n\t\tif ( !match || !disallowed ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !~disallowed.indexOf( match[1].toLowerCase() );\n\t}\n\n\tfunction readText ( parser ) {\n\t\tvar index, remaining, disallowed, barrier;\n\n\t\tremaining = parser.remaining();\n\n\t\tif ( parser.textOnlyMode ) {\n\t\t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n\t\t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\n\t\t\tindex = getLowestIndex( remaining, disallowed );\n\t\t} else {\n\t\t\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\n\t\t\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t\t\t\tindex = remaining.indexOf( barrier );\n\t\t\t} else {\n\t\t\t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n\t\t\t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\n\t\t\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t\t\t\tif ( parser.inAttribute === true ) {\n\t\t\t\t\t// we're inside an unquoted attribute value\n\t\t\t\t\tdisallowed.push( (\"\\\"\"), (\"'\"), (\"=\"), (\"<\"), (\">\"), '`' );\n\t\t\t\t} else if ( parser.inAttribute ) {\n\t\t\t\t\t// quoted attribute value\n\t\t\t\t\tdisallowed.push( parser.inAttribute );\n\t\t\t\t} else {\n\t\t\t\t\tdisallowed.push( barrier );\n\t\t\t\t}\n\n\t\t\t\tindex = getLowestIndex( remaining, disallowed );\n\t\t\t}\n\t\t}\n\n\t\tif ( !index ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( index === -1 ) {\n\t\t\tindex = remaining.length;\n\t\t}\n\n\t\tparser.pos += index;\n\n\t\tif ( ( parser.inside && parser.inside !== 'textarea' ) || parser.textOnlyMode ) {\n\t\t\treturn remaining.substr( 0, index );\n\t\t} else {\n\t\t\treturn decodeCharacterReferences( remaining.substr( 0, index ) );\n\t\t}\n\t}\n\n\tvar startPattern = /^<!--\\s*/;\n\tvar namePattern$1 = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/;\n\tvar finishPattern = /\\s*-->/;\n\n\tfunction readPartialDefinitionComment ( parser ) {\n\t\tvar start = parser.pos;\n\t\tvar open = parser.standardDelimiters[0];\n\t\tvar close = parser.standardDelimiters[1];\n\n\t\tif ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tvar name = parser.matchPattern( namePattern$1 );\n\n\t\twarnOnceIfDebug( (\"Inline partial comments are deprecated.\\nUse this...\\n  {{#partial \" + name + \"}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>\" + name + \"}} --> ... <!-- {{/\" + name + \"}} -->'\") );\n\n\t\t// make sure the rest of the comment is in the correct place\n\t\tif ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tvar content = [];\n\t\tvar closed;\n\n\t\tvar endPattern = new RegExp('^<!--\\\\s*' + escapeRegExp( open ) + '\\\\s*\\\\/\\\\s*' + name + '\\\\s*' + escapeRegExp( close ) + '\\\\s*-->');\n\n\t\tdo {\n\t\t\tif ( parser.matchPattern( endPattern ) ) {\n\t\t\t\tclosed = true;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tvar child = parser.read( READERS );\n\t\t\t\tif ( !child ) {\n\t\t\t\t\tparser.error( (\"expected closing comment ('<!-- \" + open + \"/\" + name + \"\" + close + \" -->')\") );\n\t\t\t\t}\n\n\t\t\t\tcontent.push( child );\n\t\t\t}\n\t\t} while ( !closed );\n\n\t\treturn {\n\t\t\tt: INLINE_PARTIAL,\n\t\t\tf: content,\n\t\t\tn: name\n\t\t};\n\t}\n\n\tvar partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\n\tfunction readPartialDefinitionSection ( parser ) {\n\t\tvar start, name, content, child, closed;\n\n\t\tstart = parser.pos;\n\n\t\tvar delimiters = parser.standardDelimiters;\n\n\t\tif ( !parser.matchString( delimiters[0] ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/ );\n\n\t\tif ( !name ) {\n\t\t\tparser.error( 'expected legal partial name' );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\t\tif ( !parser.matchString( delimiters[1] ) ) {\n\t\t\tparser.error( (\"Expected closing delimiter '\" + (delimiters[1]) + \"'\") );\n\t\t}\n\n\t\tcontent = [];\n\n\t\tdo {\n\t\t\t// TODO clean this up\n\t\t\tif ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] }) ) {\n\t\t\t\tif ( !child.r === 'partial' ) {\n\t\t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n\t\t\t\t}\n\n\t\t\t\tclosed = true;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tchild = parser.read( READERS );\n\n\t\t\t\tif ( !child ) {\n\t\t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n\t\t\t\t}\n\n\t\t\t\tcontent.push( child );\n\t\t\t}\n\t\t} while ( !closed );\n\n\t\treturn {\n\t\t\tt: INLINE_PARTIAL,\n\t\t\tn: name,\n\t\t\tf: content\n\t\t};\n\t}\n\n\tfunction readTemplate ( parser ) {\n\t\tvar fragment = [];\n\t\tvar partials = create( null );\n\t\tvar hasPartials = false;\n\n\t\tvar preserveWhitespace = parser.preserveWhitespace;\n\n\t\twhile ( parser.pos < parser.str.length ) {\n\t\t\tvar pos = parser.pos, item, partial;\n\n\t\t\tif ( partial = parser.read( PARTIAL_READERS ) ) {\n\t\t\t\tif ( partials[ partial.n ] ) {\n\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\tparser.error( 'Duplicated partial definition' );\n\t\t\t\t}\n\n\t\t\t\tcleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\n\t\t\t\tpartials[ partial.n ] = partial.f;\n\t\t\t\thasPartials = true;\n\t\t\t} else if ( item = parser.read( READERS ) ) {\n\t\t\t\tfragment.push( item );\n\t\t\t} else  {\n\t\t\t\tparser.error( 'Unexpected template content' );\n\t\t\t}\n\t\t}\n\n\t\tvar result = {\n\t\t\tv: TEMPLATE_VERSION,\n\t\t\tt: fragment\n\t\t};\n\n\t\tif ( hasPartials ) {\n\t\t\tresult.p = partials;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction insertExpressions ( obj, expr ) {\n\n\t\tObject.keys( obj ).forEach( function ( key ) {\n\t\t\tif  ( isExpression( key, obj ) ) return addTo( obj, expr );\n\n\t\t\tvar ref = obj[ key ];\n\t\t\tif ( hasChildren( ref ) ) insertExpressions( ref, expr );\n\t \t});\n\t}\n\n\tfunction isExpression( key, obj ) {\n\t\treturn key === 's' && isArray( obj.r );\n\t}\n\n\tfunction addTo( obj, expr ) {\n\t\tvar s = obj.s, r = obj.r;\n\t\tif ( !expr[ s ] ) expr[ s ] = fromExpression( s, r.length );\n\t}\n\n\tfunction hasChildren( ref ) {\n\t\treturn isArray( ref ) || isObject( ref );\n\t}\n\n\t// See https://github.com/ractivejs/template-spec for information\n\t// about the Ractive template specification\n\n\tvar STANDARD_READERS = [ readPartial, readUnescaped, readSection, readYielder, readInterpolator, readComment ];\n\tvar TRIPLE_READERS = [ readTriple ];\n\tvar STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?\n\n\tvar StandardParser;\n\n\tfunction parse ( template, options ) {\n\t\treturn new StandardParser( template, options || {} ).result;\n\t}\n\n\tparse.computedStrings = function( computed ) {\n\t\tif ( !computed ) return [];\n\n\t\tObject.keys( computed ).forEach( function ( key ) {\n\t\t\tvar value = computed[ key ];\n\t\t\tif ( typeof value === 'string' ) {\n\t\t\t\tcomputed[ key ] = fromComputationString( value );\n\t\t\t}\n\t\t});\n\t};\n\n\n\tvar READERS = [ readMustache, readHtmlComment, readElement, readText ];\n\tvar PARTIAL_READERS = [ readPartialDefinitionComment, readPartialDefinitionSection ];\n\n\tStandardParser = Parser$1.extend({\n\t\tinit: function ( str, options ) {\n\t\t\tvar tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],\n\t\t\t\tstaticDelimiters = options.staticDelimiters || [ '[[', ']]' ],\n\t\t\t\tstaticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];\n\n\t\t\tthis.standardDelimiters = options.delimiters || [ '{{', '}}' ];\n\n\t\t\tthis.tags = [\n\t\t\t\t{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },\n\t\t\t\t{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },\n\t\t\t\t{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },\n\t\t\t\t{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }\n\t\t\t];\n\n\t\t\tthis.contextLines = options.contextLines || 0;\n\n\t\t\tthis.sortMustacheTags();\n\n\t\t\tthis.sectionDepth = 0;\n\t\t\tthis.elementStack = [];\n\n\t\t\tthis.interpolate = {\n\t\t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t\t\t\tstyle: !options.interpolate || options.interpolate.style !== false,\n\t\t\t\ttextarea: true\n\t\t\t};\n\n\t\t\tif ( options.sanitize === true ) {\n\t\t\t\toptions.sanitize = {\n\t\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t\t\t\t\teventAttributes: true\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.stripComments = options.stripComments !== false;\n\t\t\tthis.preserveWhitespace = options.preserveWhitespace;\n\t\t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t\t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t\t\tthis.includeLinePositions = options.includeLinePositions;\n\t\t\tthis.textOnlyMode = options.textOnlyMode;\n\t\t\tthis.csp = options.csp;\n\t\t},\n\n\t\tpostProcess: function ( result ) {\n\t\t\t// special case - empty string\n\t\t\tif ( !result.length ) {\n\t\t\t\treturn { t: [], v: TEMPLATE_VERSION };\n\t\t\t}\n\n\t\t\tif ( this.sectionDepth > 0 ) {\n\t\t\t\tthis.error( 'A section was left open' );\n\t\t\t}\n\n\t\t\tcleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );\n\n\t\t\tif ( this.csp !== false ) {\n\t\t\t\tvar expr = {};\n\t\t\t\tinsertExpressions( result[0].t, expr );\n\t\t\t\tif ( Object.keys( expr ).length ) result[0].e = expr;\n\t\t\t}\n\n\t\t\treturn result[0];\n\t\t},\n\n\t\tconverters: [\n\t\t\treadTemplate\n\t\t],\n\n\t\tsortMustacheTags: function () {\n\t\t\t// Sort in order of descending opening delimiter length (longer first),\n\t\t\t// to protect against opening delimiters being substrings of each other\n\t\t\tthis.tags.sort( function ( a, b ) {\n\t\t\t\treturn b.open.length - a.open.length;\n\t\t\t});\n\t\t}\n\t});\n\n\tvar parseOptions = [\n\t\t'delimiters',\n\t\t'tripleDelimiters',\n\t\t'staticDelimiters',\n\t\t'staticTripleDelimiters',\n\t\t'csp',\n\t\t'interpolate',\n\t\t'preserveWhitespace',\n\t\t'sanitize',\n\t\t'stripComments',\n\t\t'contextLines'\n\t];\n\n\tvar TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\n\n\tvar COMPUTATION_INSTRUCTIONS = \"Either use:\\n\\n\\tRactive.parse.computedStrings( component.computed )\\n\\nat build time to pre-convert the strings to functions, or use functions instead of strings in computed properties.\";\n\n\n\tfunction throwNoParse ( method, error, instructions ) {\n\t\tif ( !method ) {\n\t\t\tfatal( (\"Missing Ractive.parse - cannot parse \" + error + \". \" + instructions) );\n\t\t}\n\t}\n\n\tfunction createFunction ( body, length ) {\n\t\tthrowNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );\n\t\treturn fromExpression( body, length );\n\t}\n\n\tfunction createFunctionFromString ( str, bindTo ) {\n\t\tthrowNoParse( fromComputationString, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS );\n\t\treturn fromComputationString( str, bindTo );\n\t}\n\n\tvar parser = {\n\n\t\tfromId: function ( id, options ) {\n\t\t\tif ( !doc ) {\n\t\t\t\tif ( options && options.noThrow ) { return; }\n\t\t\t\tthrow new Error( (\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\") );\n\t\t\t}\n\n\t\t\tif ( id ) id = id.replace( /^#/, '' );\n\n\t\t\tvar template;\n\n\t\t\tif ( !( template = doc.getElementById( id ) )) {\n\t\t\t\tif ( options && options.noThrow ) { return; }\n\t\t\t\tthrow new Error( (\"Could not find template element with id #\" + id) );\n\t\t\t}\n\n\t\t\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t\t\t\tif ( options && options.noThrow ) { return; }\n\t\t\t\tthrow new Error( (\"Template element with id #\" + id + \", must be a <script> element\") );\n\t\t\t}\n\n\t\t\treturn ( 'textContent' in template ? template.textContent : template.innerHTML );\n\n\t\t},\n\n\t\tisParsed: function ( template) {\n\t\t\treturn !( typeof template === 'string' );\n\t\t},\n\n\t\tgetParseOptions: function ( ractive ) {\n\t\t\t// Could be Ractive or a Component\n\t\t\tif ( ractive.defaults ) { ractive = ractive.defaults; }\n\n\t\t\treturn parseOptions.reduce( function ( val, key ) {\n\t\t\t\tval[ key ] = ractive[ key ];\n\t\t\t\treturn val;\n\t\t\t}, {});\n\t\t},\n\n\t\tparse: function ( template, options ) {\n\t\t\tthrowNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );\n\t\t\tvar parsed = parse( template, options );\n\t\t\taddFunctions( parsed );\n\t\t\treturn parsed;\n\t\t},\n\n\t\tparseFor: function( template, ractive ) {\n\t\t\treturn this.parse( template, this.getParseOptions( ractive ) );\n\t\t}\n\t};\n\n\tvar templateConfigurator = {\n\t\tname: 'template',\n\n\t\textend: function ( Parent, proto, options ) {\n\t\t\t// only assign if exists\n\t\t\tif ( 'template' in options ) {\n\t\t\t\tvar template = options.template;\n\n\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\tproto.template = template;\n\t\t\t\t} else {\n\t\t\t\t\tproto.template = parseTemplate( template, proto );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tinit: function ( Parent, ractive, options ) {\n\t\t\t// TODO because of prototypal inheritance, we might just be able to use\n\t\t\t// ractive.template, and not bother passing through the Parent object.\n\t\t\t// At present that breaks the test mocks' expectations\n\t\t\tvar template = 'template' in options ? options.template : Parent.prototype.template;\n\t\t\ttemplate = template || { v: TEMPLATE_VERSION, t: [] };\n\n\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\tvar fn = template;\n\t\t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\n\t\t\t\tractive._config.template = {\n\t\t\t\t\tfn: fn,\n\t\t\t\t\tresult: template\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttemplate = parseTemplate( template, ractive );\n\n\t\t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t\t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t\t\t// it's unnecessary, because the developer never needs to access\n\t\t\t// ractive.template\n\t\t\tractive.template = template.t;\n\n\t\t\tif ( template.p ) {\n\t\t\t\textendPartials( ractive.partials, template.p );\n\t\t\t}\n\t\t},\n\n\t\treset: function ( ractive ) {\n\t\t\tvar result = resetValue( ractive );\n\n\t\t\tif ( result ) {\n\t\t\t\tvar parsed = parseTemplate( result, ractive );\n\n\t\t\t\tractive.template = parsed.t;\n\t\t\t\textendPartials( ractive.partials, parsed.p, true );\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction resetValue ( ractive ) {\n\t\tvar initial = ractive._config.template;\n\n\t\t// If this isn't a dynamic template, there's nothing to do\n\t\tif ( !initial || !initial.fn ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar result = getDynamicTemplate( ractive, initial.fn );\n\n\t\t// TODO deep equality check to prevent unnecessary re-rendering\n\t\t// in the case of already-parsed templates\n\t\tif ( result !== initial.result ) {\n\t\t\tinitial.result = result;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tfunction getDynamicTemplate ( ractive, fn ) {\n\t\treturn fn.call( ractive, {\n\t\t\tfromId: parser.fromId,\n\t\t\tisParsed: parser.isParsed,\n\t\t\tparse: function ( template, options ) {\n\t\t\t\tif ( options === void 0 ) options = parser.getParseOptions( ractive );\n\n\t\t\t\treturn parser.parse( template, options );\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction parseTemplate ( template, ractive ) {\n\t\tif ( typeof template === 'string' ) {\n\t\t\t// parse will validate and add expression functions\n\t\t\ttemplate = parseAsString( template, ractive );\n\t\t}\n\t\telse {\n\t\t\t// need to validate and add exp for already parsed template\n\t\t\tvalidate$1( template );\n\t\t\taddFunctions( template );\n\t\t}\n\n\t\treturn template;\n\t}\n\n\tfunction parseAsString ( template, ractive ) {\n\t\t// ID of an element containing the template?\n\t\tif ( template[0] === '#' ) {\n\t\t\ttemplate = parser.fromId( template );\n\t\t}\n\n\t\treturn parser.parseFor( template, ractive );\n\t}\n\n\tfunction validate$1( template ) {\n\n\t\t// Check that the template even exists\n\t\tif ( template == undefined ) {\n\t\t\tthrow new Error( (\"The template cannot be \" + template + \".\") );\n\t\t}\n\n\t\t// Check the parsed template has a version at all\n\t\telse if ( typeof template.v !== 'number' ) {\n\t\t\tthrow new Error( 'The template parser was passed a non-string template, but the template doesn\\'t have a version.  Make sure you\\'re passing in the template you think you are.' );\n\t\t}\n\n\t\t// Check we're using the correct version\n\t\telse if ( template.v !== TEMPLATE_VERSION ) {\n\t\t\tthrow new Error( (\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + (template.v) + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\") );\n\t\t}\n\t}\n\n\tfunction extendPartials ( existingPartials, newPartials, overwrite ) {\n\t\tif ( !newPartials ) return;\n\n\t\t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t\t// case, but not initially...\n\n\t\tfor ( var key in newPartials ) {\n\t\t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t\t\t\texistingPartials[ key ] = newPartials[ key ];\n\t\t\t}\n\t\t}\n\t}\n\n\tvar registryNames = [\n\t\t'adaptors',\n\t\t'components',\n\t\t'computed',\n\t\t'decorators',\n\t\t'easing',\n\t\t'events',\n\t\t'interpolators',\n\t\t'partials',\n\t\t'transitions'\n\t];\n\n\tvar Registry = function Registry ( name, useDefaults ) {\n\t\tthis.name = name;\n\t\tthis.useDefaults = useDefaults;\n\t};\n\n\tRegistry.prototype.extend = function extend ( Parent, proto, options ) {\n\t\tthis.configure(\n\t\t\tthis.useDefaults ? Parent.defaults : Parent,\n\t\t\tthis.useDefaults ? proto : proto.constructor,\n\t\t\toptions );\n\t};\n\n\tRegistry.prototype.init = function init () {\n\t\t// noop\n\t};\n\n\tRegistry.prototype.configure = function configure ( Parent, target, options ) {\n\t\tvar name = this.name;\n\t\tvar option = options[ name ];\n\n\t\tvar registry = create( Parent[name] );\n\n\t\tfor ( var key in option ) {\n\t\t\tregistry[ key ] = option[ key ];\n\t\t}\n\n\t\ttarget[ name ] = registry;\n\t};\n\n\tRegistry.prototype.reset = function reset ( ractive ) {\n\t\tvar registry = ractive[ this.name ];\n\t\tvar changed = false;\n\n\t\tObject.keys( registry ).forEach( function ( key ) {\n\t\t\tvar item = registry[ key ];\n\t\t\t\t\n\t\t\tif ( item._fn ) {\n\t\t\t\tif ( item._fn.isOwner ) {\n\t\t\t\t\tregistry[key] = item._fn;\n\t\t\t\t} else {\n\t\t\t\t\tdelete registry[key];\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t});\n\n\t\treturn changed;\n\t};\n\n\tvar registries = registryNames.map( function ( name ) { return new Registry( name, name === 'computed' ); } );\n\n\tfunction wrap ( parent, name, method ) {\n\t\tif ( !/_super/.test( method ) ) return method;\n\n\t\tfunction wrapper () {\n\t\t\tvar superMethod = getSuperMethod( wrapper._parent, name );\n\t\t\tvar hasSuper = '_super' in this;\n\t\t\tvar oldSuper = this._super;\n\n\t\t\tthis._super = superMethod;\n\n\t\t\tvar result = method.apply( this, arguments );\n\n\t\t\tif ( hasSuper ) {\n\t\t\t\tthis._super = oldSuper;\n\t\t\t} else {\n\t\t\t\tdelete this._super;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\twrapper._parent = parent;\n\t\twrapper._method = method;\n\n\t\treturn wrapper;\n\t}\n\n\tfunction getSuperMethod ( parent, name ) {\n\t\tif ( name in parent ) {\n\t\t\tvar value = parent[ name ];\n\n\t\t\treturn typeof value === 'function' ?\n\t\t\t\tvalue :\n\t\t\t\tfunction () { return value; };\n\t\t}\n\n\t\treturn noop;\n\t}\n\n\tfunction getMessage( deprecated, correct, isError ) {\n\t\treturn \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\"\n\t\t\t+ ( isError ? (\" You cannot specify both options, please use options.\" + correct + \".\") : '' );\n\t}\n\n\tfunction deprecateOption ( options, deprecatedOption, correct ) {\n\t\tif ( deprecatedOption in options ) {\n\t\t\tif( !( correct in options ) ) {\n\t\t\t\twarnIfDebug( getMessage( deprecatedOption, correct ) );\n\t\t\t\toptions[ correct ] = options[ deprecatedOption ];\n\t\t\t} else {\n\t\t\t\tthrow new Error( getMessage( deprecatedOption, correct, true ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction deprecate ( options ) {\n\t\tdeprecateOption( options, 'beforeInit', 'onconstruct' );\n\t\tdeprecateOption( options, 'init', 'onrender' );\n\t\tdeprecateOption( options, 'complete', 'oncomplete' );\n\t\tdeprecateOption( options, 'eventDefinitions', 'events' );\n\n\t\t// Using extend with Component instead of options,\n\t\t// like Human.extend( Spider ) means adaptors as a registry\n\t\t// gets copied to options. So we have to check if actually an array\n\t\tif ( isArray( options.adaptors ) ) {\n\t\t\tdeprecateOption( options, 'adaptors', 'adapt' );\n\t\t}\n\t}\n\n\tvar custom = {\n\t\tadapt: adaptConfigurator,\n\t\tcss: cssConfigurator,\n\t\tdata: dataConfigurator,\n\t\ttemplate: templateConfigurator\n\t};\n\n\tvar defaultKeys = Object.keys( defaults );\n\n\tvar isStandardKey = makeObj( defaultKeys.filter( function ( key ) { return !custom[ key ]; } ) );\n\n\t// blacklisted keys that we don't double extend\n\tvar isBlacklisted = makeObj( defaultKeys.concat( registries.map( function ( r ) { return r.name; } ) ) );\n\n\tvar order = [].concat(\n\t\tdefaultKeys.filter( function ( key ) { return !registries[ key ] && !custom[ key ]; } ),\n\t\tregistries,\n\t\t//custom.data,\n\t\tcustom.template,\n\t\tcustom.css\n\t);\n\n\tvar config = {\n\t\textend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },\n\n\t\tinit: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },\n\n\t\treset: function ( ractive ) {\n\t\t\treturn order.filter( function ( c ) {\n\t\t\t\treturn c.reset && c.reset( ractive );\n\t\t\t}).map( function ( c ) { return c.name; } );\n\t\t},\n\n\t\t// this defines the order. TODO this isn't used anywhere in the codebase,\n\t\t// only in the test suite - should get rid of it\n\t\torder: order\n\t};\n\n\tfunction configure ( method, Parent, target, options ) {\n\t\tdeprecate( options );\n\n\t\tfor ( var key in options ) {\n\t\t\tif ( isStandardKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar value = options[ key ];\n\n\t\t\t\t// warn the developer if they passed a function and ignore its value\n\n\t\t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n\t\t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n\t\t\t\t// function object as the result of querySelector methods\n\t\t\t\tif ( key !== 'el' && typeof value === 'function' ) {\n\t\t\t\t\twarnIfDebug( (\"\" + key + \" is a Ractive option that does not expect a function and will be ignored\"),\n\t\t\t\t\t\tmethod === 'init' ? target : null );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// disallow combination of `append` and `enhance`\n\t\tif ( options.append && options.enhance ) {\n\t\t\tthrow new Error( 'Cannot use append and enhance at the same time' );\n\t\t}\n\n\t\tregistries.forEach( function ( registry ) {\n\t\t\tregistry[ method ]( Parent, target, options );\n\t\t});\n\n\t\tadaptConfigurator[ method ]( Parent, target, options );\n\t\ttemplateConfigurator[ method ]( Parent, target, options );\n\t\tcssConfigurator[ method ]( Parent, target, options );\n\n\t\textendOtherMethods( Parent.prototype, target, options );\n\t}\n\n\tfunction extendOtherMethods ( parent, target, options ) {\n\t\tfor ( var key in options ) {\n\t\t\tif ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {\n\t\t\t\tvar member = options[ key ];\n\n\t\t\t\t// if this is a method that overwrites a method, wrap it:\n\t\t\t\tif ( typeof member === 'function' ) {\n\t\t\t\t\tmember = wrap( parent, key, member );\n\t\t\t\t}\n\n\t\t\t\ttarget[ key ] = member;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeObj ( array ) {\n\t\tvar obj = {};\n\t\tarray.forEach( function ( x ) { return obj[x] = true; } );\n\t\treturn obj;\n\t}\n\n\tvar shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];\n\n\tvar completeHook$1 = new Hook( 'complete' );\n\tvar resetHook = new Hook( 'reset' );\n\tvar renderHook$1 = new Hook( 'render' );\n\tvar unrenderHook = new Hook( 'unrender' );\n\n\tfunction Ractive$reset ( data ) {\n\t\tdata = data || {};\n\n\t\tif ( typeof data !== 'object' ) {\n\t\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t\t}\n\n\t\t// TEMP need to tidy this up\n\t\tdata = dataConfigurator.init( this.constructor, this, { data: data });\n\n\t\tvar promise = runloop.start( this, true );\n\n\t\t// If the root object is wrapped, try and use the wrapper's reset value\n\t\tvar wrapper = this.viewmodel.wrapper;\n\t\tif ( wrapper && wrapper.reset ) {\n\t\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t\t// reset was rejected, we need to replace the object\n\t\t\t\tthis.viewmodel.set( data );\n\t\t\t}\n\t\t} else {\n\t\t\tthis.viewmodel.set( data );\n\t\t}\n\n\t\t// reset config items and track if need to rerender\n\t\tvar changes = config.reset( this );\n\t\tvar rerender;\n\n\t\tvar i = changes.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t\t\t\trerender = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( rerender ) {\n\t\t\tunrenderHook.fire( this );\n\t\t\tthis.fragment.resetTemplate( this.template );\n\t\t\trenderHook$1.fire( this );\n\t\t\tcompleteHook$1.fire( this );\n\t\t}\n\n\t\trunloop.end();\n\n\t\tresetHook.fire( this, data );\n\n\t\treturn promise;\n\t}\n\n\tfunction collect( source, name, attr, dest ) {\n\t\tsource.forEach( function ( item ) {\n\t\t\t// queue to rerender if the item is a partial and the current name matches\n\t\t\tif ( item.type === PARTIAL && ( item.refName ===  name || item.name === name ) ) {\n\t\t\t\titem.inAttribute = attr;\n\t\t\t\tdest.push( item );\n\t\t\t\treturn; // go no further\n\t\t\t}\n\n\t\t\t// if it has a fragment, process its items\n\t\t\tif ( item.fragment ) {\n\t\t\t\tcollect( item.fragment.iterations || item.fragment.items, name, attr, dest );\n\t\t\t}\n\n\t\t\t// or if it is itself a fragment, process its items\n\t\t\telse if ( isArray( item.items ) ) {\n\t\t\t\tcollect( item.items, name, attr, dest );\n\t\t\t}\n\n\t\t\t// or if it is a component, step in and process its items\n\t\t\telse if ( item.type === COMPONENT && item.instance ) {\n\t\t\t\t// ...unless the partial is shadowed\n\t\t\t\tif ( item.instance.partials[ name ] ) return;\n\t\t\t\tcollect( item.instance.fragment.items, name, attr, dest );\n\t\t\t}\n\n\t\t\t// if the item is an element, process its attributes too\n\t\t\tif ( item.type === ELEMENT ) {\n\t\t\t\tif ( isArray( item.attributes ) ) {\n\t\t\t\t\tcollect( item.attributes, name, true, dest );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction forceResetTemplate ( partial ) {\n\t\tpartial.forceResetTemplate();\n\t}\n\n\tfunction resetPartial ( name, partial ) {\n\t\tvar collection = [];\n\t\tcollect( this.fragment.items, name, false, collection );\n\n\t\tvar promise = runloop.start( this, true );\n\n\t\tthis.partials[ name ] = partial;\n\t\tcollection.forEach( forceResetTemplate );\n\n\t\trunloop.end();\n\n\t\treturn promise;\n\t}\n\n\tvar Item = function Item ( options ) {\n\t\tthis.parentFragment = options.parentFragment;\n\t\tthis.ractive = options.parentFragment.ractive;\n\n\t\tthis.template = options.template;\n\t\tthis.index = options.index;\n\t\tthis.type = options.template.t;\n\n\t\tthis.dirty = false;\n\t};\n\n\tItem.prototype.bubble = function bubble () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\tthis.parentFragment.bubble();\n\t\t}\n\t};\n\n\tItem.prototype.destroyed = function destroyed () {\n\t\tif ( this.fragment ) this.fragment.destroyed();\n\t};\n\n\tItem.prototype.find = function find () {\n\t\treturn null;\n\t};\n\n\tItem.prototype.findAll = function findAll () {\n\t\t// noop\n\t};\n\n\tItem.prototype.findComponent = function findComponent () {\n\t\treturn null;\n\t};\n\n\tItem.prototype.findAllComponents = function findAllComponents () {\n\t\t// noop;\n\t};\n\n\tItem.prototype.findNextNode = function findNextNode () {\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\tItem.prototype.shuffled = function shuffled () {\n\t\tif ( this.fragment ) this.fragment.shuffled();\n\t};\n\n\tItem.prototype.valueOf = function valueOf () {\n\t\treturn this.toString();\n\t};\n\n\tvar ComputationChild = (function (Model) {\n\t\tfunction ComputationChild () {\n\t\t\tModel.apply(this, arguments);\n\t\t}\n\n\t\tComputationChild.prototype = Object.create( Model && Model.prototype );\n\t\tComputationChild.prototype.constructor = ComputationChild;\n\n\t\tComputationChild.prototype.get = function get ( shouldCapture ) {\n\t\t\tif ( shouldCapture ) capture( this );\n\n\t\t\tvar parentValue = this.parent.get();\n\t\t\treturn parentValue ? parentValue[ this.key ] : undefined;\n\t\t};\n\n\t\tComputationChild.prototype.handleChange = function handleChange$1 () {\n\t\t\tthis.dirty = true;\n\n\t\t\tthis.links.forEach( marked );\n\t\t\tthis.deps.forEach( handleChange );\n\t\t\tthis.children.forEach( handleChange );\n\t\t\tthis.clearUnresolveds(); // TODO is this necessary?\n\t\t};\n\n\t\tComputationChild.prototype.joinKey = function joinKey ( key ) {\n\t\t\tif ( key === undefined || key === '' ) return this;\n\n\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar child = new ComputationChild( this, key );\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t}\n\n\t\t\treturn this.childByKey[ key ];\n\t\t};\n\n\t\treturn ComputationChild;\n\t}(Model));\n\n\tfunction createResolver ( proxy, ref, index ) {\n\t\tvar resolver = proxy.fragment.resolve( ref, function ( model ) {\n\t\t\tremoveFromArray( proxy.resolvers, resolver );\n\t\t\tproxy.models[ index ] = model;\n\t\t\tproxy.bubble();\n\t\t});\n\n\t\tproxy.resolvers.push( resolver );\n\t}\n\n\tvar ExpressionProxy = (function (Model) {\n\t\tfunction ExpressionProxy ( fragment, template ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tModel.call( this, fragment.ractive.viewmodel, null );\n\n\t\t\tthis.fragment = fragment;\n\t\t\tthis.template = template;\n\n\t\t\tthis.isReadonly = true;\n\t\t\tthis.dirty = true;\n\n\t\t\tthis.fn = getFunction( template.s, template.r.length );\n\n\t\t\tthis.resolvers = [];\n\t\t\tthis.models = this.template.r.map( function ( ref, index ) {\n\t\t\t\tvar model = resolveReference( this$1.fragment, ref );\n\n\t\t\t\tif ( !model ) {\n\t\t\t\t\tcreateResolver( this$1, ref, index );\n\t\t\t\t}\n\n\t\t\t\treturn model;\n\t\t\t});\n\t\t\tthis.dependencies = [];\n\n\t\t\tthis.shuffle = undefined;\n\n\t\t\tthis.bubble();\n\t\t}\n\n\t\tExpressionProxy.prototype = Object.create( Model && Model.prototype );\n\t\tExpressionProxy.prototype.constructor = ExpressionProxy;\n\n\t\tExpressionProxy.prototype.bubble = function bubble ( actuallyChanged ) {\n\t\t\t// refresh the keypath\n\t\t\tif ( actuallyChanged === void 0 ) actuallyChanged = true;\n\n\t\t\tif ( this.registered ) delete this.root.expressions[ this.keypath ];\n\t\t\tthis.keypath = undefined;\n\n\t\t\tif ( actuallyChanged ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.handleChange();\n\t\t\t}\n\t\t};\n\n\t\tExpressionProxy.prototype.get = function get ( shouldCapture ) {\n\t\t\tif ( shouldCapture ) capture( this );\n\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.value = this.getValue();\n\t\t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t\t\t\tthis.adapt();\n\t\t\t}\n\n\t\t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n\t\t};\n\n\t\tExpressionProxy.prototype.getKeypath = function getKeypath () {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( !this.template ) return '@undefined';\n\t\t\tif ( !this.keypath ) {\n\t\t\t\tthis.keypath = '@' + this.template.s.replace( /_(\\d+)/g, function ( match, i ) {\n\t\t\t\t\tif ( i >= this$1.models.length ) return match;\n\n\t\t\t\t\tvar model = this$1.models[i];\n\t\t\t\t\treturn model ? model.getKeypath() : '@undefined';\n\t\t\t\t});\n\n\t\t\t\tthis.root.expressions[ this.keypath ] = this;\n\t\t\t\tthis.registered = true;\n\t\t\t}\n\n\t\t\treturn this.keypath;\n\t\t};\n\n\t\tExpressionProxy.prototype.getValue = function getValue () {\n\t\t\tvar this$1 = this;\n\n\t\t\tstartCapturing();\n\t\t\tvar result;\n\n\t\t\ttry {\n\t\t\t\tvar params = this.models.map( function ( m ) { return m ? m.get( true ) : undefined; } );\n\t\t\t\tresult = this.fn.apply( this.fragment.ractive, params );\n\t\t\t} catch ( err ) {\n\t\t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n\t\t\t}\n\n\t\t\tvar dependencies = stopCapturing();\n\t\t\t// remove missing deps\n\t\t\tthis.dependencies.filter( function ( d ) { return !~dependencies.indexOf( d ); } ).forEach( function ( d ) {\n\t\t\t\td.unregister( this$1 );\n\t\t\t\tremoveFromArray( this$1.dependencies, d );\n\t\t\t});\n\t\t\t// register new deps\n\t\t\tdependencies.filter( function ( d ) { return !~this$1.dependencies.indexOf( d ); } ).forEach( function ( d ) {\n\t\t\t\td.register( this$1 );\n\t\t\t\tthis$1.dependencies.push( d );\n\t\t\t});\n\n\t\t\treturn result;\n\t\t};\n\n\t\tExpressionProxy.prototype.handleChange = function handleChange$1 () {\n\t\t\tthis.dirty = true;\n\n\t\t\tthis.links.forEach( marked );\n\t\t\tthis.deps.forEach( handleChange );\n\t\t\tthis.children.forEach( handleChange );\n\n\t\t\tthis.clearUnresolveds();\n\t\t};\n\n\t\tExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n\t\t\tif ( key === undefined || key === '' ) return this;\n\n\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar child = new ComputationChild( this, key );\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t}\n\n\t\t\treturn this.childByKey[ key ];\n\t\t};\n\n\t\tExpressionProxy.prototype.mark = function mark () {\n\t\t\tthis.handleChange();\n\t\t};\n\n\t\tExpressionProxy.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\tvar idx = this.models.indexOf( previous );\n\n\t\t\tif ( ~idx ) {\n\t\t\t\tnext = rebindMatch( this.template.r[idx], next, previous );\n\t\t\t\tif ( next !== previous ) {\n\t\t\t\t\tprevious.unregister( this );\n\t\t\t\t\tthis.models.splice( idx, 1, next );\n\t\t\t\t\t// TODO: set up a resolver if there is no next?\n\t\t\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.bubble( !safe );\n\t\t};\n\n\t\tExpressionProxy.prototype.retrieve = function retrieve () {\n\t\t\treturn this.get();\n\t\t};\n\n\t\tExpressionProxy.prototype.teardown = function teardown () {\n\t\t\tvar this$1 = this;\n\n\t\t\tthis.unbind();\n\t\t\tthis.fragment = undefined;\n\t\t\tif ( this.dependencies ) this.dependencies.forEach( function ( d ) { return d.unregister( this$1 ); } );\n\t\t\tModel.prototype.teardown.call(this);\n\t\t};\n\n\t\tExpressionProxy.prototype.unregister = function unregister( dep ) {\n\t\t\tModel.prototype.unregister.call( this, dep );\n\t\t\tif ( !this.deps.length ) this.teardown();\n\t\t};\n\n\t\tExpressionProxy.prototype.unbind = function unbind$1 () {\n\t\t\tthis.resolvers.forEach( unbind );\n\t\t};\n\n\t\treturn ExpressionProxy;\n\t}(Model));\n\n\tvar ReferenceExpressionChild = (function (Model) {\n\t\tfunction ReferenceExpressionChild ( parent, key ) {\n\t\t\tModel.call ( this, parent, key );\n\t\t}\n\n\t\tReferenceExpressionChild.prototype = Object.create( Model && Model.prototype );\n\t\tReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;\n\n\t\tReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {\n\t\t\tif ( isEqual( value, this.value ) ) return;\n\n\t\t\tvar parent = this.parent, keys = [ this.key ];\n\t\t\twhile ( parent ) {\n\t\t\t\tif ( parent.base ) {\n\t\t\t\t\tvar target = parent.model.joinAll( keys );\n\t\t\t\t\ttarget.applyValue( value );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tkeys.unshift( parent.key );\n\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t};\n\n\t\tReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {\n\t\t\tif ( key === undefined || key === '' ) return this;\n\n\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar child = new ReferenceExpressionChild( this, key );\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t}\n\n\t\t\treturn this.childByKey[ key ];\n\t\t};\n\n\t\tReferenceExpressionChild.prototype.retrieve = function retrieve () {\n\t\t\tvar parent = this.parent.get();\n\t\t\treturn parent && parent[ this.key ];\n\t\t};\n\n\t\treturn ReferenceExpressionChild;\n\t}(Model));\n\n\tvar ReferenceExpressionProxy = (function (Model) {\n\t\tfunction ReferenceExpressionProxy ( fragment, template ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tModel.call( this, null, null );\n\t\t\tthis.dirty = true;\n\t\t\tthis.root = fragment.ractive.viewmodel;\n\t\t\tthis.template = template;\n\n\t\t\tthis.resolvers = [];\n\n\t\t\tthis.base = resolve$2( fragment, template );\n\t\t\tvar baseResolver;\n\n\t\t\tif ( !this.base ) {\n\t\t\t\tbaseResolver = fragment.resolve( template.r, function ( model ) {\n\t\t\t\t\tthis$1.base = model;\n\t\t\t\t\tthis$1.bubble();\n\n\t\t\t\t\tremoveFromArray( this$1.resolvers, baseResolver );\n\t\t\t\t});\n\n\t\t\t\tthis.resolvers.push( baseResolver );\n\t\t\t}\n\n\t\t\tvar intermediary = this.intermediary = {\n\t\t\t\thandleChange: function () { return this$1.handleChange(); },\n\t\t\t\trebinding: function ( next, previous ) {\n\t\t\t\t\tif ( previous === this$1.base ) {\n\t\t\t\t\t\tnext = rebindMatch( template, next, previous );\n\t\t\t\t\t\tif ( next !== this$1.base ) {\n\t\t\t\t\t\t\tthis$1.base.unregister( intermediary );\n\t\t\t\t\t\t\tthis$1.base = next;\n\t\t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar idx = this$1.members.indexOf( previous );\n\t\t\t\t\t\tif ( ~idx ) {\n\t\t\t\t\t\t\t// only direct references will rebind... expressions handle themselves\n\t\t\t\t\t\t\tnext = rebindMatch( template.m[idx].n, next, previous );\n\t\t\t\t\t\t\tif ( next !== this$1.members[idx] ) {\n\t\t\t\t\t\t\t\tthis$1.members.splice( idx, 1, next );\n\t\t\t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next !== previous ) previous.unregister( intermediary );\n\t\t\t\t\tif ( next ) next.addShuffleTask( function () { return next.register( intermediary ); } );\n\n\t\t\t\t\tthis$1.bubble();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.members = template.m.map( function ( template, i ) {\n\t\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t\treturn { get: function () { return template; } };\n\t\t\t\t}\n\n\t\t\t\tvar model;\n\t\t\t\tvar resolver;\n\n\t\t\t\tif ( template.t === REFERENCE ) {\n\t\t\t\t\tmodel = resolveReference( fragment, template.n );\n\n\t\t\t\t\tif ( model ) {\n\t\t\t\t\t\tmodel.register( intermediary );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolver = fragment.resolve( template.n, function ( model ) {\n\t\t\t\t\t\t\tthis$1.members[i] = model;\n\n\t\t\t\t\t\t\tmodel.register( intermediary );\n\t\t\t\t\t\t\tthis$1.handleChange();\n\n\t\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn model;\n\t\t\t\t}\n\n\t\t\t\tmodel = new ExpressionProxy( fragment, template );\n\t\t\t\tmodel.register( intermediary );\n\t\t\t\treturn model;\n\t\t\t});\n\n\t\t\tthis.isUnresolved = true;\n\t\t\tthis.bubble();\n\t\t}\n\n\t\tReferenceExpressionProxy.prototype = Object.create( Model && Model.prototype );\n\t\tReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;\n\n\t\tReferenceExpressionProxy.prototype.bubble = function bubble () {\n\t\t\tif ( !this.base ) return;\n\t\t\tif ( !this.dirty ) this.handleChange();\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.forceResolution = function forceResolution () {\n\t\t\tthis.resolvers.forEach( function ( resolver ) { return resolver.forceResolution(); } );\n\t\t\tthis.dirty = true;\n\t\t\tthis.bubble();\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.get = function get ( shouldCapture ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.bubble();\n\n\t\t\t\tvar i = this.members.length, resolved = true;\n\t\t\t\twhile ( resolved && i-- ) {\n\t\t\t\t\tif ( !this$1.members[i] ) resolved = false;\n\t\t\t\t}\n\n\t\t\t\tif ( this.base && resolved ) {\n\t\t\t\t\tvar keys = this.members.map( function ( m ) { return escapeKey( String( m.get() ) ); } );\n\t\t\t\t\tvar model = this.base.joinAll( keys );\n\n\t\t\t\t\tif ( model !== this.model ) {\n\t\t\t\t\t\tif ( this.model ) {\n\t\t\t\t\t\t\tthis.model.unregister( this );\n\t\t\t\t\t\t\tthis.model.unregisterTwowayBinding( this );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.model = model;\n\t\t\t\t\t\tthis.parent = model.parent;\n\t\t\t\t\t\tthis.model.register( this );\n\t\t\t\t\t\tthis.model.registerTwowayBinding( this );\n\n\t\t\t\t\t\tif ( this.keypathModel ) this.keypathModel.handleChange();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.value = this.model ? this.model.get( shouldCapture ) : undefined;\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.mark();\n\t\t\t\treturn this.value;\n\t\t\t} else {\n\t\t\t\treturn this.model ? this.model.get( shouldCapture ) : undefined;\n\t\t\t}\n\t\t};\n\n\t\t// indirect two-way bindings\n\t\tReferenceExpressionProxy.prototype.getValue = function getValue () {\n\t\t\tvar this$1 = this;\n\n\t\t\tthis.value = this.model ? this.model.get() : undefined;\n\n\t\t\tvar i = this.bindings.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar value = this$1.bindings[i].getValue();\n\t\t\t\tif ( value !== this$1.value ) return value;\n\t\t\t}\n\n\t\t\t// check one-way bindings\n\t\t\tvar oneway = findBoundValue( this.deps );\n\t\t\tif ( oneway ) return oneway.value;\n\n\t\t\treturn this.value;\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {\n\t\t\treturn this.model ? this.model.getKeypath() : '@undefined';\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.handleChange = function handleChange$1 () {\n\t\t\tthis.dirty = true;\n\t\t\tthis.mark();\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n\t\t\tif ( key === undefined || key === '' ) return this;\n\n\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar child = new ReferenceExpressionChild( this, key );\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t}\n\n\t\t\treturn this.childByKey[ key ];\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.mark = function mark$1 () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.deps.forEach( handleChange );\n\t\t\t}\n\n\t\t\tthis.links.forEach( marked );\n\t\t\tthis.children.forEach( mark );\n\t\t\tthis.clearUnresolveds();\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.retrieve = function retrieve () {\n\t\t\treturn this.value;\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.rebinding = function rebinding () { }; // NOOP\n\n\t\tReferenceExpressionProxy.prototype.set = function set ( value ) {\n\t\t\tif ( !this.model ) throw new Error( 'Unresolved reference expression. This should not happen!' );\n\t\t\tthis.model.set( value );\n\t\t};\n\n\t\tReferenceExpressionProxy.prototype.unbind = function unbind$1 () {\n\t\t\tthis.resolvers.forEach( unbind );\n\t\t\tif ( this.model ) {\n\t\t\t\tthis.model.unregister( this );\n\t\t\t\tthis.model.unregisterTwowayBinding( this );\n\t\t\t}\n\t\t};\n\n\t\treturn ReferenceExpressionProxy;\n\t}(Model));\n\n\tfunction resolve$2 ( fragment, template ) {\n\t\tif ( template.r ) {\n\t\t\treturn resolveReference( fragment, template.r );\n\t\t}\n\n\t\telse if ( template.x ) {\n\t\t\treturn new ExpressionProxy( fragment, template.x );\n\t\t}\n\n\t\telse if ( template.rx ) {\n\t\t\treturn new ReferenceExpressionProxy( fragment, template.rx );\n\t\t}\n\t}\n\n\tfunction resolveAliases( section ) {\n\t\tif ( section.template.z ) {\n\t\t\tsection.aliases = {};\n\n\t\t\tvar refs = section.template.z;\n\t\t\tfor ( var i = 0; i < refs.length; i++ ) {\n\t\t\t\tsection.aliases[ refs[i].n ] = resolve$2( section.parentFragment, refs[i].x );\n\t\t\t}\n\t\t}\n\t}\n\n\tvar Alias = (function (Item) {\n\t\tfunction Alias ( options ) {\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.fragment = null;\n\t\t}\n\n\t\tAlias.prototype = Object.create( Item && Item.prototype );\n\t\tAlias.prototype.constructor = Alias;\n\n\t\tAlias.prototype.bind = function bind () {\n\t\t\tresolveAliases( this );\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\towner: this,\n\t\t\t\ttemplate: this.template.f\n\t\t\t}).bind();\n\t\t};\n\n\t\tAlias.prototype.detach = function detach () {\n\t\t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n\t\t};\n\n\t\tAlias.prototype.find = function find ( selector ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t}\n\t\t};\n\n\t\tAlias.prototype.findAll = function findAll ( selector, query ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t}\n\t\t};\n\n\t\tAlias.prototype.findComponent = function findComponent ( name ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t}\n\t\t};\n\n\t\tAlias.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t\t}\n\t\t};\n\n\t\tAlias.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\treturn this.fragment && this.fragment.firstNode( skipParent );\n\t\t};\n\n\t\tAlias.prototype.rebinding = function rebinding () {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( this.locked ) return;\n\t\t\tthis.locked = true;\n\t\t\trunloop.scheduleTask( function () {\n\t\t\t\tthis$1.locked = false;\n\t\t\t\tresolveAliases( this$1 );\n\t\t\t});\n\t\t};\n\n\t\tAlias.prototype.render = function render ( target ) {\n\t\t\tthis.rendered = true;\n\t\t\tif ( this.fragment ) this.fragment.render( target );\n\t\t};\n\n\t\tAlias.prototype.toString = function toString ( escape ) {\n\t\t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n\t\t};\n\n\t\tAlias.prototype.unbind = function unbind () {\n\t\t\tthis.aliases = {};\n\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t};\n\n\t\tAlias.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n\t\t\tthis.rendered = false;\n\t\t};\n\n\t\tAlias.prototype.update = function update () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.fragment.update();\n\t\t\t}\n\t\t};\n\n\t\treturn Alias;\n\t}(Item));\n\n\tfunction findElement( start, orComponent, name ) {\n\t\tif ( orComponent === void 0 ) orComponent = true;\n\n\t\twhile ( start && ( start.type !== ELEMENT || ( name && start.name !== name ) ) && ( !orComponent || start.type !== COMPONENT ) ) {\n\t\t\t// start is a fragment - look at the owner\n\t\t\tif ( start.owner ) start = start.owner;\n\t\t\t// start is a component or yielder - look at the container\n\t\t\telse if ( start.component ) start = start.containerFragment || start.component.parentFragment;\n\t\t\t// start is an item - look at the parent\n\t\t\telse if ( start.parent ) start = start.parent;\n\t\t\t// start is an item without a parent - look at the parent fragment\n\t\t\telse if ( start.parentFragment ) start = start.parentFragment;\n\n\t\t\telse start = undefined;\n\t\t}\n\n\t\treturn start;\n\t}\n\n\tvar space = /\\s+/;\n\tvar remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\n\tvar escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\2/gi;\n\tvar value = /\\0(\\d+)/g;\n\n\tfunction readStyle ( css ) {\n\t\tvar values = [];\n\n\t\tif ( typeof css !== 'string' ) return {};\n\n\t\treturn css.replace( escape, function ( match ) { return (\"\\u0000\" + (values.push( match ) - 1)); })\n\t\t\t.replace( remove, '' )\n\t\t\t.split( ';' )\n\t\t\t.filter( function ( rule ) { return !!rule.trim(); } )\n\t\t\t.map( function ( rule ) { return rule.replace( value, function ( match, n ) { return values[ n ]; } ); } )\n\t\t\t.reduce(function ( rules, rule ) {\n\t\t\t\tvar i = rule.indexOf(':');\n\t\t\t\tvar name = rule.substr( 0, i ).trim();\n\t\t\t\trules[ name ] = rule.substr( i + 1 ).trim();\n\t\t\t\treturn rules;\n\t\t\t}, {});\n\t}\n\n\tfunction readClass ( str ) {\n\t\tvar list = str.split( space );\n\n\t\t// remove any empty entries\n\t\tvar i = list.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( !list[i] ) list.splice( i, 1 );\n\t\t}\n\n\t\treturn list;\n\t}\n\n\tvar textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];\n\n\tfunction getUpdateDelegate ( attribute ) {\n\t\tvar element = attribute.element, name = attribute.name;\n\n\t\tif ( name === 'id' ) return updateId;\n\n\t\tif ( name === 'value' ) {\n\t\t\tif ( attribute.interpolator ) attribute.interpolator.bound = true;\n\n\t\t\t// special case - selects\n\t\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\t\treturn element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t\t}\n\n\t\t\tif ( element.name === 'textarea' ) return updateStringValue;\n\n\t\t\t// special case - contenteditable\n\t\t\tif ( element.getAttribute( 'contenteditable' ) != null ) return updateContentEditableValue;\n\n\t\t\t// special case - <input>\n\t\t\tif ( element.name === 'input' ) {\n\t\t\t\tvar type = element.getAttribute( 'type' );\n\n\t\t\t\t// type='file' value='{{fileList}}'>\n\t\t\t\tif ( type === 'file' ) return noop; // read-only\n\n\t\t\t\t// type='radio' name='{{twoway}}'\n\t\t\t\tif ( type === 'radio' && element.binding && element.binding.attribute.name === 'name' ) return updateRadioValue;\n\n\t\t\t\tif ( ~textTypes.indexOf( type ) ) return updateStringValue;\n\t\t\t}\n\n\t\t\treturn updateValue;\n\t\t}\n\n\t\tvar node = element.node;\n\n\t\t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n\t\tif ( attribute.isTwoway && name === 'name' ) {\n\t\t\tif ( node.type === 'radio' ) return updateRadioName;\n\t\t\tif ( node.type === 'checkbox' ) return updateCheckboxName;\n\t\t}\n\n\t\tif ( name === 'style' ) return updateStyleAttribute;\n\n\t\tif ( name.indexOf( 'style-' ) === 0 ) return updateInlineStyle;\n\n\t\t// special case - class names. IE fucks things up, again\n\t\tif ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === html ) ) return updateClassName;\n\n\t\tif ( name.indexOf( 'class-' ) === 0 ) return updateInlineClass;\n\n\t\tif ( attribute.isBoolean ) {\n\t\t\tvar type$1 = element.getAttribute( 'type' );\n\t\t\tif ( attribute.interpolator && name === 'checked' && ( type$1 === 'checkbox' || type$1 === 'radio' ) ) attribute.interpolator.bound = true;\n\t\t\treturn updateBoolean;\n\t\t}\n\n\t\tif ( attribute.namespace && attribute.namespace !== attribute.node.namespaceURI ) return updateNamespacedAttribute;\n\n\t\treturn updateAttribute;\n\t}\n\n\tfunction updateId ( reset ) {\n\t\tvar ref = this, node = ref.node;\n\t\tvar value = this.getValue();\n\n\t\t// remove the mapping to this node if it hasn't already been replaced\n\t\tif ( this.ractive.nodes[ node.id ] === node ) delete this.ractive.nodes[ node.id ];\n\t\tif ( reset ) return node.removeAttribute( 'id' );\n\n\t\tthis.ractive.nodes[ value ] = node;\n\n\t\tnode.id = value;\n\t}\n\n\tfunction updateMultipleSelectValue ( reset ) {\n\t\tvar value = this.getValue();\n\n\t\tif ( !isArray( value ) ) value = [ value ];\n\n\t\tvar options = this.node.options;\n\t\tvar i = options.length;\n\n\t\tif ( reset ) {\n\t\t\twhile ( i-- ) options[i].selected = false;\n\t\t} else {\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar option = options[i];\n\t\t\t\tvar optionValue = option._ractive ?\n\t\t\t\t\toption._ractive.value :\n\t\t\t\t\toption.value; // options inserted via a triple don't have _ractive\n\n\t\t\t\toption.selected = arrayContains( value, optionValue );\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updateSelectValue ( reset ) {\n\t\tvar value = this.getValue();\n\n\t\tif ( !this.locked ) { // TODO is locked still a thing?\n\t\t\tthis.node._ractive.value = value;\n\n\t\t\tvar options = this.node.options;\n\t\t\tvar i = options.length;\n\t\t\tvar wasSelected = false;\n\n\t\t\tif ( reset ) {\n\t\t\t\twhile ( i-- ) options[i].selected = false;\n\t\t\t} else {\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar option = options[i];\n\t\t\t\t\tvar optionValue = option._ractive ?\n\t\t\t\t\t\toption._ractive.value :\n\t\t\t\t\t\toption.value; // options inserted via a triple don't have _ractive\n\t\t\t\t\tif ( option.disabled && option.selected ) wasSelected = true;\n\n\t\t\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t\t\t\t\t\toption.selected = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !wasSelected ) this.node.selectedIndex = -1;\n\t\t}\n\t}\n\n\n\tfunction updateContentEditableValue ( reset ) {\n\t\tvar value = this.getValue();\n\n\t\tif ( !this.locked ) {\n\t\t\tif ( reset ) this.node.innerHTML = '';\n\t\t\telse this.node.innerHTML = value === undefined ? '' : value;\n\t\t}\n\t}\n\n\tfunction updateRadioValue ( reset ) {\n\t\tvar node = this.node;\n\t\tvar wasChecked = node.checked;\n\n\t\tvar value = this.getValue();\n\n\t\tif ( reset ) return node.checked = false;\n\n\t\t//node.value = this.element.getAttribute( 'value' );\n\t\tnode.value = this.node._ractive.value = value;\n\t\tnode.checked = value === this.element.getAttribute( 'name' );\n\n\t\t// This is a special case - if the input was checked, and the value\n\t\t// changed so that it's no longer checked, the twoway binding is\n\t\t// most likely out of date. To fix it we have to jump through some\n\t\t// hoops... this is a little kludgy but it works\n\t\tif ( wasChecked && !node.checked && this.element.binding && this.element.binding.rendered ) {\n\t\t\tthis.element.binding.group.model.set( this.element.binding.group.getValue() );\n\t\t}\n\t}\n\n\tfunction updateValue ( reset ) {\n\t\tif ( !this.locked ) {\n\t\t\tif ( reset ) {\n\t\t\t\tthis.node.removeAttribute( 'value' );\n\t\t\t\tthis.node.value = this.node._ractive.value = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar value = this.getValue();\n\n\t\t\tthis.node.value = this.node._ractive.value = value;\n\t\t\tthis.node.setAttribute( 'value', value );\n\t\t}\n\t}\n\n\tfunction updateStringValue ( reset ) {\n\t\tif ( !this.locked ) {\n\t\t\tif ( reset ) {\n\t\t\t\tthis.node._ractive.value = '';\n\t\t\t\tthis.node.removeAttribute( 'value' );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar value = this.getValue();\n\n\t\t\tthis.node._ractive.value = value;\n\n\t\t\tthis.node.value = safeToStringValue( value );\n\t\t\tthis.node.setAttribute( 'value', safeToStringValue( value ) );\n\t\t}\n\t}\n\n\tfunction updateRadioName ( reset ) {\n\t\tif ( reset ) this.node.checked = false;\n\t\telse this.node.checked = ( this.getValue() == this.node._ractive.value );\n\t}\n\n\tfunction updateCheckboxName ( reset ) {\n\t\tvar ref = this, element = ref.element, node = ref.node;\n\t\tvar binding = element.binding;\n\n\t\tvar value = this.getValue();\n\t\tvar valueAttribute = element.getAttribute( 'value' );\n\n\t\tif ( reset ) {\n\t\t\t// TODO: WAT?\n\t\t}\n\n\t\tif ( !isArray( value ) ) {\n\t\t\tbinding.isChecked = node.checked = ( value == valueAttribute );\n\t\t} else {\n\t\t\tvar i = value.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( valueAttribute == value[i] ) {\n\t\t\t\t\tbinding.isChecked = node.checked = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinding.isChecked = node.checked = false;\n\t\t}\n\t}\n\n\tfunction updateStyleAttribute ( reset ) {\n\t\tvar props = reset ? {} : readStyle( this.getValue() || '' );\n\t\tvar style = this.node.style;\n\t\tvar keys = Object.keys( props );\n\t\tvar prev = this.previous || [];\n\n\t\tvar i = 0;\n\t\twhile ( i < keys.length ) {\n\t\t\tif ( keys[i] in style ) {\n\t\t\t\tvar safe = props[ keys[i] ].replace( '!important', '' );\n\t\t\t\tstyle.setProperty( keys[i], safe, safe.length !== props[ keys[i] ].length ? 'important' : '' );\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t// remove now-missing attrs\n\t\ti = prev.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( !~keys.indexOf( prev[i] ) && prev[i] in style ) style.setProperty( prev[i], '', '' );\n\t\t}\n\n\t\tthis.previous = keys;\n\t}\n\n\tfunction updateInlineStyle ( reset ) {\n\t\tif ( !this.style ) {\n\t\t\tthis.style = decamelize( this.name.substr( 6 ) );\n\t\t}\n\n\t\tvar value = reset ? '' : safeToStringValue( this.getValue() );\n\t\tvar safe = value.replace( '!important', '' );\n\t\tthis.node.style.setProperty( this.style, safe, safe.length !== value.length ? 'important' : '' );\n\t}\n\n\tfunction updateClassName ( reset ) {\n\t\tvar value = reset ? [] : readClass( safeToStringValue( this.getValue() ) );\n\t\tvar attr = readClass( this.node.className );\n\t\tvar prev = this.previous || attr.slice( 0 );\n\n\t\tvar i = 0;\n\t\twhile ( i < value.length ) {\n\t\t\tif ( !~attr.indexOf( value[i] ) ) attr.push( value[i] );\n\t\t\ti++;\n\t\t}\n\n\t\t// remove now-missing classes\n\t\ti = prev.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( !~value.indexOf( prev[i] ) ) {\n\t\t\t\tvar idx = attr.indexOf( prev[i] );\n\t\t\t\tif ( ~idx ) attr.splice( idx, 1 );\n\t\t\t}\n\t\t}\n\n\t\tvar className = attr.join( ' ' );\n\n\t\tif ( className !== this.node.className ) {\n\t\t\tthis.node.className = className;\n\t\t}\n\n\t\tthis.previous = value;\n\t}\n\n\tfunction updateInlineClass ( reset ) {\n\t\tvar name = this.name.substr( 6 );\n\t\tvar attr = readClass( this.node.className );\n\t\tvar value = reset ? false : this.getValue();\n\n\t\tif ( !this.inlineClass ) this.inlineClass = name;\n\n\t\tif ( value && !~attr.indexOf( name ) ) attr.push( name );\n\t\telse if ( !value && ~attr.indexOf( name ) ) attr.splice( attr.indexOf( name ), 1 );\n\n\t\tthis.node.className = attr.join( ' ' );\n\t}\n\n\tfunction updateBoolean ( reset ) {\n\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t// otherwise the cursor will often be sent to the wrong place\n\t\tif ( !this.locked ) {\n\t\t\tif ( reset ) {\n\t\t\t\tif ( this.useProperty ) this.node[ this.propertyName ] = false;\n\t\t\t\tthis.node.removeAttribute( this.propertyName );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( this.useProperty ) {\n\t\t\t\tthis.node[ this.propertyName ] = this.getValue();\n\t\t\t} else {\n\t\t\t\tif ( this.getValue() ) {\n\t\t\t\t\tthis.node.setAttribute( this.propertyName, '' );\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.removeAttribute( this.propertyName );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updateAttribute ( reset ) {\n\t\tif ( reset ) this.node.removeAttribute( this.name );\n\t\telse this.node.setAttribute( this.name, safeToStringValue( this.getString() ) );\n\t}\n\n\tfunction updateNamespacedAttribute ( reset ) {\n\t\tif ( reset ) this.node.removeAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ) );\n\t\telse this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) );\n\t}\n\n\tvar propertyNames = {\n\t\t'accept-charset': 'acceptCharset',\n\t\taccesskey: 'accessKey',\n\t\tbgcolor: 'bgColor',\n\t\t'class': 'className',\n\t\tcodebase: 'codeBase',\n\t\tcolspan: 'colSpan',\n\t\tcontenteditable: 'contentEditable',\n\t\tdatetime: 'dateTime',\n\t\tdirname: 'dirName',\n\t\t'for': 'htmlFor',\n\t\t'http-equiv': 'httpEquiv',\n\t\tismap: 'isMap',\n\t\tmaxlength: 'maxLength',\n\t\tnovalidate: 'noValidate',\n\t\tpubdate: 'pubDate',\n\t\treadonly: 'readOnly',\n\t\trowspan: 'rowSpan',\n\t\ttabindex: 'tabIndex',\n\t\tusemap: 'useMap'\n\t};\n\n\tfunction lookupNamespace ( node, prefix ) {\n\t\tvar qualified = \"xmlns:\" + prefix;\n\n\t\twhile ( node ) {\n\t\t\tif ( node.hasAttribute && node.hasAttribute( qualified ) ) return node.getAttribute( qualified );\n\t\t\tnode = node.parentNode;\n\t\t}\n\n\t\treturn namespaces[ prefix ];\n\t}\n\n\tvar Attribute = (function (Item) {\n\t\tfunction Attribute ( options ) {\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.name = options.template.n;\n\t\t\tthis.namespace = null;\n\n\t\t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n\t\t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n\t\t\tthis.parentFragment = options.parentFragment; // shared\n\t\t\tthis.ractive = this.parentFragment.ractive;\n\n\t\t\tthis.rendered = false;\n\t\t\tthis.updateDelegate = null;\n\t\t\tthis.fragment = null;\n\n\t\t\tthis.element.attributeByName[ this.name ] = this;\n\n\t\t\tif ( !isArray( options.template.f ) ) {\n\t\t\t\tthis.value = options.template.f;\n\t\t\t\tif ( this.value === 0 ) {\n\t\t\t\t\tthis.value = '';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: options.template.f\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.interpolator = this.fragment &&\n\t\t\t\tthis.fragment.items.length === 1 &&\n\t\t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n\t\t\t\tthis.fragment.items[0];\n\n\t\t\tif ( this.interpolator ) this.interpolator.owner = this;\n\t\t}\n\n\t\tAttribute.prototype = Object.create( Item && Item.prototype );\n\t\tAttribute.prototype.constructor = Attribute;\n\n\t\tAttribute.prototype.bind = function bind () {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.bind();\n\t\t\t}\n\t\t};\n\n\t\tAttribute.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\tthis.element.bubble();\n\t\t\t\tthis.dirty = true;\n\t\t\t}\n\t\t};\n\n\t\tAttribute.prototype.destroyed = function destroyed () {\n\t\t\tthis.updateDelegate( true );\n\t\t};\n\n\t\tAttribute.prototype.getString = function getString () {\n\t\t\treturn this.fragment ?\n\t\t\t\tthis.fragment.toString() :\n\t\t\t\tthis.value != null ? '' + this.value : '';\n\t\t};\n\n\t\t// TODO could getValue ever be called for a static attribute,\n\t\t// or can we assume that this.fragment exists?\n\t\tAttribute.prototype.getValue = function getValue () {\n\t\t\treturn this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;\n\t\t};\n\n\t\tAttribute.prototype.render = function render () {\n\t\t\tvar node = this.element.node;\n\t\t\tthis.node = node;\n\n\t\t\t// should we use direct property access, or setAttribute?\n\t\t\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\t\t\tthis.propertyName = propertyNames[ this.name ] || this.name;\n\n\t\t\t\tif ( node[ this.propertyName ] !== undefined ) {\n\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t}\n\n\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\tif ( booleanAttributes.test( this.name ) || this.isTwoway ) {\n\t\t\t\t\tthis.isBoolean = true;\n\t\t\t\t}\n\n\t\t\t\tif ( this.propertyName === 'value' ) {\n\t\t\t\t\tnode._ractive.value = this.value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( node.namespaceURI ) {\n\t\t\t\tvar index = this.name.indexOf( ':' );\n\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\tthis.namespace = lookupNamespace( node, this.name.slice( 0, index ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis.namespace = node.namespaceURI;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.rendered = true;\n\t\t\tthis.updateDelegate = getUpdateDelegate( this );\n\t\t\tthis.updateDelegate();\n\t\t};\n\n\t\tAttribute.prototype.toString = function toString () {\n\t\t\tvar value = this.getValue();\n\n\t\t\t// Special case - select and textarea values (should not be stringified)\n\t\t\tif ( this.name === 'value' && ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Special case  bound radio `name` attributes\n\t\t\tif ( this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute( 'type' ) === 'radio' ) {\n\t\t\t\treturn (\"name=\\\"{{\" + (this.interpolator.model.getKeypath()) + \"}}\\\"\");\n\t\t\t}\n\n\t\t\t// Special case - style and class attributes and directives\n\t\t\tif ( this.owner === this.element && ( this.name === 'style' || this.name === 'class' || this.style || this.inlineClass ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !this.rendered && this.owner === this.element && ( !this.name.indexOf( 'style-' ) || !this.name.indexOf( 'class-' ) ) ) {\n\t\t\t\tif ( !this.name.indexOf( 'style-' ) ) {\n\t\t\t\t\tthis.style = decamelize( this.name.substr( 6 ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis.inlineClass = this.name.substr( 6 );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( booleanAttributes.test( this.name ) ) return value ? this.name : '';\n\t\t\tif ( value == null ) return '';\n\n\t\t\tvar str = safeAttributeString( this.getString() );\n\t\t\treturn str ?\n\t\t\t\t(\"\" + (this.name) + \"=\\\"\" + str + \"\\\"\") :\n\t\t\t\tthis.name;\n\t\t};\n\n\t\tAttribute.prototype.unbind = function unbind () {\n\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t};\n\n\t\tAttribute.prototype.unrender = function unrender () {\n\t\t\tthis.updateDelegate( true );\n\n\t\t\tthis.rendered = false;\n\t\t};\n\n\t\tAttribute.prototype.update = function update () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t\tif ( this.rendered ) this.updateDelegate();\n\t\t\t\tif ( this.isTwoway && !this.locked ) {\n\t\t\t\t\tthis.interpolator.twowayBinding.lastVal( true, this.interpolator.model.get() );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn Attribute;\n\t}(Item));\n\n\tvar BindingFlag = (function (Item) {\n\t\tfunction BindingFlag ( options ) {\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\t\tthis.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n\n\t\t\tif ( this.element.type === ELEMENT ) {\n\t\t\t\tif ( isArray( options.template.f ) ) {\n\t\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\ttemplate: options.template.f\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis.interpolator = this.fragment &&\n\t\t\t\t\t\t\t\t\tthis.fragment.items.length === 1 &&\n\t\t\t\t\t\t\t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n\t\t\t\t\t\t\t\t\tthis.fragment.items[0];\n\t\t\t}\n\t\t}\n\n\t\tBindingFlag.prototype = Object.create( Item && Item.prototype );\n\t\tBindingFlag.prototype.constructor = BindingFlag;\n\n\t\tBindingFlag.prototype.bind = function bind () {\n\t\t\tif ( this.fragment ) this.fragment.bind();\n\t\t\tset$2( this, this.getValue(), true );\n\t\t};\n\n\t\tBindingFlag.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.element.bubble();\n\t\t\t\tthis.dirty = true;\n\t\t\t}\n\t\t};\n\n\t\tBindingFlag.prototype.getValue = function getValue () {\n\t\t\tif ( this.fragment ) return this.fragment.valueOf();\n\t\t\telse if ( 'value' in this ) return this.value;\n\t\t\telse if ( 'f' in this.template ) return this.template.f;\n\t\t\telse return true;\n\t\t};\n\n\t\tBindingFlag.prototype.render = function render () {\n\t\t\tset$2( this, this.getValue(), true );\n\t\t};\n\n\t\tBindingFlag.prototype.toString = function toString () { return ''; };\n\n\t\tBindingFlag.prototype.unbind = function unbind () {\n\t\t\tif ( this.fragment ) this.fragment.unbind();\n\n\t\t\tdelete this.element[ this.flag ];\n\t\t};\n\n\t\tBindingFlag.prototype.unrender = function unrender () {\n\t\t\tif ( this.element.rendered ) this.element.recreateTwowayBinding();\n\t\t};\n\n\t\tBindingFlag.prototype.update = function update () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t\tset$2( this, this.getValue(), true );\n\t\t\t}\n\t\t};\n\n\t\treturn BindingFlag;\n\t}(Item));\n\n\tfunction set$2 ( flag, value, update ) {\n\t\tif ( value === 0 ) {\n\t\t\tflag.value = true;\n\t\t} else if ( value === 'true' ) {\n\t\t\tflag.value = true;\n\t\t} else if ( value === 'false' || value === '0' ) {\n\t\t\tflag.value = false;\n\t\t} else {\n\t\t\tflag.value = value;\n\t\t}\n\n\t\tvar current = flag.element[ flag.flag ];\n\t\tflag.element[ flag.flag ] = flag.value;\n\t\tif ( update && !flag.element.attributes.binding && current !== flag.value ) {\n\t\t\tflag.element.recreateTwowayBinding();\n\t\t}\n\n\t\treturn flag.value;\n\t}\n\n\tvar div$1 = doc ? createElement( 'div' ) : null;\n\n\tvar attributes = false;\n\tfunction inAttributes() { return attributes; }\n\tfunction doInAttributes( fn ) {\n\t\tattributes = true;\n\t\tfn();\n\t\tattributes = false;\n\t}\n\n\tvar ConditionalAttribute = (function (Item) {\n\t\tfunction ConditionalAttribute ( options ) {\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.attributes = [];\n\n\t\t\tthis.owner = options.owner;\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\tractive: this.ractive,\n\t\t\t\towner: this,\n\t\t\t\ttemplate: this.template\n\t\t\t});\n\t\t\t// this fragment can't participate in node-y things\n\t\t\tthis.fragment.findNextNode = noop;\n\n\t\t\tthis.dirty = false;\n\t\t}\n\n\t\tConditionalAttribute.prototype = Object.create( Item && Item.prototype );\n\t\tConditionalAttribute.prototype.constructor = ConditionalAttribute;\n\n\t\tConditionalAttribute.prototype.bind = function bind () {\n\t\t\tthis.fragment.bind();\n\t\t};\n\n\t\tConditionalAttribute.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.owner.bubble();\n\t\t\t}\n\t\t};\n\n\t\tConditionalAttribute.prototype.render = function render () {\n\t\t\tthis.node = this.owner.node;\n\t\t\tif ( this.node ) {\n\t\t\t\tthis.isSvg = this.node.namespaceURI === svg$1;\n\t\t\t}\n\n\t\t\tattributes = true;\n\t\t\tif ( !this.rendered ) this.fragment.render();\n\t\t\tattributes = false;\n\n\t\t\tthis.rendered = true;\n\t\t\tthis.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n\t\t\tthis.update();\n\t\t};\n\n\t\tConditionalAttribute.prototype.toString = function toString () {\n\t\t\treturn this.fragment.toString();\n\t\t};\n\n\t\tConditionalAttribute.prototype.unbind = function unbind () {\n\t\t\tthis.fragment.unbind();\n\t\t};\n\n\t\tConditionalAttribute.prototype.unrender = function unrender () {\n\t\t\tthis.rendered = false;\n\t\t\tthis.fragment.unrender();\n\t\t};\n\n\t\tConditionalAttribute.prototype.update = function update () {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar str;\n\t\t\tvar attrs;\n\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\n\t\t\t\tattributes = true;\n\t\t\t\tthis.fragment.update();\n\t\t\t\tattributes = false;\n\n\t\t\t\tif ( this.rendered && this.node ) {\n\t\t\t\t\tstr = this.fragment.toString();\n\t\t\t\t\tattrs = parseAttributes( str, this.isSvg );\n\n\t\t\t\t\t// any attributes that previously existed but no longer do\n\t\t\t\t\t// must be removed\n\t\t\t\t\tthis.attributes.filter( function ( a ) { return notIn( attrs, a ); } ).forEach( function ( a ) {\n\t\t\t\t\t\tthis$1.node.removeAttribute( a.name );\n\t\t\t\t\t});\n\n\t\t\t\t\tattrs.forEach( function ( a ) {\n\t\t\t\t\t\tthis$1.node.setAttribute( a.name, a.value );\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.attributes = attrs;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn ConditionalAttribute;\n\t}(Item));\n\n\tfunction parseAttributes ( str, isSvg ) {\n\t\tvar tagName = isSvg ? 'svg' : 'div';\n\t\treturn str\n\t\t\t? (div$1.innerHTML = \"<\" + tagName + \" \" + str + \"></\" + tagName + \">\") &&\n\t\t\t\ttoArray(div$1.childNodes[0].attributes)\n\t\t\t: [];\n\t}\n\n\tfunction notIn ( haystack, needle ) {\n\t\tvar i = haystack.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( haystack[i].name === needle.name ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction processWrapper ( wrapper, array, methodName, newIndices ) {\n\t\tvar __model = wrapper.__model;\n\n\t\tif ( newIndices ) {\n\t\t\t__model.shuffle( newIndices );\n\t\t} else {\n\t\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t\t// TODO use merge logic?\n\t\t\t//root.viewmodel.mark( keypath );\n\t\t}\n\t}\n\n\tvar mutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ];\n\tvar patchedArrayProto = [];\n\n\tmutatorMethods.forEach( function ( methodName ) {\n\t\tvar method = function () {\n\t\t\tvar this$1 = this;\n\t\t\tvar args = [], len = arguments.length;\n\t\t\twhile ( len-- ) args[ len ] = arguments[ len ];\n\n\t\t\tvar newIndices = getNewIndices( this.length, methodName, args );\n\n\t\t\t// lock any magic array wrappers, so that things don't get fudged\n\t\t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = true; } );\n\n\t\t\t// apply the underlying method\n\t\t\tvar result = Array.prototype[ methodName ].apply( this, arguments );\n\n\t\t\t// trigger changes\n\t\t\trunloop.start();\n\n\t\t\tthis._ractive.setting = true;\n\t\t\tvar i = this._ractive.wrappers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprocessWrapper( this$1._ractive.wrappers[i], this$1, methodName, newIndices );\n\t\t\t}\n\n\t\t\trunloop.end();\n\n\t\t\tthis._ractive.setting = false;\n\n\t\t\t// unlock the magic arrays... magic... bah\n\t\t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = false; } );\n\n\t\t\treturn result;\n\t\t};\n\n\t\tdefineProperty( patchedArrayProto, methodName, {\n\t\t\tvalue: method,\n\t\t\tconfigurable: true\n\t\t});\n\t});\n\n\tvar patchArrayMethods;\n\tvar unpatchArrayMethods;\n\n\t// can we use prototype chain injection?\n\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n\tif ( ({}).__proto__ ) {\n\t\t// yes, we can\n\t\tpatchArrayMethods = function ( array ) { return array.__proto__ = patchedArrayProto; };\n\t\tunpatchArrayMethods = function ( array ) { return array.__proto__ = Array.prototype; };\n\t}\n\n\telse {\n\t\t// no, we can't\n\t\tpatchArrayMethods = function ( array ) {\n\t\t\tvar i = mutatorMethods.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar methodName = mutatorMethods[i];\n\t\t\t\tdefineProperty( array, methodName, {\n\t\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tunpatchArrayMethods = function ( array ) {\n\t\t\tvar i = mutatorMethods.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t\t}\n\t\t};\n\t}\n\n\tpatchArrayMethods.unpatch = unpatchArrayMethods; // TODO export separately?\n\tvar patch = patchArrayMethods;\n\n\tvar errorMessage$1 = 'Something went wrong in a rather interesting way';\n\n\tvar arrayAdaptor = {\n\t\tfilter: function ( object ) {\n\t\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t\t// or the array didn't trigger the get() itself\n\t\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t\t},\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\tvar ArrayWrapper = function ArrayWrapper ( ractive, array ) {\n\t\tthis.root = ractive;\n\t\tthis.value = array;\n\t\tthis.__model = null; // filled in later\n\n\t\t// if this array hasn't already been ractified, ractify it\n\t\tif ( !array._ractive ) {\n\t\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\t\tdefineProperty( array, '_ractive', {\n\t\t\t\tvalue: {\n\t\t\t\t\twrappers: [],\n\t\t\t\t\tinstances: [],\n\t\t\t\t\tsetting: false\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t});\n\n\t\t\tpatch( array );\n\t\t}\n\n\t\t// store the ractive instance, so we can handle transitions later\n\t\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\t\tarray._ractive.instances.push( ractive );\n\t\t}\n\n\t\tarray._ractive.instances[ ractive._guid ] += 1;\n\t\tarray._ractive.wrappers.push( this );\n\t};\n\n\tArrayWrapper.prototype.get = function get () {\n\t\treturn this.value;\n\t};\n\n\tArrayWrapper.prototype.reset = function reset ( value ) {\n\t\treturn this.value === value;\n\t};\n\n\tArrayWrapper.prototype.teardown = function teardown () {\n\t\tvar array, storage, wrappers, instances, index;\n\n\t\tarray = this.value;\n\t\tstorage = array._ractive;\n\t\twrappers = storage.wrappers;\n\t\tinstances = storage.instances;\n\n\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t// and immediate setup\n\t\tif ( storage.setting ) {\n\t\t\treturn false; // so that we don't remove it from cached wrappers\n\t\t}\n\n\t\tindex = wrappers.indexOf( this );\n\t\tif ( index === -1 ) {\n\t\t\tthrow new Error( errorMessage$1 );\n\t\t}\n\n\t\twrappers.splice( index, 1 );\n\n\t\t// if nothing else depends on this array, we can revert it to its\n\t\t// natural state\n\t\tif ( !wrappers.length ) {\n\t\t\tdelete array._ractive;\n\t\t\tpatch.unpatch( this.value );\n\t\t}\n\n\t\telse {\n\t\t\t// remove ractive instance if possible\n\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\tindex = instances.indexOf( this.root );\n\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage$1 );\n\t\t\t\t}\n\n\t\t\t\tinstances.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t};\n\n\tvar magicAdaptor;\n\n\ttry {\n\t\tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\n\t\tmagicAdaptor = {\n\t\t\tfilter: function ( value ) {\n\t\t\t\treturn value && typeof value === 'object';\n\t\t\t},\n\t\t\twrap: function ( ractive, value, keypath ) {\n\t\t\t\treturn new MagicWrapper( ractive, value, keypath );\n\t\t\t}\n\t\t};\n\t} catch ( err ) {\n\t\tmagicAdaptor = false;\n\t}\n\n\tvar magicAdaptor$1 = magicAdaptor;\n\n\tfunction createOrWrapDescriptor ( originalDescriptor, ractive, keypath, wrapper ) {\n\t\tif ( originalDescriptor.set && originalDescriptor.set.__magic ) {\n\t\t\toriginalDescriptor.set.__magic.dependants.push({ ractive: ractive, keypath: keypath });\n\t\t\treturn originalDescriptor;\n\t\t}\n\n\t\tvar setting;\n\n\t\tvar dependants = [{ ractive: ractive, keypath: keypath }];\n\n\t\tvar descriptor = {\n\t\t\tget: function () {\n\t\t\t\treturn 'value' in originalDescriptor ? originalDescriptor.value : originalDescriptor.get.call( this );\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tif ( setting ) return;\n\n\t\t\t\tif ( 'value' in originalDescriptor ) {\n\t\t\t\t\toriginalDescriptor.value = value;\n\t\t\t\t} else {\n\t\t\t\t\toriginalDescriptor.set.call( this, value );\n\t\t\t\t}\n\n\t\t\t\tif ( wrapper.locked ) return;\n\t\t\t\tsetting = true;\n\t\t\t\tdependants.forEach( function (ref) {\n\t\t\t\t\tvar ractive = ref.ractive;\n\t\t\t\t\tvar keypath = ref.keypath;\n\n\t\t\t\t\tractive.set( keypath, value );\n\t\t\t\t});\n\t\t\t\tsetting = false;\n\t\t\t},\n\t\t\tenumerable: true\n\t\t};\n\n\t\tdescriptor.set.__magic = { dependants: dependants, originalDescriptor: originalDescriptor };\n\n\t\treturn descriptor;\n\t}\n\n\tfunction revert ( descriptor, ractive, keypath ) {\n\t\tif ( !descriptor.set || !descriptor.set.__magic ) return true;\n\n\t\tvar dependants = descriptor.set.__magic;\n\t\tvar i = dependants.length;\n\t\twhile ( i-- ) {\n\t\t\tvar dependant = dependants[i];\n\t\t\tif ( dependant.ractive === ractive && dependant.keypath === keypath ) {\n\t\t\t\tdependants.splice( i, 1 );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar MagicWrapper = function MagicWrapper ( ractive, value, keypath ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.ractive = ractive;\n\t\tthis.value = value;\n\t\tthis.keypath = keypath;\n\n\t\tthis.originalDescriptors = {};\n\n\t\t// wrap all properties with getters\n\t\tObject.keys( value ).forEach( function ( key ) {\n\t\t\tvar originalDescriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n\t\t\tthis$1.originalDescriptors[ key ] = originalDescriptor;\n\n\t\t\tvar childKeypath = keypath ? (\"\" + keypath + \".\" + (escapeKey( key ))) : escapeKey( key );\n\n\t\t\tvar descriptor = createOrWrapDescriptor( originalDescriptor, ractive, childKeypath, this$1 );\n\n\n\n\t\t\tObject.defineProperty( this$1.value, key, descriptor );\n\t\t});\n\t};\n\n\tMagicWrapper.prototype.get = function get () {\n\t\treturn this.value;\n\t};\n\n\tMagicWrapper.prototype.reset = function reset ( value ) {\n\t\treturn this.value === value;\n\t};\n\n\tMagicWrapper.prototype.set = function set ( key, value ) {\n\t\tthis.value[ key ] = value;\n\t};\n\n\tMagicWrapper.prototype.teardown = function teardown () {\n\t\tvar this$1 = this;\n\n\t\t\tObject.keys( this.value ).forEach( function ( key ) {\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n\t\t\tif ( !descriptor.set || !descriptor.set.__magic ) return;\n\n\t\t\trevert( descriptor );\n\n\t\t\tif ( descriptor.set.__magic.dependants.length === 1 ) {\n\t\t\t\tObject.defineProperty( this$1.value, key, descriptor.set.__magic.originalDescriptor );\n\t\t\t}\n\t\t});\n\t};\n\n\tvar MagicArrayWrapper = function MagicArrayWrapper ( ractive, array, keypath ) {\n\t\tthis.value = array;\n\n\t\tthis.magic = true;\n\n\t\tthis.magicWrapper = magicAdaptor$1.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper.magic = this.magicWrapper;\n\n\t\t// ugh, this really is a terrible hack\n\t\tObject.defineProperty( this, '__model', {\n\t\t\tget: function () {\n\t\t\t\treturn this.arrayWrapper.__model;\n\t\t\t},\n\t\t\tset: function ( model ) {\n\t\t\t\tthis.arrayWrapper.__model = model;\n\t\t\t}\n\t\t});\n\t};\n\n\tMagicArrayWrapper.prototype.get = function get () {\n\t\treturn this.value;\n\t};\n\n\tMagicArrayWrapper.prototype.teardown = function teardown () {\n\t\tthis.arrayWrapper.teardown();\n\t\tthis.magicWrapper.teardown();\n\t};\n\n\tMagicArrayWrapper.prototype.reset = function reset ( value ) {\n\t\treturn this.arrayWrapper.reset( value ) && this.magicWrapper.reset( value );\n\t};\n\n\tvar magicArrayAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\treturn magicAdaptor$1.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t},\n\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\t// TODO this is probably a bit anal, maybe we should leave it out\n\tfunction prettify ( fnBody ) {\n\t\tvar lines = fnBody\n\t\t\t.replace( /^\\t+/gm, function ( tabs ) { return tabs.split( '\\t' ).join( '  ' ); } )\n\t\t\t.split( '\\n' );\n\n\t\tvar minIndent = lines.length < 2 ? 0 :\n\t\t\tlines.slice( 1 ).reduce( function ( prev, line ) {\n\t\t\t\treturn Math.min( prev, /^\\s*/.exec( line )[0].length );\n\t\t\t}, Infinity );\n\n\t\treturn lines.map( function ( line, i ) {\n\t\t\treturn '    ' + ( i ? line.substring( minIndent ) : line );\n\t\t}).join( '\\n' );\n\t}\n\n\t// Ditto. This function truncates the stack to only include app code\n\tfunction truncateStack ( stack ) {\n\t\tif ( !stack ) return '';\n\n\t\tvar lines = stack.split( '\\n' );\n\t\tvar name = Computation.name + '.getValue';\n\n\t\tvar truncated = [];\n\n\t\tvar len = lines.length;\n\t\tfor ( var i = 1; i < len; i += 1 ) {\n\t\t\tvar line = lines[i];\n\n\t\t\tif ( ~line.indexOf( name ) ) {\n\t\t\t\treturn truncated.join( '\\n' );\n\t\t\t} else {\n\t\t\t\ttruncated.push( line );\n\t\t\t}\n\t\t}\n\t}\n\n\tvar Computation = (function (Model) {\n\t\tfunction Computation ( viewmodel, signature, key ) {\n\t\t\tModel.call( this, null, null );\n\n\t\t\tthis.root = this.parent = viewmodel;\n\t\t\tthis.signature = signature;\n\n\t\t\tthis.key = key; // not actually used, but helps with debugging\n\t\t\tthis.isExpression = key && key[0] === '@';\n\n\t\t\tthis.isReadonly = !this.signature.setter;\n\n\t\t\tthis.context = viewmodel.computationContext;\n\n\t\t\tthis.dependencies = [];\n\n\t\t\tthis.children = [];\n\t\t\tthis.childByKey = {};\n\n\t\t\tthis.deps = [];\n\n\t\t\tthis.dirty = true;\n\n\t\t\t// TODO: is there a less hackish way to do this?\n\t\t\tthis.shuffle = undefined;\n\t\t}\n\n\t\tComputation.prototype = Object.create( Model && Model.prototype );\n\t\tComputation.prototype.constructor = Computation;\n\n\t\tComputation.prototype.get = function get ( shouldCapture ) {\n\t\t\tif ( shouldCapture ) capture( this );\n\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.value = this.getValue();\n\t\t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t\t\t\tthis.adapt();\n\t\t\t}\n\n\t\t\t// if capturing, this value needs to be unwrapped because it's for external use\n\t\t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n\t\t};\n\n\t\tComputation.prototype.getValue = function getValue () {\n\t\t\tstartCapturing();\n\t\t\tvar result;\n\n\t\t\ttry {\n\t\t\t\tresult = this.signature.getter.call( this.context );\n\t\t\t} catch ( err ) {\n\t\t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n\n\t\t\t\t// TODO this is all well and good in Chrome, but...\n\t\t\t\t// ...also, should encapsulate this stuff better, and only\n\t\t\t\t// show it if Ractive.DEBUG\n\t\t\t\tif ( hasConsole ) {\n\t\t\t\t\tif ( console.groupCollapsed ) console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' );\n\t\t\t\t\tvar functionBody = prettify( this.signature.getterString );\n\t\t\t\t\tvar stack = this.signature.getterUseStack ? '\\n\\n' + truncateStack( err.stack ) : '';\n\t\t\t\t\tconsole.error( (\"\" + (err.name) + \": \" + (err.message) + \"\\n\\n\" + functionBody + \"\" + stack) );\n\t\t\t\t\tif ( console.groupCollapsed ) console.groupEnd();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dependencies = stopCapturing();\n\t\t\tthis.setDependencies( dependencies );\n\n\t\t\t// if not the first computation and the value is not the same,\n\t\t\t// register the change for change events\n\t\t\tif ( 'value' in this && result !== this.value ) {\n\t\t\t\tthis.registerChange( this.getKeypath(), result );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tComputation.prototype.handleChange = function handleChange$1 () {\n\t\t\tthis.dirty = true;\n\n\t\t\tthis.links.forEach( marked );\n\t\t\tthis.deps.forEach( handleChange );\n\t\t\tthis.children.forEach( handleChange );\n\t\t\tthis.clearUnresolveds(); // TODO same question as on Model - necessary for primitives?\n\t\t};\n\n\t\tComputation.prototype.joinKey = function joinKey ( key ) {\n\t\t\tif ( key === undefined || key === '' ) return this;\n\n\t\t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t\t\t\tvar child = new ComputationChild( this, key );\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.childByKey[ key ] = child;\n\t\t\t}\n\n\t\t\treturn this.childByKey[ key ];\n\t\t};\n\n\t\tComputation.prototype.mark = function mark () {\n\t\t\tthis.handleChange();\n\t\t};\n\n\t\tComputation.prototype.rebinding = function rebinding ( next, previous ) {\n\t\t\t// computations will grab all of their deps again automagically\n\t\t\tif ( next !== previous ) this.handleChange();\n\t\t};\n\n\t\tComputation.prototype.set = function set ( value ) {\n\t\t\tif ( !this.signature.setter ) {\n\t\t\t\tthrow new Error( (\"Cannot set read-only computed value '\" + (this.key) + \"'\") );\n\t\t\t}\n\n\t\t\tthis.signature.setter( value );\n\t\t\tthis.mark();\n\t\t};\n\n\t\tComputation.prototype.setDependencies = function setDependencies ( dependencies ) {\n\t\t\t// unregister any soft dependencies we no longer have\n\t\t\tvar this$1 = this;\n\n\t\t\tvar i = this.dependencies.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar model = this$1.dependencies[i];\n\t\t\t\tif ( !~dependencies.indexOf( model ) ) model.unregister( this$1 );\n\t\t\t}\n\n\t\t\t// and add any new ones\n\t\t\ti = dependencies.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar model$1 = dependencies[i];\n\t\t\t\tif ( !~this$1.dependencies.indexOf( model$1 ) ) model$1.register( this$1 );\n\t\t\t}\n\n\t\t\tthis.dependencies = dependencies;\n\t\t};\n\n\t\tComputation.prototype.teardown = function teardown () {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar i = this.dependencies.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( this$1.dependencies[i] ) this$1.dependencies[i].unregister( this$1 );\n\t\t\t}\n\t\t\tif ( this.root.computations[this.key] === this ) delete this.root.computations[this.key];\n\t\t\tModel.prototype.teardown.call(this);\n\t\t};\n\n\t\tComputation.prototype.unregister = function unregister ( dependent ) {\n\t\t\tModel.prototype.unregister.call( this, dependent );\n\t\t\t// tear down expressions with no deps, because they will be replaced when needed\n\t\t\tif ( this.isExpression && this.deps.length === 0 ) this.teardown();\n\t\t};\n\n\t\treturn Computation;\n\t}(Model));\n\n\tvar RactiveModel = (function (Model) {\n\t\tfunction RactiveModel ( ractive ) {\n\t\t\tModel.call( this, null, '' );\n\t\t\tthis.value = ractive;\n\t\t\tthis.isRoot = true;\n\t\t\tthis.root = this;\n\t\t\tthis.adaptors = [];\n\t\t\tthis.ractive = ractive;\n\t\t\tthis.changes = {};\n\t\t}\n\n\t\tRactiveModel.prototype = Object.create( Model && Model.prototype );\n\t\tRactiveModel.prototype.constructor = RactiveModel;\n\n\t\tRactiveModel.prototype.getKeypath = function getKeypath() {\n\t\t\treturn '@this';\n\t\t};\n\n\t\treturn RactiveModel;\n\t}(Model));\n\n\tvar hasProp$1 = Object.prototype.hasOwnProperty;\n\n\tvar RootModel = (function (Model) {\n\t\tfunction RootModel ( options ) {\n\t\t\tModel.call( this, null, null );\n\n\t\t\t// TODO deprecate this\n\t\t\tthis.changes = {};\n\n\t\t\tthis.isRoot = true;\n\t\t\tthis.root = this;\n\t\t\tthis.ractive = options.ractive; // TODO sever this link\n\n\t\t\tthis.value = options.data;\n\t\t\tthis.adaptors = options.adapt;\n\t\t\tthis.adapt();\n\n\t\t\tthis.computationContext = options.ractive;\n\t\t\tthis.computations = {};\n\n\t\t\t// TODO this is only for deprecation of using expression keypaths\n\t\t\tthis.expressions = {};\n\t\t}\n\n\t\tRootModel.prototype = Object.create( Model && Model.prototype );\n\t\tRootModel.prototype.constructor = RootModel;\n\n\t\tRootModel.prototype.applyChanges = function applyChanges () {\n\t\t\tthis._changeHash = {};\n\t\t\tthis.flush();\n\n\t\t\treturn this._changeHash;\n\t\t};\n\n\t\tRootModel.prototype.compute = function compute ( key, signature ) {\n\t\t\tvar computation = new Computation( this, signature, key );\n\t\t\tthis.computations[ escapeKey( key ) ] = computation;\n\n\t\t\treturn computation;\n\t\t};\n\n\t\tRootModel.prototype.createLink = function createLink ( keypath, target, targetPath ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar keys = splitKeypathI( keypath );\n\n\t\t\tvar model = this;\n\t\t\twhile ( keys.length ) {\n\t\t\t\tvar key = keys.shift();\n\t\t\t\tmodel = this$1.childByKey[ key ] || this$1.joinKey( key );\n\t\t\t}\n\n\t\t\treturn model.link( target, targetPath );\n\t\t};\n\n\t\tRootModel.prototype.get = function get ( shouldCapture, options ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( shouldCapture ) capture( this );\n\n\t\t\tif ( !options || options.virtual !== false ) {\n\t\t\t\tvar result = this.getVirtual();\n\t\t\t\tvar keys = Object.keys( this.computations );\n\t\t\t\tvar i = keys.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar computation = this$1.computations[ keys[i] ];\n\t\t\t\t\t// exclude template expressions\n\t\t\t\t\tif ( !computation.isExpression ) {\n\t\t\t\t\t\tresult[ keys[i] ] = computation.get();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t};\n\n\t\tRootModel.prototype.getKeypath = function getKeypath () {\n\t\t\treturn '';\n\t\t};\n\n\t\tRootModel.prototype.getRactiveModel = function getRactiveModel() {\n\t\t\treturn this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );\n\t\t};\n\n\t\tRootModel.prototype.getValueChildren = function getValueChildren () {\n\t\t\tvar children = Model.prototype.getValueChildren.call( this, this.value );\n\n\t\t\tthis.children.forEach( function ( child ) {\n\t\t\t\tif ( child._link ) {\n\t\t\t\t\tvar idx = children.indexOf( child );\n\t\t\t\t\tif ( ~idx ) children.splice( idx, 1, child._link );\n\t\t\t\t\telse children.push( child._link );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor ( var k in this.computations ) {\n\t\t\t\tchildren.push( this.computations[k] );\n\t\t\t}\n\n\t\t\treturn children;\n\t\t};\n\n\t\tRootModel.prototype.handleChange = function handleChange$1 () {\n\t\t\tthis.deps.forEach( handleChange );\n\t\t};\n\n\t\tRootModel.prototype.has = function has ( key ) {\n\t\t\tvar value = this.value;\n\t\t\tvar unescapedKey = unescapeKey( key );\n\n\t\t\tif ( hasProp$1.call( value, unescapedKey ) ) return true;\n\n\t\t\t// mappings/links and computations\n\t\t\tif ( key in this.computations || this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link ) return true;\n\t\t\t// TODO remove this after deprecation is done\n\t\t\tif ( key in this.expressions ) return true;\n\n\t\t\t// We climb up the constructor chain to find if one of them contains the unescapedKey\n\t\t\tvar constructor = value.constructor;\n\t\t\twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n\t\t\t\tif ( hasProp$1.call( constructor.prototype, unescapedKey ) ) return true;\n\t\t\t\tconstructor = constructor.constructor;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\tRootModel.prototype.joinKey = function joinKey ( key, opts ) {\n\t\t\tif ( key === '@global' ) return GlobalModel$1;\n\t\t\tif ( key === '@this' ) return this.getRactiveModel();\n\n\t\t\tif ( this.expressions.hasOwnProperty( key ) ) {\n\t\t\t\twarnIfDebug( (\"Accessing expression keypaths (\" + (key.substr(1)) + \") from the instance is deprecated. You can used a getNodeInfo or event object to access keypaths with expression context.\") );\n\t\t\t\treturn this.expressions[ key ];\n\t\t\t}\n\n\t\t\treturn this.computations.hasOwnProperty( key ) ? this.computations[ key ] :\n\t\t\t       Model.prototype.joinKey.call( this, key, opts );\n\t\t};\n\n\t\tRootModel.prototype.map = function map ( localKey, origin ) {\n\t\t\tvar local = this.joinKey( localKey );\n\t\t\tlocal.link( origin );\n\t\t};\n\n\t\tRootModel.prototype.rebinding = function rebinding () {\n\t\t};\n\n\t\tRootModel.prototype.set = function set ( value ) {\n\t\t\t// TODO wrapping root node is a baaaad idea. We should prevent this\n\t\t\tvar wrapper = this.wrapper;\n\t\t\tif ( wrapper ) {\n\t\t\t\tvar shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;\n\n\t\t\t\tif ( shouldTeardown ) {\n\t\t\t\t\twrapper.teardown();\n\t\t\t\t\tthis.wrapper = null;\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.adapt();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.adapt();\n\t\t\t}\n\n\t\t\tthis.deps.forEach( handleChange );\n\t\t\tthis.children.forEach( mark );\n\t\t\tthis.clearUnresolveds(); // TODO do we need to do this with primitive values? if not, what about e.g. unresolved `length` property of null -> string?\n\t\t};\n\n\t\tRootModel.prototype.retrieve = function retrieve () {\n\t\t\treturn this.wrapper ? this.wrapper.get() : this.value;\n\t\t};\n\n\t\tRootModel.prototype.update = function update () {\n\t\t\t// noop\n\t\t};\n\n\t\treturn RootModel;\n\t}(Model));\n\n\tfunction getComputationSignature ( ractive, key, signature ) {\n\t\tvar getter;\n\t\tvar setter;\n\n\t\t// useful for debugging\n\t\tvar getterString;\n\t\tvar getterUseStack;\n\t\tvar setterString;\n\n\t\tif ( typeof signature === 'function' ) {\n\t\t\tgetter = bind( signature, ractive );\n\t\t\tgetterString = signature.toString();\n\t\t\tgetterUseStack = true;\n\t\t}\n\n\t\tif ( typeof signature === 'string' ) {\n\t\t\tgetter = createFunctionFromString( signature, ractive );\n\t\t\tgetterString = signature;\n\t\t}\n\n\t\tif ( typeof signature === 'object' ) {\n\t\t\tif ( typeof signature.get === 'string' ) {\n\t\t\t\tgetter = createFunctionFromString( signature.get, ractive );\n\t\t\t\tgetterString = signature.get;\n\t\t\t} else if ( typeof signature.get === 'function' ) {\n\t\t\t\tgetter = bind( signature.get, ractive );\n\t\t\t\tgetterString = signature.get.toString();\n\t\t\t\tgetterUseStack = true;\n\t\t\t} else {\n\t\t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t\t\t}\n\n\t\t\tif ( typeof signature.set === 'function' ) {\n\t\t\t\tsetter = bind( signature.set, ractive );\n\t\t\t\tsetterString = signature.set.toString();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgetter: getter,\n\t\t\tsetter: setter,\n\t\t\tgetterString: getterString,\n\t\t\tsetterString: setterString,\n\t\t\tgetterUseStack: getterUseStack\n\t\t};\n\t}\n\n\tvar constructHook = new Hook( 'construct' );\n\n\tvar registryNames$1 = [\n\t\t'adaptors',\n\t\t'components',\n\t\t'decorators',\n\t\t'easing',\n\t\t'events',\n\t\t'interpolators',\n\t\t'partials',\n\t\t'transitions'\n\t];\n\n\tvar uid = 0;\n\n\tfunction construct ( ractive, options ) {\n\t\tif ( Ractive.DEBUG ) welcome();\n\n\t\tinitialiseProperties( ractive );\n\n\t\t// TODO remove this, eventually\n\t\tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\n\t\t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\t\tconstructHook.fire( ractive, options );\n\n\t\t// Add registries\n\t\tregistryNames$1.forEach( function ( name ) {\n\t\t\tractive[ name ] = extendObj( create( ractive.constructor[ name ] || null ), options[ name ] );\n\t\t});\n\n\t\t// Create a viewmodel\n\t\tvar viewmodel = new RootModel({\n\t\t\tadapt: getAdaptors( ractive, ractive.adapt, options ),\n\t\t\tdata: dataConfigurator.init( ractive.constructor, ractive, options ),\n\t\t\tractive: ractive\n\t\t});\n\n\t\tractive.viewmodel = viewmodel;\n\n\t\t// Add computed properties\n\t\tvar computed = extendObj( create( ractive.constructor.prototype.computed ), options.computed );\n\n\t\tfor ( var key in computed ) {\n\t\t\tvar signature = getComputationSignature( ractive, key, computed[ key ] );\n\t\t\tviewmodel.compute( key, signature );\n\t\t}\n\t}\n\n\tfunction combine$2 ( arrays ) {\n\t\tvar res = [];\n\t\tvar args = res.concat.apply( res, arrays );\n\n\t\tvar i = args.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( !~res.indexOf( args[i] ) ) {\n\t\t\t\tres.unshift( args[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tfunction getAdaptors ( ractive, protoAdapt, options ) {\n\t\tprotoAdapt = protoAdapt.map( lookup );\n\t\tvar adapt = ensureArray( options.adapt ).map( lookup );\n\n\t\tvar builtins = [];\n\t\tvar srcs = [ protoAdapt, adapt ];\n\t\tif ( ractive.parent && !ractive.isolated ) {\n\t\t\tsrcs.push( ractive.parent.viewmodel.adaptors );\n\t\t}\n\t\tsrcs.push( builtins );\n\n\t\tvar magic = 'magic' in options ? options.magic : ractive.magic;\n\t\tvar modifyArrays = 'modifyArrays' in options ? options.modifyArrays : ractive.modifyArrays;\n\n\t\tif ( magic ) {\n\t\t\tif ( !magicSupported ) {\n\t\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t\t}\n\n\t\t\tif ( modifyArrays ) {\n\t\t\t\tbuiltins.push( magicArrayAdaptor );\n\t\t\t}\n\n\t\t\tbuiltins.push( magicAdaptor$1 );\n\t\t}\n\n\t\tif ( modifyArrays ) {\n\t\t\tbuiltins.push( arrayAdaptor );\n\t\t}\n\n\t\treturn combine$2( srcs );\n\n\n\t\tfunction lookup ( adaptor ) {\n\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n\t\t\t\tif ( !adaptor ) {\n\t\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn adaptor;\n\t\t}\n\t}\n\n\tfunction initialiseProperties ( ractive ) {\n\t\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t\t// existed\n\t\tractive._guid = 'r-' + uid++;\n\n\t\t// events\n\t\tractive._subs = create( null );\n\n\t\t// storage for item configuration from instantiation to reset,\n\t\t// like dynamic functions or original values\n\t\tractive._config = {};\n\n\t\t// nodes registry\n\t\tractive.nodes = {};\n\n\t\t// events\n\t\tractive.event = null;\n\t\tractive._eventQueue = [];\n\n\t\t// live queries\n\t\tractive._liveQueries = [];\n\t\tractive._liveComponentQueries = [];\n\n\t\t// observers\n\t\tractive._observers = [];\n\n\t\tif(!ractive.component){\n\t\t\tractive.root = ractive;\n\t\t\tractive.parent = ractive.container = null; // TODO container still applicable?\n\t\t}\n\n\t}\n\n\tfunction deprecateRactiveData () {\n\t\tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n\t}\n\n\tfunction getChildQueue ( queue, ractive ) {\n\t\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n\t}\n\n\tfunction fire ( hookQueue, ractive ) {\n\t\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n\t\thookQueue.hook.fire( ractive );\n\n\t\t// queue is \"live\" because components can end up being\n\t\t// added while hooks fire on parents that modify data values.\n\t\twhile ( childQueue.length ) {\n\t\t\tfire( hookQueue, childQueue.shift() );\n\t\t}\n\n\t\tdelete hookQueue.queue[ ractive._guid ];\n\t}\n\n\tvar HookQueue = function HookQueue ( event ) {\n\t\tthis.hook = new Hook( event );\n\t\tthis.inProcess = {};\n\t\tthis.queue = {};\n\t};\n\n\tHookQueue.prototype.begin = function begin ( ractive ) {\n\t\tthis.inProcess[ ractive._guid ] = true;\n\t};\n\n\tHookQueue.prototype.end = function end ( ractive ) {\n\t\tvar parent = ractive.parent;\n\n\t\t// If this is *isn't* a child of a component that's in process,\n\t\t// it should call methods or fire at this point\n\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\tfire( this, ractive );\n\t\t}\n\t\t// elsewise, handoff to parent to fire when ready\n\t\telse {\n\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t}\n\n\t\tdelete this.inProcess[ ractive._guid ];\n\t};\n\n\tvar configHook = new Hook( 'config' );\n\tvar initHook = new HookQueue( 'init' );\n\n\tfunction initialise ( ractive, userOptions, options ) {\n\t\tObject.keys( ractive.viewmodel.computations ).forEach( function ( key ) {\n\t\t\tvar computation = ractive.viewmodel.computations[ key ];\n\n\t\t\tif ( ractive.viewmodel.value.hasOwnProperty( key ) ) {\n\t\t\t\tcomputation.set( ractive.viewmodel.value[ key ] );\n\t\t\t}\n\t\t});\n\n\t\t// init config from Parent and options\n\t\tconfig.init( ractive.constructor, ractive, userOptions );\n\n\t\tconfigHook.fire( ractive );\n\t\tinitHook.begin( ractive );\n\n\t\tvar fragment;\n\n\t\t// Render virtual DOM\n\t\tif ( ractive.template ) {\n\t\t\tvar cssIds;\n\n\t\t\tif ( options.cssIds || ractive.cssId ) {\n\t\t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n\t\t\t\tif ( ractive.cssId ) {\n\t\t\t\t\tcssIds.push( ractive.cssId );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tractive.fragment = fragment = new Fragment({\n\t\t\t\towner: ractive,\n\t\t\t\ttemplate: ractive.template,\n\t\t\t\tcssIds: cssIds\n\t\t\t}).bind( ractive.viewmodel );\n\t\t}\n\n\t\tinitHook.end( ractive );\n\n\t\tif ( fragment ) {\n\t\t\t// render automatically ( if `el` is specified )\n\t\t\tvar el = getElement( ractive.el );\n\t\t\tif ( el ) {\n\t\t\t\tvar promise = ractive.render( el, ractive.append );\n\n\t\t\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t\t\t\t\tpromise['catch']( function ( err ) {\n\t\t\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t\t\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive: ractive });\n\t\t\t\t\t\tlogIfDebug( err );\n\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar DOMEvent = function DOMEvent ( name, owner ) {\n\t\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\t\tfatal( (\"Only component proxy-events may contain \\\"*\\\" wildcards, <\" + (owner.name) + \" on-\" + name + \"=\\\"...\\\"/> is not valid\") );\n\t\t}\n\n\t\tthis.name = name;\n\t\tthis.owner = owner;\n\t\tthis.node = null;\n\t\tthis.handler = null;\n\t};\n\n\tDOMEvent.prototype.listen = function listen ( directive ) {\n\t\tvar node = this.node = this.owner.node;\n\t\tvar name = this.name;\n\n\t\tif ( !( (\"on\" + name) in node ) ) {\n\t\t\twarnOnce( missingPlugin( name, 'events' ) );\n\t\t\t}\n\n\t\t\tnode.addEventListener( name, this.handler = function( event ) {\n\t\t\tdirective.fire({\n\t\t\t\t\tnode: node,\n\t\t\t\toriginal: event\n\t\t\t\t});\n\t\t\t}, false );\n\t};\n\n\tDOMEvent.prototype.unlisten = function unlisten () {\n\t\tif ( this.handler ) this.node.removeEventListener( this.name, this.handler, false );\n\t};\n\n\tvar CustomEvent = function CustomEvent ( eventPlugin, owner ) {\n\t\tthis.eventPlugin = eventPlugin;\n\t\tthis.owner = owner;\n\t\tthis.handler = null;\n\t};\n\n\tCustomEvent.prototype.listen = function listen ( directive ) {\n\t\tvar node = this.owner.node;\n\n\t\tthis.handler = this.eventPlugin( node, function ( event ) {\n\t\t\tif ( event === void 0 ) event = {};\n\n\t\t\t\tevent.node = event.node || node;\n\t\t\tdirective.fire( event );\n\t\t});\n\t};\n\n\tCustomEvent.prototype.unlisten = function unlisten () {\n\t\tthis.handler.teardown();\n\t};\n\n\tvar RactiveEvent = function RactiveEvent ( ractive, name ) {\n\t\tthis.ractive = ractive;\n\t\tthis.name = name;\n\t\tthis.handler = null;\n\t};\n\n\tRactiveEvent.prototype.listen = function listen ( directive ) {\n\t\tvar ractive = this.ractive;\n\n\t\tthis.handler = ractive.on( this.name, function () {\n\t\t\tvar event;\n\n\t\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\t\tif ( arguments.length && arguments[0] && arguments[0].node ) {\n\t\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t\t\tevent.component = ractive;\n\t\t\t}\n\n\t\t\tvar args = Array.prototype.slice.call( arguments );\n\t\t\tdirective.fire( event, args );\n\n\t\t\t// cancel bubbling\n\t\t\treturn false;\n\t\t});\n\t};\n\n\tRactiveEvent.prototype.unlisten = function unlisten () {\n\t\tthis.handler.cancel();\n\t};\n\n\tvar specialPattern = /^(event|arguments)(\\..+)?$/;\n\tvar dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\n\tvar EventDirective = function EventDirective ( options ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\tthis.template = options.template;\n\t\tthis.parentFragment = options.parentFragment;\n\t\tthis.ractive = options.parentFragment.ractive;\n\n\t\tthis.events = [];\n\n\t\tif ( this.element.type === COMPONENT ) {\n\t\t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n\t\t\t\tthis$1.events.push( new RactiveEvent( this$1.element.instance, n ) );\n\t\t\t});\n\t\t} else {\n\t\t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n\t\t\t\tvar fn = findInViewHierarchy( 'events', this$1.ractive, n );\n\t\t\t\t// we need to pass in \"this\" in order to get\n\t\t\t\t// access to node when it is created.\n\t\t\t\tthis$1.events.push(fn ? new CustomEvent( fn, this$1.element ) : new DOMEvent( n, this$1.element ));\n\t\t\t});\n\t\t}\n\n\t\tthis.context = null;\n\n\t\t// method calls\n\t\tthis.resolvers = null;\n\t\tthis.models = null;\n\n\t\t// handler directive\n\t\tthis.action = null;\n\t\tthis.args = null;\n\t};\n\n\tEventDirective.prototype.bind = function bind () {\n\t\tvar this$1 = this;\n\n\t\t\tthis.context = this.parentFragment.findContext();\n\n\t\tvar template = this.template.f;\n\n\t\tif ( template.x ) {\n\t\t\tthis.fn = getFunction( template.x.s, template.x.r.length );\n\t\t\tthis.resolvers = [];\n\t\t\tthis.models = template.x.r.map( function ( ref, i ) {\n\t\t\t\tvar specialMatch = specialPattern.exec( ref );\n\t\t\t\tif ( specialMatch ) {\n\t\t\t\t\t// on-click=\"foo(event.node)\"\n\t\t\t\t\treturn {\n\t\t\t\t\t\tspecial: specialMatch[1],\n\t\t\t\t\t\tkeys: specialMatch[2] ? splitKeypathI( specialMatch[2].substr(1) ) : []\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar dollarMatch = dollarArgsPattern.exec( ref );\n\t\t\t\tif ( dollarMatch ) {\n\t\t\t\t\t// on-click=\"foo($1)\"\n\t\t\t\t\treturn {\n\t\t\t\t\t\tspecial: 'arguments',\n\t\t\t\t\t\tkeys: [ dollarMatch[1] - 1 ].concat( dollarMatch[2] ? splitKeypathI( dollarMatch[2].substr( 1 ) ) : [] )\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar resolver;\n\n\t\t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t\t\t\tif ( !model ) {\n\t\t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t\t\t\t\t\tthis$1.models[i] = model;\n\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\tmodel.register( this$1 );\n\t\t\t\t\t});\n\n\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t} else model.register( this$1 );\n\n\t\t\t\treturn model;\n\t\t\t});\n\t\t}\n\n\t\telse {\n\t\t\t// TODO deprecate this style of directive\n\t\t\tthis.action = typeof template === 'string' ? // on-click='foo'\n\t\t\t\ttemplate :\n\t\t\t\ttypeof template.n === 'string' ? // on-click='{{dynamic}}'\n\t\t\t\t\ttemplate.n :\n\t\t\t\t\tnew Fragment({\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\ttemplate: template.n\n\t\t\t\t\t});\n\n\t\t\tthis.args = template.a ? // static arguments\n\t\t\t\t( typeof template.a === 'string' ? [ template.a ] : template.a ) :\n\t\t\t\ttemplate.d ? // dynamic arguments\n\t\t\t\t\tnew Fragment({\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\ttemplate: template.d\n\t\t\t\t\t}) :\n\t\t\t\t\t[]; // no arguments\n\t\t}\n\n\t\tif ( this.action && typeof this.action !== 'string' ) this.action.bind();\n\t\tif ( this.args && template.d ) this.args.bind();\n\t};\n\n\tEventDirective.prototype.bubble = function bubble () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\tthis.owner.bubble();\n\t\t}\n\t};\n\n\tEventDirective.prototype.destroyed = function destroyed () {\n\t\tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n\t};\n\n\tEventDirective.prototype.fire = function fire ( event, passedArgs ) {\n\n\t\t// augment event object\n\t\tif ( passedArgs === void 0 ) passedArgs = [];\n\n\t\t\tif ( event && !event.hasOwnProperty( '_element' ) ) {\n\t\t\t   addHelpers( event, this.owner );\n\t\t}\n\n\t\tif ( this.fn ) {\n\t\t\tvar values = [];\n\n\t\t\tif ( event ) passedArgs.unshift( event );\n\n\t\t\tif ( this.models ) {\n\t\t\t\tthis.models.forEach( function ( model ) {\n\t\t\t\t\tif ( !model ) return values.push( undefined );\n\n\t\t\t\t\tif ( model.special ) {\n\t\t\t\t\t\tvar obj = model.special === 'event' ? event : passedArgs;\n\t\t\t\t\t\tvar keys = model.keys.slice();\n\n\t\t\t\t\t\twhile ( keys.length ) obj = obj[ keys.shift() ];\n\t\t\t\t\t\treturn values.push( obj );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( model.wrapper ) {\n\t\t\t\t\t\treturn values.push( model.wrapperValue );\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues.push( model.get() );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// make event available as `this.event`\n\t\t\tvar ractive = this.ractive;\n\t\t\tvar oldEvent = ractive.event;\n\n\t\t\tractive.event = event;\n\t\t\tvar result = this.fn.apply( ractive, values ).pop();\n\n\t\t\t// Auto prevent and stop if return is explicitly false\n\t\t\tif ( result === false ) {\n\t\t\t\tvar original = event ? event.original : undefined;\n\t\t\t\tif ( original ) {\n\t\t\t\t\toriginal.preventDefault && original.preventDefault();\n\t\t\t\t\toriginal.stopPropagation && original.stopPropagation();\n\t\t\t\t} else {\n\t\t\t\t\twarnOnceIfDebug( (\"handler '\" + (this.template.n) + \"' returned false, but there is no event available to cancel\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tractive.event = oldEvent;\n\t\t}\n\n\t\telse {\n\t\t\tvar action = this.action.toString();\n\t\t\tvar args = this.template.f.d ? this.args.getArgsList() : this.args;\n\n\t\t\tif ( passedArgs.length ) args = args.concat( passedArgs );\n\n\t\t\tif ( event ) event.name = action;\n\n\t\t\tfireEvent( this.ractive, action, {\n\t\t\t\tevent: event,\n\t\t\t\targs: args\n\t\t\t});\n\t\t}\n\t};\n\n\tEventDirective.prototype.handleChange = function handleChange () {};\n\n\tEventDirective.prototype.rebinding = function rebinding ( next, previous ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( !this.models ) return;\n\t\tvar idx = this.models.indexOf( previous );\n\n\t\tif ( ~idx ) {\n\t\t\tthis.models.splice( idx, 1, next );\n\t\t\tprevious.unregister( this );\n\t\t\tif ( next ) next.addShuffleTask( function () { return next.register( this$1 ); } );\n\t\t}\n\t};\n\n\tEventDirective.prototype.render = function render () {\n\t\t// render events after everything else, so they fire after bindings\n\t\tvar this$1 = this;\n\n\t\t\trunloop.scheduleTask( function () { return this$1.events.forEach( function ( e ) { return e.listen( this$1 ); }, true ); } );\n\t};\n\n\tEventDirective.prototype.toString = function toString() { return ''; };\n\n\tEventDirective.prototype.unbind = function unbind$1 () {\n\t\tvar this$1 = this;\n\n\t\t\tvar template = this.template.f;\n\n\t\tif ( template.m ) {\n\t\t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t\t\tthis.resolvers = [];\n\n\t\t\tif ( this.models ) this.models.forEach( function ( m ) {\n\t\t\t\tif ( m.unregister ) m.unregister( this$1 );\n\t\t\t});\n\t\t\tthis.models = null;\n\t\t}\n\n\t\telse {\n\t\t\t// TODO this is brittle and non-explicit, fix it\n\t\t\tif ( this.action && this.action.unbind ) this.action.unbind();\n\t\t\tif ( this.args && this.args.unbind ) this.args.unbind();\n\t\t}\n\t};\n\n\tEventDirective.prototype.unrender = function unrender () {\n\t\tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n\t};\n\n\tEventDirective.prototype.update = function update () {\n\t\tif ( this.method || !this.dirty ) return; // nothing to do\n\n\t\tthis.dirty = false;\n\n\t\t// ugh legacy\n\t\tif ( this.action && this.action.update ) this.action.update();\n\t\tif ( this.args && this.args.update ) this.args.update();\n\t};\n\n\t// TODO it's unfortunate that this has to run every time a\n\t// component is rendered... is there a better way?\n\tfunction updateLiveQueries ( component ) {\n\t\t// Does this need to be added to any live queries?\n\t\tvar instance = component.ractive;\n\n\t\tdo {\n\t\t\tvar liveQueries = instance._liveComponentQueries;\n\n\t\t\tvar i = liveQueries.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar name = liveQueries[i];\n\t\t\t\tvar query = liveQueries[ (\"_\" + name) ];\n\n\t\t\t\tif ( query.test( component ) ) {\n\t\t\t\t\tquery.add( component.instance );\n\t\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t\tcomponent.liveQueries.push( query );\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( instance = instance.parent );\n\t}\n\n\tfunction removeFromLiveComponentQueries ( component ) {\n\t\tvar instance = component.ractive;\n\n\t\twhile ( instance ) {\n\t\t\tvar query = instance._liveComponentQueries[ (\"_\" + (component.name)) ];\n\t\t\tif ( query ) query.remove( component );\n\n\t\t\tinstance = instance.parent;\n\t\t}\n\t}\n\n\tfunction makeDirty ( query ) {\n\t\tquery.makeDirty();\n\t}\n\n\tvar teardownHook = new Hook( 'teardown' );\n\n\tvar Component = (function (Item) {\n\t\tfunction Component ( options, ComponentConstructor ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tItem.call( this, options );\n\t\t\tthis.type = COMPONENT; // override ELEMENT from super\n\n\t\t\tvar instance = create( ComponentConstructor.prototype );\n\n\t\t\tthis.instance = instance;\n\t\t\tthis.name = options.template.e;\n\t\t\tthis.parentFragment = options.parentFragment;\n\n\t\t\tthis.liveQueries = [];\n\n\t\t\tif ( instance.el ) {\n\t\t\t\twarnIfDebug( (\"The <\" + (this.name) + \"> component has a default 'el' property; it has been disregarded\") );\n\t\t\t}\n\n\t\t\tvar partials = options.template.p || {};\n\t\t\tif ( !( 'content' in partials ) ) partials.content = options.template.f || [];\n\t\t\tthis._partials = partials; // TEMP\n\n\t\t\tthis.yielders = {};\n\n\t\t\t// find container\n\t\t\tvar fragment = options.parentFragment;\n\t\t\tvar container;\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\t\t\tcontainer = fragment.owner.container;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfragment = fragment.parent;\n\t\t\t}\n\n\t\t\t// add component-instance-specific properties\n\t\t\tinstance.parent = this.parentFragment.ractive;\n\t\t\tinstance.container = container || null;\n\t\t\tinstance.root = instance.parent.root;\n\t\t\tinstance.component = this;\n\n\t\t\tconstruct( this.instance, { partials: partials });\n\n\t\t\t// for hackability, this could be an open option\n\t\t\t// for any ractive instance, but for now, just\n\t\t\t// for components and just for ractive...\n\t\t\tinstance._inlinePartials = partials;\n\n\t\t\tthis.attributeByName = {};\n\n\t\t\tthis.attributes = [];\n\t\t\tvar leftovers = [];\n\t\t\t( this.template.m || [] ).forEach( function ( template ) {\n\t\t\t\tswitch ( template.t ) {\n\t\t\t\t\tcase ATTRIBUTE:\n\t\t\t\t\tcase EVENT:\n\t\t\t\t\tcase TRANSITION:\n\t\t\t\t\t\tthis$1.attributes.push( createItem({\n\t\t\t\t\t\t\towner: this$1,\n\t\t\t\t\t\t\tparentFragment: this$1.parentFragment,\n\t\t\t\t\t\t\ttemplate: template\n\t\t\t\t\t\t}) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase BINDING_FLAG:\n\t\t\t\t\tcase DECORATOR:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tleftovers.push( template );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.attributes.push( new ConditionalAttribute({\n\t\t\t\towner: this,\n\t\t\t\tparentFragment: this.parentFragment,\n\t\t\t\ttemplate: leftovers\n\t\t\t}) );\n\n\t\t\tthis.eventHandlers = [];\n\t\t\tif ( this.template.v ) this.setupEvents();\n\t\t}\n\n\t\tComponent.prototype = Object.create( Item && Item.prototype );\n\t\tComponent.prototype.constructor = Component;\n\n\t\tComponent.prototype.bind = function bind$1$$ () {\n\t\t\tthis.attributes.forEach( bind$1 );\n\n\t\t\tinitialise( this.instance, {\n\t\t\t\tpartials: this._partials\n\t\t\t}, {\n\t\t\t\tcssIds: this.parentFragment.cssIds\n\t\t\t});\n\n\t\t\tthis.eventHandlers.forEach( bind$1 );\n\n\t\t\tthis.bound = true;\n\t\t};\n\n\t\tComponent.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t}\n\t\t};\n\n\t\tComponent.prototype.checkYielders = function checkYielders () {\n\t\t\tvar this$1 = this;\n\n\t\t\tObject.keys( this.yielders ).forEach( function ( name ) {\n\t\t\t\tif ( this$1.yielders[ name ].length > 1 ) {\n\t\t\t\t\trunloop.end();\n\t\t\t\t\tthrow new Error( (\"A component template can only have one {{yield\" + (name ? ' ' + name : '') + \"}} declaration at a time\") );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tComponent.prototype.destroyed = function destroyed () {\n\t\t\tif ( this.instance.fragment ) this.instance.fragment.destroyed();\n\t\t};\n\n\t\tComponent.prototype.detach = function detach () {\n\t\t\treturn this.instance.fragment.detach();\n\t\t};\n\n\t\tComponent.prototype.find = function find ( selector ) {\n\t\t\treturn this.instance.fragment.find( selector );\n\t\t};\n\n\t\tComponent.prototype.findAll = function findAll ( selector, query ) {\n\t\t\tthis.instance.fragment.findAll( selector, query );\n\t\t};\n\n\t\tComponent.prototype.findComponent = function findComponent ( name ) {\n\t\t\tif ( !name || this.name === name ) return this.instance;\n\n\t\t\tif ( this.instance.fragment ) {\n\t\t\t\treturn this.instance.fragment.findComponent( name );\n\t\t\t}\n\t\t};\n\n\t\tComponent.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\tif ( query.test( this ) ) {\n\t\t\t\tquery.add( this.instance );\n\n\t\t\t\tif ( query.live ) {\n\t\t\t\t\tthis.liveQueries.push( query );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.instance.fragment.findAllComponents( name, query );\n\t\t};\n\n\t\tComponent.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\treturn this.instance.fragment.firstNode( skipParent );\n\t\t};\n\n\t\tComponent.prototype.render = function render$1$$ ( target, occupants ) {\n\t\t\trender$1( this.instance, target, null, occupants );\n\n\t\t\tthis.checkYielders();\n\t\t\tthis.attributes.forEach( render );\n\t\t\tthis.eventHandlers.forEach( render );\n\t\t\tupdateLiveQueries( this );\n\n\t\t\tthis.rendered = true;\n\t\t};\n\n\t\tComponent.prototype.setupEvents = function setupEvents () {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar handlers = this.eventHandlers;\n\n\t\t\tObject.keys( this.template.v ).forEach( function ( key ) {\n\t\t\t\tvar eventNames = key.split( '-' );\n\t\t\t\tvar template = this$1.template.v[ key ];\n\n\t\t\t\teventNames.forEach( function ( eventName ) {\n\t\t\t\t\tvar event = new RactiveEvent( this$1.instance, eventName );\n\t\t\t\t\thandlers.push( new EventDirective( this$1, event, template ) );\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tComponent.prototype.shuffled = function shuffled () {\n\t\t\tthis.liveQueries.forEach( makeDirty );\n\t\t\tItem.prototype.shuffled.call(this);\n\t\t};\n\n\t\tComponent.prototype.toString = function toString () {\n\t\t\treturn this.instance.toHTML();\n\t\t};\n\n\t\tComponent.prototype.unbind = function unbind$1 () {\n\t\t\tthis.bound = false;\n\n\t\t\tthis.attributes.forEach( unbind );\n\n\t\t\tvar instance = this.instance;\n\t\t\tinstance.viewmodel.teardown();\n\t\t\tinstance.fragment.unbind();\n\t\t\tinstance._observers.forEach( cancel );\n\n\t\t\tremoveFromLiveComponentQueries( this );\n\n\t\t\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\t\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t\t\t}\n\n\t\t\tteardownHook.fire( instance );\n\t\t};\n\n\t\tComponent.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tthis.rendered = false;\n\n\t\t\tthis.shouldDestroy = shouldDestroy;\n\t\t\tthis.instance.unrender();\n\t\t\tthis.attributes.forEach( unrender );\n\t\t\tthis.eventHandlers.forEach( unrender );\n\t\t\tthis.liveQueries.forEach( function ( query ) { return query.remove( this$1.instance ); } );\n\t\t};\n\n\t\tComponent.prototype.update = function update$1 () {\n\t\t\tthis.dirty = false;\n\t\t\tthis.instance.fragment.update();\n\t\t\tthis.checkYielders();\n\t\t\tthis.attributes.forEach( update );\n\t\t\tthis.eventHandlers.forEach( update );\n\t\t};\n\n\t\treturn Component;\n\t}(Item));\n\n\tvar missingDecorator = {\n\t\tupdate: noop,\n\t\tteardown: noop\n\t};\n\n\tvar Decorator = function Decorator ( options ) {\n\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\tthis.parentFragment = this.owner.parentFragment;\n\t\tthis.ractive = this.owner.ractive;\n\t\tvar template = this.template = options.template;\n\n\t\tthis.dynamicName = typeof template.f.n === 'object';\n\t\tthis.dynamicArgs = !!template.f.d;\n\n\t\tif ( this.dynamicName ) {\n\t\t\tthis.nameFragment = new Fragment({\n\t\t\t\towner: this,\n\t\t\t\ttemplate: template.f.n\n\t\t\t});\n\t\t} else {\n\t\t\tthis.name = template.f.n || template.f;\n\t\t}\n\n\t\tif ( this.dynamicArgs ) {\n\t\t\tthis.argsFragment = new Fragment({\n\t\t\t\towner: this,\n\t\t\t\ttemplate: template.f.d\n\t\t\t});\n\t\t} else {\n\t\t\tif ( template.f.a && template.f.a.s ) {\n\t\t\t\tthis.args = [];\n\t\t\t} else {\n\t\t\t\tthis.args = template.f.a || [];\n\t\t\t}\n\t\t}\n\n\t\tthis.node = null;\n\t\tthis.intermediary = null;\n\n\t\tthis.element.decorators.push( this );\n\t};\n\n\tDecorator.prototype.bind = function bind () {\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.dynamicName ) {\n\t\t\tthis.nameFragment.bind();\n\t\t\tthis.name = this.nameFragment.toString();\n\t\t}\n\n\t\tif ( this.dynamicArgs ) this.argsFragment.bind();\n\n\t\t// TODO: dry this up once deprecation is done\n\t\tif ( this.template.f.a && this.template.f.a.s ) {\n\t\t\tthis.resolvers = [];\n\t\t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n\t\t\t\tvar resolver;\n\t\t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t\t\t\tif ( !model ) {\n\t\t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t\t\t\t\t\tthis$1.models[i] = model;\n\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\tmodel.register( this$1 );\n\t\t\t\t\t});\n\n\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t} else model.register( this$1 );\n\n\t\t\t\treturn model;\n\t\t\t});\n\t\t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n\t\t}\n\t};\n\n\tDecorator.prototype.bubble = function bubble () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\tthis.owner.bubble();\n\t\t}\n\t};\n\n\tDecorator.prototype.destroyed = function destroyed () {\n\t\tif ( this.intermediary ) this.intermediary.teardown();\n\t\tthis.shouldDestroy = true;\n\t};\n\n\tDecorator.prototype.handleChange = function handleChange () { this.bubble(); };\n\n\tDecorator.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\tvar idx = this.models.indexOf( previous );\n\t\tif ( !~idx ) return;\n\n\t\tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n\t\tif ( next === previous ) return;\n\n\t\tprevious.unregister( this );\n\t\tthis.models.splice( idx, 1, next );\n\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\n\t\tif ( !safe ) this.bubble();\n\t};\n\n\tDecorator.prototype.render = function render () {\n\t\tvar this$1 = this;\n\n\t\t\trunloop.scheduleTask( function () {\n\t\t\tvar fn = findInViewHierarchy( 'decorators', this$1.ractive, this$1.name );\n\n\t\t\tif ( !fn ) {\n\t\t\t\twarnOnce( missingPlugin( this$1.name, 'decorator' ) );\n\t\t\t\tthis$1.intermediary = missingDecorator;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis$1.node = this$1.element.node;\n\n\t\t\tvar args;\n\t\t\tif ( this$1.argsFn ) {\n\t\t\t\targs = this$1.models.map( function ( model ) {\n\t\t\t\t\tif ( !model ) return undefined;\n\n\t\t\t\t\treturn model.get();\n\t\t\t\t});\n\t\t\t\targs = this$1.argsFn.apply( this$1.ractive, args );\n\t\t\t} else {\n\t\t\t\targs = this$1.dynamicArgs ? this$1.argsFragment.getArgsList() : this$1.args;\n\t\t\t}\n\n\t\t\tthis$1.intermediary = fn.apply( this$1.ractive, [ this$1.node ].concat( args ) );\n\n\t\t\tif ( !this$1.intermediary || !this$1.intermediary.teardown ) {\n\t\t\t\tthrow new Error( (\"The '\" + (this$1.name) + \"' decorator must return an object with a teardown method\") );\n\t\t\t}\n\n\t\t\t// watch out for decorators that cause their host element to be unrendered\n\t\t\tif ( this$1.shouldDestroy ) this$1.destroyed();\n\t\t}, true );\n\t\tthis.rendered = true;\n\t};\n\n\tDecorator.prototype.toString = function toString () { return ''; };\n\n\tDecorator.prototype.unbind = function unbind$1 () {\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.dynamicName ) this.nameFragment.unbind();\n\t\tif ( this.dynamicArgs ) this.argsFragment.unbind();\n\t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t\tif ( this.models ) this.models.forEach( function ( m ) {\n\t\t\tif ( m ) m.unregister( this$1 );\n\t\t});\n\t};\n\n\tDecorator.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\tif ( ( !shouldDestroy || this.element.rendered ) && this.intermediary ) this.intermediary.teardown();\n\t\tthis.rendered = false;\n\t};\n\n\tDecorator.prototype.update = function update () {\n\t\tif ( !this.dirty ) return;\n\n\t\tthis.dirty = false;\n\n\t\tvar nameChanged = false;\n\n\t\tif ( this.dynamicName && this.nameFragment.dirty ) {\n\t\t\tvar name = this.nameFragment.toString();\n\t\t\tnameChanged = name !== this.name;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tif ( this.intermediary ) {\n\t\t\tif ( nameChanged || !this.intermediary.update ) {\n\t\t\t\tthis.unrender();\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( this.dynamicArgs ) {\n\t\t\t\t\tif ( this.argsFragment.dirty ) {\n\t\t\t\t\t\tvar args = this.argsFragment.getArgsList();\n\t\t\t\t\t\tthis.intermediary.update.apply( this.ractive, args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( this.argsFn ) {\n\t\t\t\t\tvar args$1 = this.models.map( function ( model ) {\n\t\t\t\t\t\tif ( !model ) return undefined;\n\n\t\t\t\t\t\treturn model.get();\n\t\t\t\t\t});\n\t\t\t\t\tthis.intermediary.update.apply( this.ractive, this.argsFn.apply( this.ractive, args$1 ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.intermediary.update.apply( this.ractive, this.args );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// need to run these for unrender/render cases\n\t\t// so can't just be in conditional if above\n\n\t\tif ( this.dynamicName && this.nameFragment.dirty ) {\n\t\t\tthis.nameFragment.update();\n\t\t}\n\n\t\tif ( this.dynamicArgs && this.argsFragment.dirty ) {\n\t\t\tthis.argsFragment.update();\n\t\t}\n\t};\n\n\tvar Doctype = (function (Item) {\n\t\tfunction Doctype () {\n\t\t\tItem.apply(this, arguments);\n\t\t}\n\n\t\tDoctype.prototype = Object.create( Item && Item.prototype );\n\t\tDoctype.prototype.constructor = Doctype;\n\n\t\tDoctype.prototype.bind = function bind () {\n\t\t\t// noop\n\t\t};\n\n\t\tDoctype.prototype.render = function render () {\n\t\t\t// noop\n\t\t};\n\n\t\tDoctype.prototype.teardown = function teardown () {\n\t\t\t// noop\n\t\t};\n\n\t\tDoctype.prototype.toString = function toString () {\n\t\t\treturn '<!DOCTYPE' + this.template.a + '>';\n\t\t};\n\n\t\tDoctype.prototype.unbind = function unbind () {\n\t\t\t// noop\n\t\t};\n\n\t\tDoctype.prototype.unrender = function unrender () {\n\t\t\t// noop\n\t\t};\n\n\t\tDoctype.prototype.update = function update () {\n\t\t\t// noop\n\t\t};\n\n\t\treturn Doctype;\n\t}(Item));\n\n\tfunction updateLiveQueries$1 ( element ) {\n\t\t// Does this need to be added to any live queries?\n\t\tvar node = element.node;\n\t\tvar instance = element.ractive;\n\n\t\tdo {\n\t\t\tvar liveQueries = instance._liveQueries;\n\n\t\t\tvar i = liveQueries.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar selector = liveQueries[i];\n\t\t\t\tvar query = liveQueries[ (\"_\" + selector) ];\n\n\t\t\t\tif ( query.test( node ) ) {\n\t\t\t\t\tquery.add( node );\n\t\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t\telement.liveQueries.push( query );\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( instance = instance.parent );\n\t}\n\n\tfunction warnAboutAmbiguity ( description, ractive ) {\n\t\twarnOnceIfDebug( (\"The \" + description + \" being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: ractive });\n\t}\n\n\tvar Binding = function Binding ( element, name ) {\n\t\tif ( name === void 0 ) name = 'value';\n\n\t\t\tthis.element = element;\n\t\tthis.ractive = element.ractive;\n\t\tthis.attribute = element.attributeByName[ name ];\n\n\t\tvar interpolator = this.attribute.interpolator;\n\t\tinterpolator.twowayBinding = this;\n\n\t\tvar model = interpolator.model;\n\n\t\t// not bound?\n\t\tif ( !model ) {\n\t\t\t// try to force resolution\n\t\t\tinterpolator.resolver.forceResolution();\n\t\t\tmodel = interpolator.model;\n\n\t\t\twarnAboutAmbiguity( (\"'\" + (interpolator.template.r) + \"' reference\"), this.ractive );\n\t\t\t}\n\n\t\t\telse if ( model.isUnresolved ) {\n\t\t\t\t// reference expressions (e.g. foo[bar])\n\t\t\t\tmodel.forceResolution();\n\t\t\t\twarnAboutAmbiguity( 'expression', this.ractive );\n\t\t}\n\n\t\t// TODO include index/key/keypath refs as read-only\n\t\telse if ( model.isReadonly ) {\n\t\t\tvar keypath = model.getKeypath().replace( /^@/, '' );\n\t\t\twarnOnceIfDebug( (\"Cannot use two-way binding on <\" + (element.name) + \"> element: \" + keypath + \" is read-only. To suppress this warning use <\" + (element.name) + \" twoway='false'...>\"), { ractive: this.ractive });\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.attribute.isTwoway = true;\n\t\tthis.model = model;\n\n\t\t// initialise value, if it's undefined\n\t\tvar value = model.get();\n\t\tthis.wasUndefined = value === undefined;\n\n\t\tif ( value === undefined && this.getInitialValue ) {\n\t\t\tvalue = this.getInitialValue();\n\t\t\tmodel.set( value );\n\t\t}\n\t\tthis.lastVal( true, value );\n\n\t\tvar parentForm = findElement( this.element, false, 'form' );\n\t\tif ( parentForm ) {\n\t\t\tthis.resetValue = value;\n\t\t\tparentForm.formBindings.push( this );\n\t\t}\n\t};\n\n\tBinding.prototype.bind = function bind () {\n\t\tthis.model.registerTwowayBinding( this );\n\t};\n\n\tBinding.prototype.handleChange = function handleChange () {\n\t\tvar this$1 = this;\n\n\t\t\tvar value = this.getValue();\n\t\tif ( this.lastVal() === value ) return;\n\n\t\trunloop.start( this.root );\n\t\tthis.attribute.locked = true;\n\t\tthis.model.set( value );\n\t\tthis.lastVal( true, value );\n\n\t\t// if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n\t\tif ( this.model.get() !== value ) this.attribute.locked = false;\n\t\telse runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\n\t\trunloop.end();\n\t};\n\n\tBinding.prototype.lastVal = function lastVal ( setting, value ) {\n\t\tif ( setting ) this.lastValue = value;\n\t\telse return this.lastValue;\n\t};\n\n\tBinding.prototype.rebinding = function rebinding ( next, previous ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.model && this.model === previous ) previous.unregisterTwowayBinding( this );\n\t\tif ( next ) {\n\t\t\tthis.model = next;\n\t\t\trunloop.scheduleTask( function () { return next.registerTwowayBinding( this$1 ); } );\n\t\t}\n\t};\n\n\tBinding.prototype.render = function render () {\n\t\tthis.node = this.element.node;\n\t\tthis.node._ractive.binding = this;\n\t\tthis.rendered = true; // TODO is this used anywhere?\n\t};\n\n\t\tBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tthis.model.set( node.value );\n\t};\n\n\tBinding.prototype.unbind = function unbind () {\n\t\tthis.model.unregisterTwowayBinding( this );\n\t};\n\n\tBinding.prototype.unrender = function unrender () {\n\t\t\t// noop?\n\t\t};\n\n\t// This is the handler for DOM events that would lead to a change in the model\n\t// (i.e. change, sometimes, input, and occasionally click and keyup)\n\tfunction handleDomEvent () {\n\t\tthis._ractive.binding.handleChange();\n\t}\n\n\tvar CheckboxBinding = (function (Binding) {\n\t\tfunction CheckboxBinding ( element ) {\n\t\t\tBinding.call( this, element, 'checked' );\n\t\t}\n\n\t\tCheckboxBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tCheckboxBinding.prototype.constructor = CheckboxBinding;\n\n\t\tCheckboxBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\n\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\t\tif ( this.node.attachEvent ) {\n\t\t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n\t\t\t}\n\t\t};\n\n\t\tCheckboxBinding.prototype.unrender = function unrender () {\n\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n\t\t};\n\n\t\tCheckboxBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\treturn !!this.element.getAttribute( 'checked' );\n\t\t};\n\n\t\tCheckboxBinding.prototype.getValue = function getValue () {\n\t\t\treturn this.node.checked;\n\t\t};\n\n\t\tCheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tthis.model.set( node.checked );\n\t\t};\n\n\t\treturn CheckboxBinding;\n\t}(Binding));\n\n\tfunction getBindingGroup ( group, model, getValue ) {\n\t\tvar hash = \"\" + group + \"-bindingGroup\";\n\t\treturn model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) );\n\t}\n\n\tvar BindingGroup = function BindingGroup ( hash, model, getValue ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.model = model;\n\t\tthis.hash = hash;\n\t\tthis.getValue = function () {\n\t\t\tthis$1.value = getValue.call(this$1);\n\t\t\treturn this$1.value;\n\t\t};\n\n\t\tthis.bindings = [];\n\t};\n\n\tBindingGroup.prototype.add = function add ( binding ) {\n\t\tthis.bindings.push( binding );\n\t};\n\n\tBindingGroup.prototype.bind = function bind () {\n\t\tthis.value = this.model.get();\n\t\tthis.model.registerTwowayBinding( this );\n\t\tthis.bound = true;\n\t};\n\n\tBindingGroup.prototype.remove = function remove ( binding ) {\n\t\tremoveFromArray( this.bindings, binding );\n\t\tif ( !this.bindings.length ) {\n\t\t\tthis.unbind();\n\t\t}\n\t};\n\n\tBindingGroup.prototype.unbind = function unbind () {\n\t\tthis.model.unregisterTwowayBinding( this );\n\t\tthis.bound = false;\n\t\tdelete this.model[this.hash];\n\t};\n\n\tvar push$2 = [].push;\n\n\tfunction getValue() {\n\t\tvar all = this.bindings.filter(function ( b ) { return b.node && b.node.checked; }).map(function ( b ) { return b.element.getAttribute( 'value' ); });\n\t\tvar res = [];\n\t\tall.forEach(function ( v ) { if ( !arrayContains( res, v ) ) res.push( v ); });\n\t\treturn res;\n\t}\n\n\tvar CheckboxNameBinding = (function (Binding) {\n\t\tfunction CheckboxNameBinding ( element ) {\n\t\t\tBinding.call( this, element, 'name' );\n\n\t\t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n\t\t\t// Each input has a reference to an array containing it and its\n\t\t\t// group, as two-way binding depends on being able to ascertain\n\t\t\t// the status of all inputs within the group\n\t\t\tthis.group = getBindingGroup( 'checkboxes', this.model, getValue );\n\t\t\tthis.group.add( this );\n\n\t\t\tif ( this.noInitialValue ) {\n\t\t\t\tthis.group.noInitialValue = true;\n\t\t\t}\n\n\t\t\t// If no initial value was set, and this input is checked, we\n\t\t\t// update the model\n\t\t\tif ( this.group.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\t\tvar existingValue = this.model.get();\n\t\t\t\tvar bindingValue = this.element.getAttribute( 'value' );\n\n\t\t\t\tif ( !arrayContains( existingValue, bindingValue ) ) {\n\t\t\t\t\tpush$2.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tCheckboxNameBinding.prototype.constructor = CheckboxNameBinding;\n\n\t\tCheckboxNameBinding.prototype.bind = function bind () {\n\t\t\tif ( !this.group.bound ) {\n\t\t\t\tthis.group.bind();\n\t\t\t}\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.changed = function changed () {\n\t\t\tvar wasChecked = !!this.isChecked;\n\t\t\tthis.isChecked = this.node.checked;\n\t\t\treturn this.isChecked === wasChecked;\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\t// This only gets called once per group (of inputs that\n\t\t\t// share a name), because it only gets called if there\n\t\t\t// isn't an initial value. By the same token, we can make\n\t\t\t// a note of that fact that there was no initial value,\n\t\t\t// and populate it using any `checked` attributes that\n\t\t\t// exist (which users should avoid, but which we should\n\t\t\t// support anyway to avoid breaking expectations)\n\t\t\tthis.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n\t\t\treturn [];\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.getValue = function getValue$1 () {\n\t\t\treturn this.group.value;\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.handleChange = function handleChange () {\n\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\tthis.group.value = this.model.get();\n\t\t\tvar value = this.element.getAttribute( 'value' );\n\t\t\tif ( this.isChecked && !arrayContains( this.group.value, value ) ) {\n\t\t\t\tthis.group.value.push( value );\n\t\t\t} else if ( !this.isChecked && arrayContains( this.group.value, value ) ) {\n\t\t\t\tremoveFromArray( this.group.value, value );\n\t\t\t}\n\t\t\t// make sure super knows there's a change\n\t\t\tthis.lastValue = null;\n\t\t\tBinding.prototype.handleChange.call(this);\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\n\t\t\tvar node = this.node;\n\n\t\t\tvar existingValue = this.model.get();\n\t\t\tvar bindingValue = this.element.getAttribute( 'value' );\n\n\t\t\tif ( isArray( existingValue ) ) {\n\t\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t\t} else {\n\t\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t\t}\n\n\t\t\tnode.name = '{{' + this.model.getKeypath() + '}}';\n\t\t\tnode.checked = this.isChecked;\n\n\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t\t// in case of IE emergency, bind to click event as well\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t}\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tthis.group.bindings.forEach( function ( binding ) { return binding.wasUndefined = true; } );\n\n\t\t\tif ( node.checked ) {\n\t\t\t\tvar valueSoFar = this.group.getValue();\n\t\t\t\tvalueSoFar.push( this.element.getAttribute( 'value' ) );\n\n\t\t\t\tthis.group.model.set( valueSoFar );\n\t\t\t}\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.unbind = function unbind () {\n\t\t\tthis.group.remove( this );\n\t\t};\n\n\t\tCheckboxNameBinding.prototype.unrender = function unrender () {\n\t\t\tvar node = this.element.node;\n\n\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t};\n\n\t\treturn CheckboxNameBinding;\n\t}(Binding));\n\n\tvar ContentEditableBinding = (function (Binding) {\n\t\tfunction ContentEditableBinding () {\n\t\t\tBinding.apply(this, arguments);\n\t\t}\n\n\t\tContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tContentEditableBinding.prototype.constructor = ContentEditableBinding;\n\n\t\tContentEditableBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t\t};\n\n\t\tContentEditableBinding.prototype.getValue = function getValue () {\n\t\t\treturn this.element.node.innerHTML;\n\t\t};\n\n\t\tContentEditableBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\n\t\t\tvar node = this.node;\n\n\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\tnode.addEventListener( 'blur', handleDomEvent, false );\n\n\t\t\tif ( !this.ractive.lazy ) {\n\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tthis.model.set( node.innerHTML );\n\t\t};\n\n\t\tContentEditableBinding.prototype.unrender = function unrender () {\n\t\t\tvar node = this.node;\n\n\t\t\tnode.removeEventListener( 'blur', handleDomEvent, false );\n\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t};\n\n\t\treturn ContentEditableBinding;\n\t}(Binding));\n\n\tfunction handleBlur () {\n\t\thandleDomEvent.call( this );\n\n\t\tvar value = this._ractive.binding.model.get();\n\t\tthis.value = value == undefined ? '' : value;\n\t}\n\n\tfunction handleDelay ( delay ) {\n\t\tvar timeout;\n\n\t\treturn function () {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( timeout ) clearTimeout( timeout );\n\n\t\t\ttimeout = setTimeout( function () {\n\t\t\t\tvar binding = this$1._ractive.binding;\n\t\t\t\tif ( binding.rendered ) handleDomEvent.call( this$1 );\n\t\t\t\ttimeout = null;\n\t\t\t}, delay );\n\t\t};\n\t}\n\n\tvar GenericBinding = (function (Binding) {\n\t\tfunction GenericBinding () {\n\t\t\tBinding.apply(this, arguments);\n\t\t}\n\n\t\tGenericBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tGenericBinding.prototype.constructor = GenericBinding;\n\n\t\tGenericBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\treturn '';\n\t\t};\n\n\t\tGenericBinding.prototype.getValue = function getValue () {\n\t\t\treturn this.node.value;\n\t\t};\n\n\t\tGenericBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\n\t\t\t// any lazy setting for this element overrides the root\n\t\t\t// if the value is a number, it's a timeout\n\t\t\tvar lazy = this.ractive.lazy;\n\t\t\tvar timeout = false;\n\n\t\t\tif ( 'lazy' in this.element ) {\n\t\t\t\tlazy = this.element.lazy;\n\t\t\t}\n\n\t\t\tif ( isNumeric( lazy ) ) {\n\t\t\t\ttimeout = +lazy;\n\t\t\t\tlazy = false;\n\t\t\t}\n\n\t\t\tthis.handler = timeout ? handleDelay( timeout ) : handleDomEvent;\n\n\t\t\tvar node = this.node;\n\n\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t\tif ( !lazy ) {\n\t\t\t\tnode.addEventListener( 'input', this.handler, false );\n\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t\t};\n\n\t\tGenericBinding.prototype.unrender = function unrender () {\n\t\t\tvar node = this.element.node;\n\t\t\tthis.rendered = false;\n\n\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\tnode.removeEventListener( 'input', this.handler, false );\n\t\t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t\t};\n\n\t\treturn GenericBinding;\n\t}(Binding));\n\n\tvar FileBinding = (function (GenericBinding) {\n\t\tfunction FileBinding () {\n\t\t\tGenericBinding.apply(this, arguments);\n\t\t}\n\n\t\tFileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n\t\tFileBinding.prototype.constructor = FileBinding;\n\n\t\tFileBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\treturn undefined;\n\t\t};\n\n\t\tFileBinding.prototype.getValue = function getValue () {\n\t\t\treturn this.node.files;\n\t\t};\n\n\t\tFileBinding.prototype.render = function render () {\n\t\t\tthis.element.lazy = false;\n\t\t\tGenericBinding.prototype.render.call(this);\n\t\t};\n\n\t\tFileBinding.prototype.setFromNode = function setFromNode( node ) {\n\t\t\tthis.model.set( node.files );\n\t\t};\n\n\t\treturn FileBinding;\n\t}(GenericBinding));\n\n\tfunction getSelectedOptions ( select ) {\n\t    return select.selectedOptions\n\t\t\t? toArray( select.selectedOptions )\n\t\t\t: select.options\n\t\t\t\t? toArray( select.options ).filter( function ( option ) { return option.selected; } )\n\t\t\t\t: [];\n\t}\n\n\tvar MultipleSelectBinding = (function (Binding) {\n\t\tfunction MultipleSelectBinding () {\n\t\t\tBinding.apply(this, arguments);\n\t\t}\n\n\t\tMultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tMultipleSelectBinding.prototype.constructor = MultipleSelectBinding;\n\n\t\tMultipleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar value = this.getValue();\n\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tthis.attribute.locked = true;\n\t\t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t\t\t\tthis.model.set( value );\n\t\t\t}\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\treturn this.element.options\n\t\t\t\t.filter( function ( option ) { return option.getAttribute( 'selected' ); } )\n\t\t\t\t.map( function ( option ) { return option.getAttribute( 'value' ); } );\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.getValue = function getValue () {\n\t\t\tvar options = this.element.node.options;\n\t\t\tvar len = options.length;\n\n\t\t\tvar selectedValues = [];\n\n\t\t\tfor ( var i = 0; i < len; i += 1 ) {\n\t\t\t\tvar option = options[i];\n\n\t\t\t\tif ( option.selected ) {\n\t\t\t\t\tvar optionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\tselectedValues.push( optionValue );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn selectedValues;\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.handleChange = function handleChange () {\n\t\t\tvar attribute = this.attribute;\n\t\t\tvar previousValue = attribute.getValue();\n\n\t\t\tvar value = this.getValue();\n\n\t\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\t\tBinding.prototype.handleChange.call(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\n\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\t\tif ( this.model.get() === undefined ) {\n\t\t\t\t// get value from DOM, if possible\n\t\t\t\tthis.handleChange();\n\t\t\t}\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tvar selectedOptions = getSelectedOptions( node );\n\t\t\tvar i = selectedOptions.length;\n\t\t\tvar result = new Array( i );\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar option = selectedOptions[i];\n\t\t\t\tresult[i] = option._ractive ? option._ractive.value : option.value;\n\t\t\t}\n\n\t\t\tthis.model.set( result );\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.setValue = function setValue () {\n\t\t\tthrow new Error( 'TODO not implemented yet' );\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.unrender = function unrender () {\n\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t};\n\n\t\tMultipleSelectBinding.prototype.updateModel = function updateModel () {\n\t\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\t\tthis.keypath.set( this.initialValue );\n\t\t\t}\n\t\t};\n\n\t\treturn MultipleSelectBinding;\n\t}(Binding));\n\n\tvar NumericBinding = (function (GenericBinding) {\n\t\tfunction NumericBinding () {\n\t\t\tGenericBinding.apply(this, arguments);\n\t\t}\n\n\t\tNumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n\t\tNumericBinding.prototype.constructor = NumericBinding;\n\n\t\tNumericBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\treturn undefined;\n\t\t};\n\n\t\tNumericBinding.prototype.getValue = function getValue () {\n\t\t\tvar value = parseFloat( this.node.value );\n\t\t\treturn isNaN( value ) ? undefined : value;\n\t\t};\n\n\t\tNumericBinding.prototype.setFromNode = function setFromNode( node ) {\n\t\t\tvar value = parseFloat( node.value );\n\t\t\tif ( !isNaN( value ) ) this.model.set( value );\n\t\t};\n\n\t\treturn NumericBinding;\n\t}(GenericBinding));\n\n\tvar siblings = {};\n\n\tfunction getSiblings ( hash ) {\n\t\treturn siblings[ hash ] || ( siblings[ hash ] = [] );\n\t}\n\n\tvar RadioBinding = (function (Binding) {\n\t\tfunction RadioBinding ( element ) {\n\t\t\tBinding.call( this, element, 'checked' );\n\n\t\t\tthis.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );\n\t\t\tthis.siblings.push( this );\n\t\t}\n\n\t\tRadioBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tRadioBinding.prototype.constructor = RadioBinding;\n\n\t\tRadioBinding.prototype.getValue = function getValue () {\n\t\t\treturn this.node.checked;\n\t\t};\n\n\t\tRadioBinding.prototype.handleChange = function handleChange () {\n\t\t\trunloop.start( this.root );\n\n\t\t\tthis.siblings.forEach( function ( binding ) {\n\t\t\t\tbinding.model.set( binding.getValue() );\n\t\t\t});\n\n\t\t\trunloop.end();\n\t\t};\n\n\t\tRadioBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\n\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\t\tif ( this.node.attachEvent ) {\n\t\t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n\t\t\t}\n\t\t};\n\n\t\tRadioBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tthis.model.set( node.checked );\n\t\t};\n\n\t\tRadioBinding.prototype.unbind = function unbind () {\n\t\t\tremoveFromArray( this.siblings, this );\n\t\t};\n\n\t\tRadioBinding.prototype.unrender = function unrender () {\n\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n\t\t};\n\n\t\treturn RadioBinding;\n\t}(Binding));\n\n\tfunction getValue$1() {\n\t\tvar checked = this.bindings.filter( function ( b ) { return b.node.checked; } );\n\t\tif ( checked.length > 0 ) {\n\t\t\treturn checked[0].element.getAttribute( 'value' );\n\t\t}\n\t}\n\n\tvar RadioNameBinding = (function (Binding) {\n\t\tfunction RadioNameBinding ( element ) {\n\t\t\tBinding.call( this, element, 'name' );\n\n\t\t\tthis.group = getBindingGroup( 'radioname', this.model, getValue$1 );\n\t\t\tthis.group.add( this );\n\n\t\t\tif ( element.checked ) {\n\t\t\t\tthis.group.value = this.getValue();\n\t\t\t}\n\t\t}\n\n\t\tRadioNameBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tRadioNameBinding.prototype.constructor = RadioNameBinding;\n\n\t\tRadioNameBinding.prototype.bind = function bind () {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( !this.group.bound ) {\n\t\t\t\tthis.group.bind();\n\t\t\t}\n\n\t\t\t// update name keypath when necessary\n\t\t\tthis.nameAttributeBinding = {\n\t\t\t\thandleChange: function () { return this$1.node.name = \"{{\" + (this$1.model.getKeypath()) + \"}}\"; }\n\t\t\t};\n\n\t\t\tthis.model.getKeypathModel().register( this.nameAttributeBinding );\n\t\t};\n\n\t\tRadioNameBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\t\treturn this.element.getAttribute( 'value' );\n\t\t\t}\n\t\t};\n\n\t\tRadioNameBinding.prototype.getValue = function getValue$1 () {\n\t\t\treturn this.element.getAttribute( 'value' );\n\t\t};\n\n\t\tRadioNameBinding.prototype.handleChange = function handleChange () {\n\t\t\t// If this <input> is the one that's checked, then the value of its\n\t\t\t// `name` model gets set to its value\n\t\t\tif ( this.node.checked ) {\n\t\t\t\tthis.group.value = this.getValue();\n\t\t\t\tBinding.prototype.handleChange.call(this);\n\t\t\t}\n\t\t};\n\n\t\tRadioNameBinding.prototype.lastVal = function lastVal ( setting, value ) {\n\t\t\tif ( !this.group ) return;\n\t\t\tif ( setting ) this.group.lastValue = value;\n\t\t\telse return this.group.lastValue;\n\t\t};\n\n\t\tRadioNameBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\n\t\t\tvar node = this.node;\n\n\t\t\tnode.name = \"{{\" + (this.model.getKeypath()) + \"}}\";\n\t\t\tnode.checked = this.model.get() == this.element.getAttribute( 'value' );\n\n\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t}\n\t\t};\n\n\t\tRadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tif ( node.checked ) {\n\t\t\t\tthis.group.model.set( this.element.getAttribute( 'value' ) );\n\t\t\t}\n\t\t};\n\n\t\tRadioNameBinding.prototype.unbind = function unbind () {\n\t\t\tthis.group.remove( this );\n\n\t\t\tthis.model.getKeypathModel().unregister( this.nameAttributeBinding );\n\t\t};\n\n\t\tRadioNameBinding.prototype.unrender = function unrender () {\n\t\t\tvar node = this.node;\n\n\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t};\n\n\t\treturn RadioNameBinding;\n\t}(Binding));\n\n\tvar SingleSelectBinding = (function (Binding) {\n\t\tfunction SingleSelectBinding () {\n\t\t\tBinding.apply(this, arguments);\n\t\t}\n\n\t\tSingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n\t\tSingleSelectBinding.prototype.constructor = SingleSelectBinding;\n\n\t\tSingleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar value = this.getValue();\n\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tthis.attribute.locked = true;\n\t\t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t\t\t\tthis.model.set( value );\n\t\t\t}\n\t\t};\n\n\t\tSingleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n\t\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar options = this.element.options;\n\t\t\tvar len = options.length;\n\n\t\t\tif ( !len ) return;\n\n\t\t\tvar value;\n\t\t\tvar optionWasSelected;\n\t\t\tvar i = len;\n\n\t\t\t// take the final selected option...\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar option = options[i];\n\n\t\t\t\tif ( option.getAttribute( 'selected' ) ) {\n\t\t\t\t\tif ( !option.getAttribute( 'disabled' ) ) {\n\t\t\t\t\t\tvalue = option.getAttribute( 'value' );\n\t\t\t\t\t}\n\n\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// or the first non-disabled option, if none are selected\n\t\t\tif ( !optionWasSelected ) {\n\t\t\t\twhile ( ++i < len ) {\n\t\t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t\t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t\t// other more expensive work\n\t\t\t// TODO does it still work? seems at odds with new architecture\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tthis.element.attributeByName.value.value = value;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\t\tSingleSelectBinding.prototype.getValue = function getValue () {\n\t\t\tvar options = this.node.options;\n\t\t\tvar len = options.length;\n\n\t\t\tvar i;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar option = options[i];\n\n\t\t\t\tif ( options[i].selected && !options[i].disabled ) {\n\t\t\t\t\treturn option._ractive ? option._ractive.value : option.value;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tSingleSelectBinding.prototype.render = function render () {\n\t\t\tBinding.prototype.render.call(this);\n\t\t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\t};\n\n\t\tSingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t\t\tvar option = getSelectedOptions( node )[0];\n\t\t\tthis.model.set( option._ractive ? option._ractive.value : option.value );\n\t\t};\n\n\t\t// TODO this method is an anomaly... is it necessary?\n\t\tSingleSelectBinding.prototype.setValue = function setValue ( value ) {\n\t\t\tthis.model.set( value );\n\t\t};\n\n\t\tSingleSelectBinding.prototype.unrender = function unrender () {\n\t\t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t};\n\n\t\treturn SingleSelectBinding;\n\t}(Binding));\n\n\tfunction isBindable ( attribute ) {\n\t\treturn attribute &&\n\t\t\t   attribute.template.f &&\n\t\t       attribute.template.f.length === 1 &&\n\t\t       attribute.template.f[0].t === INTERPOLATOR &&\n\t\t       !attribute.template.f[0].s;\n\t}\n\n\tfunction selectBinding ( element ) {\n\t\tvar attributes = element.attributeByName;\n\n\t\t// contenteditable - bind if the contenteditable attribute is true\n\t\t// or is bindable and may thus become true...\n\t\tif ( element.getAttribute( 'contenteditable' ) || isBindable( attributes.contenteditable ) ) {\n\t\t\t// ...and this element also has a value attribute to bind\n\t\t\treturn isBindable( attributes.value ) ? ContentEditableBinding : null;\n\t\t}\n\n\t\t// <input>\n\t\tif ( element.name === 'input' ) {\n\t\t\tvar type = element.getAttribute( 'type' );\n\n\t\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\t\tvar bindName = isBindable( attributes.name );\n\t\t\t\tvar bindChecked = isBindable( attributes.checked );\n\n\t\t\t\t// for radios we can either bind the name attribute, or the checked attribute - not both\n\t\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\t\tif ( type === 'radio' ) {\n\t\t\t\t\t\twarnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// A checkbox with bindings for both name and checked - see https://github.com/ractivejs/ractive/issues/1749\n\t\t\t\t\t\treturn CheckboxBinding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( bindName ) {\n\t\t\t\t\treturn type === 'radio' ? RadioNameBinding : CheckboxNameBinding;\n\t\t\t\t}\n\n\t\t\t\tif ( bindChecked ) {\n\t\t\t\t\treturn type === 'radio' ? RadioBinding : CheckboxBinding;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\t\treturn FileBinding;\n\t\t\t}\n\n\t\t\tif ( isBindable( attributes.value ) ) {\n\t\t\t\treturn ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// <select>\n\t\tif ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\t\treturn element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;\n\t\t}\n\n\t\t// <textarea>\n\t\tif ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\t\treturn GenericBinding;\n\t\t}\n\t}\n\n\tfunction makeDirty$1 ( query ) {\n\t\tquery.makeDirty();\n\t}\n\n\tvar endsWithSemi = /;\\s*$/;\n\n\tvar Element = (function (Item) {\n\t\tfunction Element ( options ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.liveQueries = []; // TODO rare case. can we handle differently?\n\n\t\t\tthis.name = options.template.e.toLowerCase();\n\t\t\tthis.isVoid = voidElementNames.test( this.name );\n\n\t\t\t// find parent element\n\t\t\tthis.parent = findElement( this.parentFragment, false );\n\n\t\t\tif ( this.parent && this.parent.name === 'option' ) {\n\t\t\t\tthrow new Error( (\"An <option> element cannot contain other elements (encountered <\" + (this.name) + \">)\") );\n\t\t\t}\n\n\t\t\tthis.decorators = [];\n\n\t\t\t// create attributes\n\t\t\tthis.attributeByName = {};\n\n\t\t\tthis.attributes = [];\n\t\t\tvar leftovers = [];\n\t\t\t( this.template.m || [] ).forEach( function ( template ) {\n\t\t\t\tswitch ( template.t ) {\n\t\t\t\t\tcase ATTRIBUTE:\n\t\t\t\t\tcase BINDING_FLAG:\n\t\t\t\t\tcase DECORATOR:\n\t\t\t\t\tcase EVENT:\n\t\t\t\t\tcase TRANSITION:\n\t\t\t\t\t\tthis$1.attributes.push( createItem({\n\t\t\t\t\t\t\towner: this$1,\n\t\t\t\t\t\t\tparentFragment: this$1.parentFragment,\n\t\t\t\t\t\t\ttemplate: template\n\t\t\t\t\t\t}) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tleftovers.push( template );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif ( leftovers.length ) {\n\t\t\t\tthis.attributes.push( new ConditionalAttribute({\n\t\t\t\t\towner: this,\n\t\t\t\t\tparentFragment: this.parentFragment,\n\t\t\t\t\ttemplate: leftovers\n\t\t\t\t}) );\n\t\t\t}\n\n\t\t\tvar i = this.attributes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar attr = this$1.attributes[ i ];\n\t\t\t\tif ( attr.name === 'type' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\telse if ( attr.name === 'max' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\telse if ( attr.name === 'min' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\telse if ( attr.name === 'class' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\telse if ( attr.name === 'value' ) {\n\t\t\t\t\tthis$1.attributes.push( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create children\n\t\t\tif ( options.template.f && !options.deferContent ) {\n\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\ttemplate: options.template.f,\n\t\t\t\t\towner: this,\n\t\t\t\t\tcssIds: null\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.binding = null; // filled in later\n\t\t}\n\n\t\tElement.prototype = Object.create( Item && Item.prototype );\n\t\tElement.prototype.constructor = Element;\n\n\t\tElement.prototype.bind = function bind$1$$ () {\n\t\t\tthis.attributes.binding = true;\n\t\t\tthis.attributes.forEach( bind$1 );\n\t\t\tthis.attributes.binding = false;\n\n\t\t\tif ( this.fragment ) this.fragment.bind();\n\n\t\t\t// create two-way binding if necessary\n\t\t\tif ( !this.binding ) this.recreateTwowayBinding();\n\t\t};\n\n\t\tElement.prototype.createTwowayBinding = function createTwowayBinding () {\n\t\t\tvar shouldBind = 'twoway' in this ? this.twoway : this.ractive.twoway;\n\n\t\t\tif ( !shouldBind ) return null;\n\n\t\t\tvar Binding = selectBinding( this );\n\n\t\t\tif ( !Binding ) return null;\n\n\t\t\tvar binding = new Binding( this );\n\n\t\t\treturn binding && binding.model ?\n\t\t\t\tbinding :\n\t\t\t\tnull;\n\t\t};\n\n\t\tElement.prototype.destroyed = function destroyed () {\n\t\t\tthis.attributes.forEach( function ( a ) { return a.destroyed(); } );\n\t\t\tif ( this.fragment ) this.fragment.destroyed();\n\t\t};\n\n\t\tElement.prototype.detach = function detach () {\n\t\t\t// if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n\t\t\tif ( !this.rendered ) this.destroyed();\n\n\t\t\treturn detachNode( this.node );\n\t\t};\n\n\t\tElement.prototype.find = function find ( selector ) {\n\t\t\tif ( this.node && matches( this.node, selector ) ) return this.node;\n\t\t\tif ( this.fragment ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t}\n\t\t};\n\n\t\tElement.prototype.findAll = function findAll ( selector, query ) {\n\t\t\t// Add this node to the query, if applicable, and register the\n\t\t\t// query on this element\n\t\t\tvar matches = query.test( this.node );\n\t\t\tif ( matches ) {\n\t\t\t\tquery.add( this.node );\n\t\t\t\tif ( query.live ) this.liveQueries.push( query );\n\t\t\t}\n\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t}\n\t\t};\n\n\t\tElement.prototype.findComponent = function findComponent ( name ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t}\n\t\t};\n\n\t\tElement.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t\t}\n\t\t};\n\n\t\tElement.prototype.findNextNode = function findNextNode () {\n\t\t\treturn null;\n\t\t};\n\n\t\tElement.prototype.firstNode = function firstNode () {\n\t\t\treturn this.node;\n\t\t};\n\n\t\tElement.prototype.getAttribute = function getAttribute ( name ) {\n\t\t\tvar attribute = this.attributeByName[ name ];\n\t\t\treturn attribute ? attribute.getValue() : undefined;\n\t\t};\n\n\t\tElement.prototype.recreateTwowayBinding = function recreateTwowayBinding () {\n\t\t\tif ( this.binding ) {\n\t\t\t\tthis.binding.unbind();\n\t\t\t\tthis.binding.unrender();\n\t\t\t}\n\n\t\t\tif ( this.binding = this.createTwowayBinding() ) {\n\t\t\t\tthis.binding.bind();\n\t\t\t\tif ( this.rendered ) this.binding.render();\n\t\t\t}\n\t\t};\n\n\t\tElement.prototype.render = function render$1 ( target, occupants ) {\n\t\t\t// TODO determine correct namespace\n\t\t\tvar this$1 = this;\n\n\t\t\tthis.namespace = getNamespace( this );\n\n\t\t\tvar node;\n\t\t\tvar existing = false;\n\n\t\t\tif ( occupants ) {\n\t\t\t\tvar n;\n\t\t\t\twhile ( ( n = occupants.shift() ) ) {\n\t\t\t\t\tif ( n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() && n.namespaceURI === this$1.namespace ) {\n\t\t\t\t\t\tthis$1.node = node = n;\n\t\t\t\t\t\texisting = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdetachNode( n );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !node ) {\n\t\t\t\tnode = createElement( this.template.e, this.namespace, this.getAttribute( 'is' ) );\n\t\t\t\tthis.node = node;\n\t\t\t}\n\n\t\t\tdefineProperty( node, '_ractive', {\n\t\t\t\tvalue: {\n\t\t\t\t\tproxy: this\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Is this a top-level node of a component? If so, we may need to add\n\t\t\t// a data-ractive-css attribute, for CSS encapsulation\n\t\t\tif ( this.parentFragment.cssIds ) {\n\t\t\t\tnode.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function ( x ) { return (\"{\" + x + \"}\"); } ).join( ' ' ) );\n\t\t\t}\n\n\t\t\tif ( existing && this.foundNode ) this.foundNode( node );\n\n\t\t\tif ( this.fragment ) {\n\t\t\t\tvar children = existing ? toArray( node.childNodes ) : undefined;\n\n\t\t\t\tthis.fragment.render( node, children );\n\n\t\t\t\t// clean up leftover children\n\t\t\t\tif ( children ) {\n\t\t\t\t\tchildren.forEach( detachNode );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( existing ) {\n\t\t\t\t// store initial values for two-way binding\n\t\t\t\tif ( this.binding && this.binding.wasUndefined ) this.binding.setFromNode( node );\n\t\t\t\t// remove unused attributes\n\t\t\t\tvar i = node.attributes.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvar name = node.attributes[i].name;\n\t\t\t\t\tif ( !( name in this$1.attributeByName ) ) node.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.attributes.forEach( render );\n\n\t\t\tif ( this.binding ) this.binding.render();\n\n\t\t\tupdateLiveQueries$1( this );\n\n\t\t\tif ( this._introTransition && this.ractive.transitionsEnabled ) {\n\t\t\t\tthis._introTransition.isIntro = true;\n\t\t\t\trunloop.registerTransition( this._introTransition );\n\t\t\t}\n\n\t\t\tif ( !existing ) {\n\t\t\t\ttarget.appendChild( node );\n\t\t\t}\n\n\t\t\tthis.rendered = true;\n\t\t};\n\n\t\tElement.prototype.shuffled = function shuffled () {\n\t\t\tthis.liveQueries.forEach( makeDirty$1 );\n\t\t\tItem.prototype.shuffled.call(this);\n\t\t};\n\n\t\tElement.prototype.toString = function toString () {\n\t\t\tvar tagName = this.template.e;\n\n\t\t\tvar attrs = this.attributes.map( stringifyAttribute ).join( '' );\n\n\t\t\t// Special case - selected options\n\t\t\tif ( this.name === 'option' && this.isSelected() ) {\n\t\t\t\tattrs += ' selected';\n\t\t\t}\n\n\t\t\t// Special case - two-way radio name bindings\n\t\t\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\t\t\tattrs += ' checked';\n\t\t\t}\n\n\t\t\t// Special case style and class attributes and directives\n\t\t\tvar style, cls;\n\t\t\tthis.attributes.forEach( function ( attr ) {\n\t\t\t\tif ( attr.name === 'class' ) {\n\t\t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + safeAttributeString( attr.getString() );\n\t\t\t\t} else if ( attr.name === 'style' ) {\n\t\t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) + safeAttributeString( attr.getString() );\n\t\t\t\t\tif ( style && !endsWithSemi.test( style ) ) style += ';';\n\t\t\t\t} else if ( attr.style ) {\n\t\t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) +  \"\" + (attr.style) + \": \" + (safeAttributeString( attr.getString() )) + \";\";\n\t\t\t\t} else if ( attr.inlineClass && attr.getValue() ) {\n\t\t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + attr.inlineClass;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// put classes first, then inline style\n\t\t\tif ( style !== undefined ) attrs = ' style' + ( style ? (\"=\\\"\" + style + \"\\\"\") : '' ) + attrs;\n\t\t\tif ( cls !== undefined ) attrs = ' class' + (cls ? (\"=\\\"\" + cls + \"\\\"\") : '') + attrs;\n\n\t\t\tvar str = \"<\" + tagName + \"\" + attrs + \">\";\n\n\t\t\tif ( this.isVoid ) return str;\n\n\t\t\t// Special case - textarea\n\t\t\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t\t\t}\n\n\t\t\t// Special case - contenteditable\n\t\t\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t\t\t}\n\n\t\t\tif ( this.fragment ) {\n\t\t\t\tstr += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style\n\t\t\t}\n\n\t\t\tstr += \"</\" + tagName + \">\";\n\t\t\treturn str;\n\t\t};\n\n\t\tElement.prototype.unbind = function unbind$1 () {\n\t\t\tthis.attributes.unbinding = true;\n\t\t\tthis.attributes.forEach( unbind );\n\t\t\tthis.attributes.unbinding = false;\n\n\t\t\tif ( this.binding ) this.binding.unbind();\n\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t};\n\n\t\tElement.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tif ( !this.rendered ) return;\n\t\t\tthis.rendered = false;\n\n\t\t\t// unrendering before intro completed? complete it now\n\t\t\t// TODO should be an API for aborting transitions\n\t\t\tvar transition = this._introTransition;\n\t\t\tif ( transition && transition.complete ) transition.complete();\n\n\t\t\t// Detach as soon as we can\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t// <option> elements detach immediately, so that\n\t\t\t\t// their parent <select> element syncs correctly, and\n\t\t\t\t// since option elements can't have transitions anyway\n\t\t\t\tthis.detach();\n\t\t\t} else if ( shouldDestroy ) {\n\t\t\t\trunloop.detachWhenReady( this );\n\t\t\t}\n\n\t\t\tif ( this.fragment ) this.fragment.unrender();\n\n\t\t\tif ( this.binding ) this.binding.unrender();\n\n\t\t\t// outro transition\n\t\t\tif ( this._outroTransition && this.ractive.transitionsEnabled ) {\n\t\t\t\tthis._outroTransition.isIntro = false;\n\t\t\t\trunloop.registerTransition( this._outroTransition );\n\t\t\t}\n\n\t\t\tremoveFromLiveQueries( this );\n\t\t\t// TODO forms are a special case\n\t\t};\n\n\t\tElement.prototype.update = function update$1 () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\n\t\t\t\tthis.attributes.forEach( update );\n\n\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t}\n\t\t};\n\n\t\treturn Element;\n\t}(Item));\n\n\tfunction inputIsCheckedRadio ( element ) {\n\t\tvar attributes = element.attributeByName;\n\n\t\tvar typeAttribute  = attributes.type;\n\t\tvar valueAttribute = attributes.value;\n\t\tvar nameAttribute  = attributes.name;\n\n\t\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( valueAttribute.getValue() === nameAttribute.interpolator.model.get() ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfunction stringifyAttribute ( attribute ) {\n\t\tvar str = attribute.toString();\n\t\treturn str ? ' ' + str : '';\n\t}\n\n\tfunction removeFromLiveQueries ( element ) {\n\t\tvar i = element.liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tvar query = element.liveQueries[i];\n\t\t\tquery.remove( element.node );\n\t\t}\n\t}\n\n\tfunction getNamespace ( element ) {\n\t\t// Use specified namespace...\n\t\tvar xmlns = element.getAttribute( 'xmlns' );\n\t\tif ( xmlns ) return xmlns;\n\n\t\t// ...or SVG namespace, if this is an <svg> element\n\t\tif ( element.name === 'svg' ) return svg$1;\n\n\t\tvar parent = element.parent;\n\n\t\tif ( parent ) {\n\t\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\t\tif ( parent.name === 'foreignobject' ) return html;\n\n\t\t\t// ...or inherit from the parent node\n\t\t\treturn parent.node.namespaceURI;\n\t\t}\n\n\t\treturn element.ractive.el.namespaceURI;\n\t}\n\n\tvar Form = (function (Element) {\n\t\tfunction Form ( options ) {\n\t\t\tElement.call( this, options );\n\t\t\tthis.formBindings = [];\n\t\t}\n\n\t\tForm.prototype = Object.create( Element && Element.prototype );\n\t\tForm.prototype.constructor = Form;\n\n\t\tForm.prototype.render = function render ( target, occupants ) {\n\t\t\tElement.prototype.render.call( this, target, occupants );\n\t\t\tthis.node.addEventListener( 'reset', handleReset, false );\n\t\t};\n\n\t\tForm.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tthis.node.removeEventListener( 'reset', handleReset, false );\n\t\t\tElement.prototype.unrender.call( this, shouldDestroy );\n\t\t};\n\n\t\treturn Form;\n\t}(Element));\n\n\tfunction handleReset () {\n\t\tvar element = this._ractive.proxy;\n\n\t\trunloop.start();\n\t\telement.formBindings.forEach( updateModel$1 );\n\t\trunloop.end();\n\t}\n\n\tfunction updateModel$1 ( binding ) {\n\t\tbinding.model.set( binding.resetValue );\n\t}\n\n\tvar Mustache = (function (Item) {\n\t\tfunction Mustache ( options ) {\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.parentFragment = options.parentFragment;\n\t\t\tthis.template = options.template;\n\t\t\tthis.index = options.index;\n\t\t\tif ( options.owner ) this.parent = options.owner;\n\n\t\t\tthis.isStatic = !!options.template.s;\n\n\t\t\tthis.model = null;\n\t\t\tthis.dirty = false;\n\t\t}\n\n\t\tMustache.prototype = Object.create( Item && Item.prototype );\n\t\tMustache.prototype.constructor = Mustache;\n\n\t\tMustache.prototype.bind = function bind () {\n\t\t\t// try to find a model for this view\n\t\t\tvar this$1 = this;\n\n\t\t\tvar model = resolve$2( this.parentFragment, this.template );\n\t\t\tvar value = model ? model.get() : undefined;\n\n\t\t\tif ( this.isStatic ) {\n\t\t\t\tthis.model = { get: function () { return value; } };\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( model ) {\n\t\t\t\tmodel.register( this );\n\t\t\t\tthis.model = model;\n\t\t\t} else {\n\t\t\t\tthis.resolver = this.parentFragment.resolve( this.template.r, function ( model ) {\n\t\t\t\t\tthis$1.model = model;\n\t\t\t\t\tmodel.register( this$1 );\n\n\t\t\t\t\tthis$1.handleChange();\n\t\t\t\t\tthis$1.resolver = null;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tMustache.prototype.handleChange = function handleChange () {\n\t\t\tthis.bubble();\n\t\t};\n\n\t\tMustache.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\tnext = rebindMatch( this.template, next, previous );\n\t\t\tif ( this['static'] ) return false;\n\t\t\tif ( next === this.model ) return false;\n\n\t\t\tif ( this.model ) {\n\t\t\t\tthis.model.unregister( this );\n\t\t\t}\n\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t\t\tthis.model = next;\n\t\t\tif ( !safe ) this.handleChange();\n\t\t\treturn true;\n\t\t};\n\n\t\tMustache.prototype.unbind = function unbind () {\n\t\t\tif ( !this.isStatic ) {\n\t\t\t\tthis.model && this.model.unregister( this );\n\t\t\t\tthis.model = undefined;\n\t\t\t\tthis.resolver && this.resolver.unbind();\n\t\t\t}\n\t\t};\n\n\t\treturn Mustache;\n\t}(Item));\n\n\tvar Interpolator = (function (Mustache) {\n\t\tfunction Interpolator () {\n\t\t\tMustache.apply(this, arguments);\n\t\t}\n\n\t\tInterpolator.prototype = Object.create( Mustache && Mustache.prototype );\n\t\tInterpolator.prototype.constructor = Interpolator;\n\n\t\tInterpolator.prototype.bubble = function bubble () {\n\t\t\tif ( this.owner ) this.owner.bubble();\n\t\t\tMustache.prototype.bubble.call(this);\n\t\t};\n\n\t\tInterpolator.prototype.detach = function detach () {\n\t\t\treturn detachNode( this.node );\n\t\t};\n\n\t\tInterpolator.prototype.firstNode = function firstNode () {\n\t\t\treturn this.node;\n\t\t};\n\n\t\tInterpolator.prototype.getString = function getString () {\n\t\t\treturn this.model ? safeToStringValue( this.model.get() ) : '';\n\t\t};\n\n\t\tInterpolator.prototype.render = function render ( target, occupants ) {\n\t\t\tif ( inAttributes() ) return;\n\t\t\tvar value = this.getString();\n\n\t\t\tthis.rendered = true;\n\n\t\t\tif ( occupants ) {\n\t\t\t\tvar n = occupants[0];\n\t\t\t\tif ( n && n.nodeType === 3 ) {\n\t\t\t\t\toccupants.shift();\n\t\t\t\t\tif ( n.nodeValue !== value ) {\n\t\t\t\t\t\tn.nodeValue = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = this.node = doc.createTextNode( value );\n\t\t\t\t\tif ( occupants[0] ) {\n\t\t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.appendChild( n );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.node = n;\n\t\t\t} else {\n\t\t\t\tthis.node = doc.createTextNode( value );\n\t\t\t\ttarget.appendChild( this.node );\n\t\t\t}\n\t\t};\n\n\t\tInterpolator.prototype.toString = function toString ( escape ) {\n\t\t\tvar string = this.getString();\n\t\t\treturn escape ? escapeHtml( string ) : string;\n\t\t};\n\n\t\tInterpolator.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tif ( shouldDestroy ) this.detach();\n\t\t\tthis.rendered = false;\n\t\t};\n\n\t\tInterpolator.prototype.update = function update () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\tthis.node.data = this.getString();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tInterpolator.prototype.valueOf = function valueOf () {\n\t\t\treturn this.model ? this.model.get() : undefined;\n\t\t};\n\n\t\treturn Interpolator;\n\t}(Mustache));\n\n\tvar Input = (function (Element) {\n\t\tfunction Input () {\n\t\t\tElement.apply(this, arguments);\n\t\t}\n\n\t\tInput.prototype = Object.create( Element && Element.prototype );\n\t\tInput.prototype.constructor = Input;\n\n\t\tInput.prototype.render = function render ( target, occupants ) {\n\t\t\tElement.prototype.render.call( this, target, occupants );\n\t\t\tthis.node.defaultValue = this.node.value;\n\t\t};\n\n\t\treturn Input;\n\t}(Element));\n\n\tvar Mapping = (function (Item) {\n\t\tfunction Mapping ( options ) {\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.name = options.template.n;\n\n\t\t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n\t\t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n\t\t\tthis.parentFragment = this.element.parentFragment; // shared\n\t\t\tthis.ractive = this.parentFragment.ractive;\n\n\t\t\tthis.fragment = null;\n\n\t\t\tthis.element.attributeByName[ this.name ] = this;\n\n\t\t\tthis.value = options.template.f;\n\t\t}\n\n\t\tMapping.prototype = Object.create( Item && Item.prototype );\n\t\tMapping.prototype.constructor = Mapping;\n\n\t\tMapping.prototype.bind = function bind () {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.bind();\n\t\t\t}\n\n\t\t\tvar template = this.template.f;\n\t\t\tvar viewmodel = this.element.instance.viewmodel;\n\n\t\t\tif ( template === 0 ) {\n\t\t\t\t// empty attributes are `true`\n\t\t\t\tviewmodel.joinKey( this.name ).set( true );\n\t\t\t}\n\n\t\t\telse if ( typeof template === 'string' ) {\n\t\t\t\tvar parsed = parseJSON( template );\n\t\t\t\tviewmodel.joinKey( this.name ).set( parsed ? parsed.value : template );\n\t\t\t}\n\n\t\t\telse if ( isArray( template ) ) {\n\t\t\t\tcreateMapping( this, true );\n\t\t\t}\n\t\t};\n\n\t\tMapping.prototype.render = function render () {};\n\n\t\tMapping.prototype.unbind = function unbind () {\n\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t\tif ( this.boundFragment ) this.boundFragment.unbind();\n\n\t\t\tif ( this.element.bound ) {\n\t\t\t\tif ( this.link.target === this.model ) this.link.owner.unlink();\n\t\t\t}\n\t\t};\n\n\t\tMapping.prototype.unrender = function unrender () {};\n\n\t\tMapping.prototype.update = function update () {\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tif ( this.fragment ) this.fragment.update();\n\t\t\t\tif ( this.boundFragment ) this.boundFragment.update();\n\t\t\t\tif ( this.rendered ) this.updateDelegate();\n\t\t\t}\n\t\t};\n\n\t\treturn Mapping;\n\t}(Item));\n\n\tfunction createMapping ( item ) {\n\t\tvar template = item.template.f;\n\t\tvar viewmodel = item.element.instance.viewmodel;\n\t\tvar childData = viewmodel.value;\n\n\t\tif ( template.length === 1 && template[0].t === INTERPOLATOR ) {\n\t\t\titem.model = resolve$2( item.parentFragment, template[0] );\n\n\t\t\tif ( !item.model ) {\n\t\t\t\twarnOnceIfDebug( (\"The \" + (item.name) + \"='{{\" + (template[0].r) + \"}}' mapping is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: item.element.instance }); // TODO add docs page explaining item\n\t\t\t\titem.parentFragment.ractive.get( item.name ); // side-effect: create mappings as necessary\n\t\t\t\titem.model = item.parentFragment.findContext().joinKey( item.name );\n\t\t\t}\n\n\t\t\titem.link = viewmodel.createLink( item.name, item.model, template[0].r );\n\n\t\t\tif ( item.model.get() === undefined && item.name in childData ) {\n\t\t\t\titem.model.set( childData[ item.name ] );\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\titem.boundFragment = new Fragment({\n\t\t\t\towner: item,\n\t\t\t\ttemplate: template\n\t\t\t}).bind();\n\n\t\t\titem.model = viewmodel.joinKey( item.name );\n\t\t\titem.model.set( item.boundFragment.valueOf() );\n\n\t\t\t// item is a *bit* of a hack\n\t\t\titem.boundFragment.bubble = function () {\n\t\t\t\tFragment.prototype.bubble.call( item.boundFragment );\n\t\t\t\t// defer this to avoid mucking around model deps if there happens to be an expression involved\n\t\t\t\trunloop.scheduleTask(function () {\n\t\t\t\t\titem.boundFragment.update();\n\t\t\t\t\titem.model.set( item.boundFragment.valueOf() );\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}\n\n\tvar Option = (function (Element) {\n\t\tfunction Option ( options ) {\n\t\t\tvar template = options.template;\n\t\t\tif ( !template.a ) template.a = {};\n\n\t\t\t// If the value attribute is missing, use the element's content,\n\t\t\t// as long as it isn't disabled\n\t\t\tif ( template.a.value === undefined && !( 'disabled' in template.a ) ) {\n\t\t\t\ttemplate.a.value = template.f || '';\n\t\t\t}\n\n\t\t\tElement.call( this, options );\n\n\t\t\tthis.select = findElement( this.parent || this.parentFragment, false, 'select' );\n\t\t}\n\n\t\tOption.prototype = Object.create( Element && Element.prototype );\n\t\tOption.prototype.constructor = Option;\n\n\t\tOption.prototype.bind = function bind () {\n\t\t\tif ( !this.select ) {\n\t\t\t\tElement.prototype.bind.call(this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If the select has a value, it overrides the `selected` attribute on\n\t\t\t// this option - so we delete the attribute\n\t\t\tvar selectedAttribute = this.attributeByName.selected;\n\t\t\tif ( selectedAttribute && this.select.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\tvar index = this.attributes.indexOf( selectedAttribute );\n\t\t\t\tthis.attributes.splice( index, 1 );\n\t\t\t\tdelete this.attributeByName.selected;\n\t\t\t}\n\n\t\t\tElement.prototype.bind.call(this);\n\t\t\tthis.select.options.push( this );\n\t\t};\n\n\t\tOption.prototype.bubble = function bubble () {\n\t\t\t// if we're using content as value, may need to update here\n\t\t\tvar value = this.getAttribute( 'value' );\n\t\t\tif ( this.node && this.node.value !== value ) {\n\t\t\t\tthis.node._ractive.value = value;\n\t\t\t}\n\t\t\tElement.prototype.bubble.call(this);\n\t\t};\n\n\t\tOption.prototype.getAttribute = function getAttribute ( name ) {\n\t\t\tvar attribute = this.attributeByName[ name ];\n\t\t\treturn attribute ? attribute.getValue() : name === 'value' && this.fragment ? this.fragment.valueOf() : undefined;\n\t\t};\n\n\t\tOption.prototype.isSelected = function isSelected () {\n\t\t\tvar optionValue = this.getAttribute( 'value' );\n\n\t\t\tif ( optionValue === undefined || !this.select ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar selectValue = this.select.getAttribute( 'value' );\n\n\t\t\tif ( selectValue == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( this.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\t\t\tvar i = selectValue.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tOption.prototype.render = function render ( target, occupants ) {\n\t\t\tElement.prototype.render.call( this, target, occupants );\n\n\t\t\tif ( !this.attributeByName.value ) {\n\t\t\t\tthis.node._ractive.value = this.getAttribute( 'value' );\n\t\t\t}\n\t\t};\n\n\t\tOption.prototype.unbind = function unbind () {\n\t\t\tElement.prototype.unbind.call(this);\n\n\t\t\tif ( this.select ) {\n\t\t\t\tremoveFromArray( this.select.options, this );\n\t\t\t}\n\t\t};\n\n\t\treturn Option;\n\t}(Element));\n\n\tfunction getPartialTemplate ( ractive, name, parentFragment ) {\n\t\t// If the partial in instance or view heirarchy instances, great\n\t\tvar partial = getPartialFromRegistry( ractive, name, parentFragment || {} );\n\t\tif ( partial ) return partial;\n\n\t\t// Does it exist on the page as a script tag?\n\t\tpartial = parser.fromId( name, { noThrow: true } );\n\t\tif ( partial ) {\n\t\t\t// parse and register to this ractive instance\n\t\t\tvar parsed = parser.parseFor( partial, ractive );\n\n\t\t\t// register extra partials on the ractive instance if they don't already exist\n\t\t\tif ( parsed.p ) fillGaps( ractive.partials, parsed.p );\n\n\t\t\t// register (and return main partial if there are others in the template)\n\t\t\treturn ractive.partials[ name ] = parsed.t;\n\t\t}\n\t}\n\n\tfunction getPartialFromRegistry ( ractive, name, parentFragment ) {\n\t\t// if there was an instance up-hierarchy, cool\n\t\tvar partial = findParentPartial( name, parentFragment.owner );\n\t\tif ( partial ) return partial;\n\n\t\t// find first instance in the ractive or view hierarchy that has this partial\n\t\tvar instance = findInstance( 'partials', ractive, name );\n\n\t\tif ( !instance ) { return; }\n\n\t\tpartial = instance.partials[ name ];\n\n\t\t// partial is a function?\n\t\tvar fn;\n\t\tif ( typeof partial === 'function' ) {\n\t\t\tfn = partial.bind( instance );\n\t\t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n\t\t\tpartial = fn.call( ractive, parser );\n\t\t}\n\n\t\tif ( !partial && partial !== '' ) {\n\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });\n\t\t\treturn;\n\t\t}\n\n\t\t// If this was added manually to the registry,\n\t\t// but hasn't been parsed, parse it now\n\t\tif ( !parser.isParsed( partial ) ) {\n\t\t\t// use the parseOptions of the ractive instance on which it was found\n\t\t\tvar parsed = parser.parseFor( partial, instance );\n\n\t\t\t// Partials cannot contain nested partials!\n\t\t\t// TODO add a test for this\n\t\t\tif ( parsed.p ) {\n\t\t\t\twarnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });\n\t\t\t}\n\n\t\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t\t// in the correct point in prototype chain on instance or constructor\n\t\t\tvar target = fn ? instance : findOwner( instance, name );\n\n\t\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\t\ttarget.partials[ name ] = partial = parsed.t;\n\t\t}\n\n\t\t// store for reset\n\t\tif ( fn ) partial._fn = fn;\n\n\t\treturn partial.v ? partial.t : partial;\n\t}\n\n\tfunction findOwner ( ractive, key ) {\n\t\treturn ractive.partials.hasOwnProperty( key )\n\t\t\t? ractive\n\t\t\t: findConstructor( ractive.constructor, key);\n\t}\n\n\tfunction findConstructor ( constructor, key ) {\n\t\tif ( !constructor ) { return; }\n\t\treturn constructor.partials.hasOwnProperty( key )\n\t\t\t? constructor\n\t\t\t: findConstructor( constructor._Parent, key );\n\t}\n\n\tfunction findParentPartial( name, parent ) {\n\t\tif ( parent ) {\n\t\t\tif ( parent.template && parent.template.p && parent.template.p[name] ) {\n\t\t\t\treturn parent.template.p[name];\n\t\t\t} else if ( parent.parentFragment && parent.parentFragment.owner ) {\n\t\t\t\treturn findParentPartial( name, parent.parentFragment.owner );\n\t\t\t}\n\t\t}\n\t}\n\n\tvar Partial = (function (Mustache) {\n\t\tfunction Partial () {\n\t\t\tMustache.apply(this, arguments);\n\t\t}\n\n\t\tPartial.prototype = Object.create( Mustache && Mustache.prototype );\n\t\tPartial.prototype.constructor = Partial;\n\n\t\tPartial.prototype.bind = function bind () {\n\t\t\t// keep track of the reference name for future resets\n\t\t\tthis.refName = this.template.r;\n\n\t\t\t// name matches take priority over expressions\n\t\t\tvar template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;\n\t\t\tvar templateObj;\n\n\t\t\tif ( template ) {\n\t\t\t\tthis.named = true;\n\t\t\t\tthis.setTemplate( this.template.r, template );\n\t\t\t}\n\n\t\t\tif ( !template ) {\n\t\t\t\tMustache.prototype.bind.call(this);\n\t\t\t\tif ( this.model && ( templateObj = this.model.get() ) && typeof templateObj === 'object' && ( typeof templateObj.template === 'string' || isArray( templateObj.t ) ) ) {\n\t\t\t\t\tif ( templateObj.template ) {\n\t\t\t\t\t\tthis.source = templateObj.template;\n\t\t\t\t\t\ttemplateObj = parsePartial( this.template.r, templateObj.template, this.ractive );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.source = templateObj.t;\n\t\t\t\t\t}\n\t\t\t\t\tthis.setTemplate( this.template.r, templateObj.t );\n\t\t\t\t} else if ( ( !this.model || typeof this.model.get() !== 'string' ) && this.refName ) {\n\t\t\t\t\tthis.setTemplate( this.refName, template );\n\t\t\t\t} else {\n\t\t\t\t\tthis.setTemplate( this.model.get() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\towner: this,\n\t\t\t\ttemplate: this.partialTemplate\n\t\t\t}).bind();\n\t\t};\n\n\t\tPartial.prototype.detach = function detach () {\n\t\t\treturn this.fragment.detach();\n\t\t};\n\n\t\tPartial.prototype.find = function find ( selector ) {\n\t\t\treturn this.fragment.find( selector );\n\t\t};\n\n\t\tPartial.prototype.findAll = function findAll ( selector, query ) {\n\t\t\tthis.fragment.findAll( selector, query );\n\t\t};\n\n\t\tPartial.prototype.findComponent = function findComponent ( name ) {\n\t\t\treturn this.fragment.findComponent( name );\n\t\t};\n\n\t\tPartial.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t};\n\n\t\tPartial.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\treturn this.fragment.firstNode( skipParent );\n\t\t};\n\n\t\tPartial.prototype.forceResetTemplate = function forceResetTemplate () {\n\t\t\tvar this$1 = this;\n\n\t\t\tthis.partialTemplate = undefined;\n\n\t\t\t// on reset, check for the reference name first\n\t\t\tif ( this.refName ) {\n\t\t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );\n\t\t\t}\n\n\t\t\t// then look for the resolved name\n\t\t\tif ( !this.partialTemplate ) {\n\t\t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );\n\t\t\t}\n\n\t\t\tif ( !this.partialTemplate ) {\n\t\t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + (this.name) + \"'\") );\n\t\t\t\tthis.partialTemplate = [];\n\t\t\t}\n\n\t\t\tif ( this.inAttribute ) {\n\t\t\t\tdoInAttributes( function () { return this$1.fragment.resetTemplate( this$1.partialTemplate ); } );\n\t\t\t} else {\n\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t\t\t}\n\n\t\t\tthis.bubble();\n\t\t};\n\n\t\tPartial.prototype.render = function render ( target, occupants ) {\n\t\t\tthis.fragment.render( target, occupants );\n\t\t};\n\n\t\tPartial.prototype.setTemplate = function setTemplate ( name, template ) {\n\t\t\tthis.name = name;\n\n\t\t\tif ( !template && template !== null ) template = getPartialTemplate( this.ractive, name, this.parentFragment );\n\n\t\t\tif ( !template ) {\n\t\t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + name + \"'\") );\n\t\t\t}\n\n\t\t\tthis.partialTemplate = template || [];\n\t\t};\n\n\t\tPartial.prototype.toString = function toString ( escape ) {\n\t\t\treturn this.fragment.toString( escape );\n\t\t};\n\n\t\tPartial.prototype.unbind = function unbind () {\n\t\t\tMustache.prototype.unbind.call(this);\n\t\t\tthis.fragment.unbind();\n\t\t};\n\n\t\tPartial.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t};\n\n\t\tPartial.prototype.update = function update () {\n\t\t\tvar template;\n\n\t\t\tif ( this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\n\t\t\t\tif ( !this.named ) {\n\t\t\t\t\tif ( this.model ) {\n\t\t\t\t\t\ttemplate = this.model.get();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( template && typeof template === 'string' && template !== this.name ) {\n\t\t\t\t\t\tthis.setTemplate( template );\n\t\t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t\t\t\t\t} else if ( template && typeof template === 'object' && ( typeof template.template === 'string' || isArray( template.t ) ) ) {\n\t\t\t\t\t\tif ( template.t !== this.source && template.template !== this.source ) {\n\t\t\t\t\t\t\tif ( template.template ) {\n\t\t\t\t\t\t\t\tthis.source = template.template;\n\t\t\t\t\t\t\t\ttemplate = parsePartial( this.name, template.template, this.ractive );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.source = template.t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.setTemplate( this.name, template.t );\n\t\t\t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.fragment.update();\n\t\t\t}\n\t\t};\n\n\t\treturn Partial;\n\t}(Mustache));\n\n\tfunction parsePartial( name, partial, ractive ) {\n\t\tvar parsed;\n\n\t\ttry {\n\t\t\tparsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\t\t} catch (e) {\n\t\t\twarnIfDebug( (\"Could not parse partial from expression '\" + name + \"'\\n\" + (e.message)) );\n\t\t}\n\n\t\treturn parsed || { t: [] };\n\t}\n\n\tvar RepeatedFragment = function RepeatedFragment ( options ) {\n\t\tthis.parent = options.owner.parentFragment;\n\n\t\t// bit of a hack, so reference resolution works without another\n\t\t// layer of indirection\n\t\tthis.parentFragment = this;\n\t\tthis.owner = options.owner;\n\t\tthis.ractive = this.parent.ractive;\n\n\t\t// encapsulated styles should be inherited until they get applied by an element\n\t\tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\n\t\tthis.context = null;\n\t\tthis.rendered = false;\n\t\tthis.iterations = [];\n\n\t\tthis.template = options.template;\n\n\t\tthis.indexRef = options.indexRef;\n\t\tthis.keyRef = options.keyRef;\n\n\t\tthis.pendingNewIndices = null;\n\t\tthis.previousIterations = null;\n\n\t\t// track array versus object so updates of type rest\n\t\tthis.isArray = false;\n\t};\n\n\tRepeatedFragment.prototype.bind = function bind ( context ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.context = context;\n\t\tvar value = context.get();\n\n\t\t// {{#each array}}...\n\t\tif ( this.isArray = isArray( value ) ) {\n\t\t\t// we can't use map, because of sparse arrays\n\t\t\tthis.iterations = [];\n\t\t\tvar max = value.length;\n\t\t\tfor ( var i = 0; i < max; i += 1 ) {\n\t\t\t\tthis$1.iterations[i] = this$1.createIteration( i, i );\n\t\t\t}\n\t\t}\n\n\t\t// {{#each object}}...\n\t\telse if ( isObject( value ) ) {\n\t\t\tthis.isArray = false;\n\n\t\t\t// TODO this is a dreadful hack. There must be a neater way\n\t\t\tif ( this.indexRef ) {\n\t\t\t\tvar refs = this.indexRef.split( ',' );\n\t\t\t\tthis.keyRef = refs[0];\n\t\t\t\tthis.indexRef = refs[1];\n\t\t\t}\n\n\t\t\tthis.iterations = Object.keys( value ).map( function ( key, index ) {\n\t\t\t\treturn this$1.createIteration( key, index );\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tRepeatedFragment.prototype.bubble = function bubble () {\n\t\tthis.owner.bubble();\n\t};\n\n\tRepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {\n\t\tvar fragment = new Fragment({\n\t\t\towner: this,\n\t\t\ttemplate: this.template\n\t\t});\n\n\t\t// TODO this is a bit hacky\n\t\tfragment.key = key;\n\t\tfragment.index = index;\n\t\tfragment.isIteration = true;\n\n\t\tvar model = this.context.joinKey( key );\n\n\t\t// set up an iteration alias if there is one\n\t\tif ( this.owner.template.z ) {\n\t\t\tfragment.aliases = {};\n\t\t\tfragment.aliases[ this.owner.template.z[0].n ] = model;\n\t\t}\n\n\t\treturn fragment.bind( model );\n\t};\n\n\tRepeatedFragment.prototype.destroyed = function destroyed () {\n\t\tthis.iterations.forEach( function ( i ) { return i.destroyed(); } );\n\t};\n\n\tRepeatedFragment.prototype.detach = function detach () {\n\t\tvar docFrag = createDocumentFragment();\n\t\tthis.iterations.forEach( function ( fragment ) { return docFrag.appendChild( fragment.detach() ); } );\n\t\treturn docFrag;\n\t};\n\n\tRepeatedFragment.prototype.find = function find ( selector ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar len = this.iterations.length;\n\t\tvar i;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tvar found = this$1.iterations[i].find( selector );\n\t\t\tif ( found ) return found;\n\t\t}\n\t};\n\n\tRepeatedFragment.prototype.findAll = function findAll ( selector, query ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar len = this.iterations.length;\n\t\tvar i;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis$1.iterations[i].findAll( selector, query );\n\t\t}\n\t};\n\n\tRepeatedFragment.prototype.findComponent = function findComponent ( name ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar len = this.iterations.length;\n\t\tvar i;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tvar found = this$1.iterations[i].findComponent( name );\n\t\t\tif ( found ) return found;\n\t\t}\n\t};\n\n\tRepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar len = this.iterations.length;\n\t\tvar i;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis$1.iterations[i].findAllComponents( name, query );\n\t\t}\n\t};\n\n\tRepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( iteration.index < this.iterations.length - 1 ) {\n\t\t\tfor ( var i = iteration.index + 1; i < this$1.iterations.length; i++ ) {\n\t\t\t\tvar node = this$1.iterations[ i ].firstNode( true );\n\t\t\t\tif ( node ) return node;\n\t\t\t}\n\t\t}\n\n\t\treturn this.owner.findNextNode();\n\t};\n\n\tRepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {\n\t\treturn this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null;\n\t};\n\n\tRepeatedFragment.prototype.rebinding = function rebinding ( next ) {\n\t\tvar this$1 = this;\n\n\t\t\tthis.context = next;\n\t\tthis.iterations.forEach( function ( fragment ) {\n\t\t\tvar model = next ? next.joinKey( fragment.key || fragment.index ) : undefined;\n\t\t\tfragment.context = model;\n\t\t\tif ( this$1.owner.template.z ) {\n\t\t\t\tfragment.aliases = {};\n\t\t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n\t\t\t}\n\t\t});\n\t};\n\n\tRepeatedFragment.prototype.render = function render ( target, occupants ) {\n\t\t// TODO use docFrag.cloneNode...\n\n\t\tif ( this.iterations ) {\n\t\t\tthis.iterations.forEach( function ( fragment ) { return fragment.render( target, occupants ); } );\n\t\t}\n\n\t\tthis.rendered = true;\n\t};\n\n\tRepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( !this.pendingNewIndices ) this.previousIterations = this.iterations.slice();\n\n\t\tif ( !this.pendingNewIndices ) this.pendingNewIndices = [];\n\n\t\tthis.pendingNewIndices.push( newIndices );\n\n\t\tvar iterations = [];\n\n\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\tif ( newIndex === -1 ) return;\n\n\t\t\tvar fragment = this$1.iterations[ oldIndex ];\n\t\t\titerations[ newIndex ] = fragment;\n\n\t\t\tif ( newIndex !== oldIndex && fragment ) fragment.dirty = true;\n\t\t});\n\n\t\tthis.iterations = iterations;\n\n\t\tthis.bubble();\n\t};\n\n\tRepeatedFragment.prototype.shuffled = function shuffled () {\n\t\tthis.iterations.forEach( function ( i ) { return i.shuffled(); } );\n\t};\n\n\tRepeatedFragment.prototype.toString = function toString$1$$ ( escape ) {\n\t\treturn this.iterations ?\n\t\t\tthis.iterations.map( escape ? toEscapedString : toString$1 ).join( '' ) :\n\t\t\t'';\n\t};\n\n\tRepeatedFragment.prototype.unbind = function unbind$1 () {\n\t\tthis.iterations.forEach( unbind );\n\t\treturn this;\n\t};\n\n\tRepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t\tthis.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\t\tif ( this.pendingNewIndices && this.previousIterations ) {\n\t\t\tthis.previousIterations.forEach( function ( fragment ) {\n\t\t\t\tif ( fragment.rendered ) shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment );\n\t\t\t});\n\t\t}\n\t\tthis.rendered = false;\n\t};\n\n\t// TODO smart update\n\tRepeatedFragment.prototype.update = function update$1 () {\n\t\t// skip dirty check, since this is basically just a facade\n\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.pendingNewIndices ) {\n\t\t\tthis.updatePostShuffle();\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.updating ) return;\n\t\tthis.updating = true;\n\n\t\tvar value = this.context.get(),\n\t\t\t\t  wasArray = this.isArray;\n\n\t\tvar toRemove;\n\t\tvar oldKeys;\n\t\tvar reset = true;\n\t\tvar i;\n\n\t\tif ( this.isArray = isArray( value ) ) {\n\t\t\tif ( wasArray ) {\n\t\t\t\treset = false;\n\t\t\t\tif ( this.iterations.length > value.length ) {\n\t\t\t\t\ttoRemove = this.iterations.splice( value.length );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( isObject( value ) && !wasArray ) {\n\t\t\treset = false;\n\t\t\ttoRemove = [];\n\t\t\toldKeys = {};\n\t\t\ti = this.iterations.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar fragment$1 = this$1.iterations[i];\n\t\t\t\tif ( fragment$1.key in value ) {\n\t\t\t\t\toldKeys[ fragment$1.key ] = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis$1.iterations.splice( i, 1 );\n\t\t\t\t\ttoRemove.push( fragment$1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( reset ) {\n\t\t\ttoRemove = this.iterations;\n\t\t\tthis.iterations = [];\n\t\t}\n\n\t\tif ( toRemove ) {\n\t\t\ttoRemove.forEach( function ( fragment ) {\n\t\t\t\tfragment.unbind();\n\t\t\t\tfragment.unrender( true );\n\t\t\t});\n\t\t}\n\n\t\t// update the remaining ones\n\t\tthis.iterations.forEach( update );\n\n\t\t// add new iterations\n\t\tvar newLength = isArray( value ) ?\n\t\t\tvalue.length :\n\t\t\tisObject( value ) ?\n\t\t\t\tObject.keys( value ).length :\n\t\t\t\t0;\n\n\t\tvar docFrag;\n\t\tvar fragment;\n\n\t\tif ( newLength > this.iterations.length ) {\n\t\t\tdocFrag = this.rendered ? createDocumentFragment() : null;\n\t\t\ti = this.iterations.length;\n\n\t\t\tif ( isArray( value ) ) {\n\t\t\t\twhile ( i < value.length ) {\n\t\t\t\t\tfragment = this$1.createIteration( i, i );\n\n\t\t\t\t\tthis$1.iterations.push( fragment );\n\t\t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if ( isObject( value ) ) {\n\t\t\t\t// TODO this is a dreadful hack. There must be a neater way\n\t\t\t\tif ( this.indexRef && !this.keyRef ) {\n\t\t\t\t\tvar refs = this.indexRef.split( ',' );\n\t\t\t\t\tthis.keyRef = refs[0];\n\t\t\t\t\tthis.indexRef = refs[1];\n\t\t\t\t}\n\n\t\t\t\tObject.keys( value ).forEach( function ( key ) {\n\t\t\t\t\tif ( !oldKeys || !( key in oldKeys ) ) {\n\t\t\t\t\t\tfragment = this$1.createIteration( key, i );\n\n\t\t\t\t\t\tthis$1.iterations.push( fragment );\n\t\t\t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( this.rendered ) {\n\t\t\t\tvar parentNode = this.parent.findParentNode();\n\t\t\t\tvar anchor = this.parent.findNextNode( this.owner );\n\n\t\t\t\tparentNode.insertBefore( docFrag, anchor );\n\t\t\t}\n\t\t}\n\n\t\tthis.updating = false;\n\t};\n\n\tRepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {\n\t\tvar this$1 = this;\n\n\t\t\tvar newIndices = this.pendingNewIndices[ 0 ];\n\n\t\t// map first shuffle through\n\t\tthis.pendingNewIndices.slice( 1 ).forEach( function ( indices ) {\n\t\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\t\tnewIndices[ oldIndex ] = indices[ newIndex ];\n\t\t\t});\n\t\t});\n\n\t\t// This algorithm (for detaching incorrectly-ordered fragments from the DOM and\n\t\t// storing them in a document fragment for later reinsertion) seems a bit hokey,\n\t\t// but it seems to work for now\n\t\tvar len = this.context.get().length, oldLen = this.previousIterations.length;\n\t\tvar i;\n\t\tvar removed = {};\n\n\t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t\t\tvar fragment = this$1.previousIterations[ oldIndex ];\n\t\t\tthis$1.previousIterations[ oldIndex ] = null;\n\n\t\t\tif ( newIndex === -1 ) {\n\t\t\t\tremoved[ oldIndex ] = fragment;\n\t\t\t} else if ( fragment.index !== newIndex ) {\n\t\t\t\tvar model = this$1.context.joinKey( newIndex );\n\t\t\t\tfragment.index = newIndex;\n\t\t\t\tfragment.context = model;\n\t\t\t\tif ( this$1.owner.template.z ) {\n\t\t\t\t\tfragment.aliases = {};\n\t\t\t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices\n\t\tthis.previousIterations.forEach( function ( frag, i ) {\n\t\t\tif ( frag ) removed[ i ] = frag;\n\t\t});\n\n\t\t// create new/move existing iterations\n\t\tvar docFrag = this.rendered ? createDocumentFragment() : null;\n\t\tvar parentNode = this.rendered ? this.parent.findParentNode() : null;\n\n\t\tvar contiguous = 'startIndex' in newIndices;\n\t\ti = contiguous ? newIndices.startIndex : 0;\n\n\t\tfor ( i; i < len; i++ ) {\n\t\t\tvar frag = this$1.iterations[i];\n\n\t\t\tif ( frag && contiguous ) {\n\t\t\t\t// attach any built-up iterations\n\t\t\t\tif ( this$1.rendered ) {\n\t\t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t\t\t\t\tif ( docFrag.childNodes.length  ) parentNode.insertBefore( docFrag, frag.firstNode() );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( !frag ) this$1.iterations[i] = this$1.createIteration( i, i );\n\n\t\t\tif ( this$1.rendered ) {\n\t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\n\t\t\t\tif ( frag ) docFrag.appendChild( frag.detach() );\n\t\t\t\telse {\n\t\t\t\t\tthis$1.iterations[i].render( docFrag );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// append any leftovers\n\t\tif ( this.rendered ) {\n\t\t\tfor ( i = len; i < oldLen; i++ ) {\n\t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t\t\t}\n\n\t\t\tif ( docFrag.childNodes.length ) {\n\t\t\t\tparentNode.insertBefore( docFrag, this.owner.findNextNode() );\n\t\t\t}\n\t\t}\n\n\t\t// trigger removal on old nodes\n\t\tObject.keys( removed ).forEach( function ( k ) { return removed[k].unbind().unrender( true ); } );\n\n\t\tthis.iterations.forEach( update );\n\n\t\tthis.pendingNewIndices = null;\n\n\t\tthis.shuffled();\n\t};\n\n\tfunction isEmpty ( value ) {\n\t\treturn !value ||\n\t\t       ( isArray( value ) && value.length === 0 ) ||\n\t\t\t   ( isObject( value ) && Object.keys( value ).length === 0 );\n\t}\n\n\tfunction getType ( value, hasIndexRef ) {\n\t\tif ( hasIndexRef || isArray( value ) ) return SECTION_EACH;\n\t\tif ( isObject( value ) || typeof value === 'function' ) return SECTION_IF_WITH;\n\t\tif ( value === undefined ) return null;\n\t\treturn SECTION_IF;\n\t}\n\n\tvar Section = (function (Mustache) {\n\t\tfunction Section ( options ) {\n\t\t\tMustache.call( this, options );\n\n\t\t\tthis.sectionType = options.template.n || null;\n\t\t\tthis.templateSectionType = this.sectionType;\n\t\t\tthis.subordinate = options.template.l === 1;\n\t\t\tthis.fragment = null;\n\t\t}\n\n\t\tSection.prototype = Object.create( Mustache && Mustache.prototype );\n\t\tSection.prototype.constructor = Section;\n\n\t\tSection.prototype.bind = function bind () {\n\t\t\tMustache.prototype.bind.call(this);\n\n\t\t\tif ( this.subordinate ) {\n\t\t\t\tthis.sibling = this.parentFragment.items[ this.parentFragment.items.indexOf( this ) - 1 ];\n\t\t\t\tthis.sibling.nextSibling = this;\n\t\t\t}\n\n\t\t\t// if we managed to bind, we need to create children\n\t\t\tif ( this.model ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.update();\n\t\t\t} else if ( this.sectionType && this.sectionType === SECTION_UNLESS && ( !this.sibling || !this.sibling.isTruthy() ) ) {\n\t\t\t\tthis.fragment = new Fragment({\n\t\t\t\t\towner: this,\n\t\t\t\t\ttemplate: this.template.f\n\t\t\t\t}).bind();\n\t\t\t}\n\t\t};\n\n\t\tSection.prototype.detach = function detach () {\n\t\t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n\t\t};\n\n\t\tSection.prototype.find = function find ( selector ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t}\n\t\t};\n\n\t\tSection.prototype.findAll = function findAll ( selector, query ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAll( selector, query );\n\t\t\t}\n\t\t};\n\n\t\tSection.prototype.findComponent = function findComponent ( name ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\treturn this.fragment.findComponent( name );\n\t\t\t}\n\t\t};\n\n\t\tSection.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.findAllComponents( name, query );\n\t\t\t}\n\t\t};\n\n\t\tSection.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\treturn this.fragment && this.fragment.firstNode( skipParent );\n\t\t};\n\n\t\tSection.prototype.isTruthy = function isTruthy () {\n\t\t\tif ( this.subordinate && this.sibling.isTruthy() ) return true;\n\t\t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n\t\t\treturn !!value && ( this.templateSectionType === SECTION_IF_WITH || !isEmpty( value ) );\n\t\t};\n\n\t\tSection.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t\t\tif ( Mustache.prototype.rebinding.call( this, next, previous, safe ) ) {\n\t\t\t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n\t\t\t\t\tthis.fragment.rebinding( next, previous );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tSection.prototype.render = function render ( target, occupants ) {\n\t\t\tthis.rendered = true;\n\t\t\tif ( this.fragment ) this.fragment.render( target, occupants );\n\t\t};\n\n\t\tSection.prototype.shuffle = function shuffle ( newIndices ) {\n\t\t\tif ( this.fragment && this.sectionType === SECTION_EACH ) {\n\t\t\t\tthis.fragment.shuffle( newIndices );\n\t\t\t}\n\t\t};\n\n\t\tSection.prototype.toString = function toString ( escape ) {\n\t\t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n\t\t};\n\n\t\tSection.prototype.unbind = function unbind () {\n\t\t\tMustache.prototype.unbind.call(this);\n\t\t\tif ( this.fragment ) this.fragment.unbind();\n\t\t};\n\n\t\tSection.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n\t\t\tthis.rendered = false;\n\t\t};\n\n\t\tSection.prototype.update = function update () {\n\t\t\tif ( !this.dirty ) return;\n\n\t\t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n\t\t\t\tthis.fragment.context = this.model;\n\t\t\t}\n\n\t\t\tif ( !this.model && this.sectionType !== SECTION_UNLESS ) return;\n\n\t\t\tthis.dirty = false;\n\n\t\t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n\t\t\tvar siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n\t\t\tvar lastType = this.sectionType;\n\n\t\t\t// watch for switching section types\n\t\t\tif ( this.sectionType === null || this.templateSectionType === null ) this.sectionType = getType( value, this.template.i );\n\t\t\tif ( lastType && lastType !== this.sectionType && this.fragment ) {\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\tthis.fragment.unbind().unrender( true );\n\t\t\t\t}\n\n\t\t\t\tthis.fragment = null;\n\t\t\t}\n\n\t\t\tvar newFragment;\n\n\t\t\tvar fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n\t\t\t                            this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n\t\t\t                            ( siblingFalsey && ( this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy() ) ); // if, unless, and if-with depend on siblings and the condition\n\n\t\t\tif ( fragmentShouldExist ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.update();\n\t\t\t\t} else {\n\t\t\t\t\tif ( this.sectionType === SECTION_EACH ) {\n\t\t\t\t\t\tnewFragment = new RepeatedFragment({\n\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\ttemplate: this.template.f,\n\t\t\t\t\t\t\tindexRef: this.template.i\n\t\t\t\t\t\t}).bind( this.model );\n\t\t\t\t\t} else {\n\t\t \t\t\t\t// only with and if-with provide context - if and unless do not\n\t\t\t\t\t\tvar context = this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ? this.model : null;\n\t\t\t\t\t\tnewFragment = new Fragment({\n\t\t\t\t\t\t\towner: this,\n\t\t\t\t\t\t\ttemplate: this.template.f\n\t\t\t\t\t\t}).bind( context );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( this.fragment && this.rendered ) {\n\t\t\t\t\tthis.fragment.unbind().unrender( true );\n\t\t\t\t}\n\n\t\t\t\tthis.fragment = null;\n\t\t\t}\n\n\t\t\tif ( newFragment ) {\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\tvar parentNode = this.parentFragment.findParentNode();\n\t\t\t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\n\t\t\t\t\tif ( anchor ) {\n\t\t\t\t\t\tvar docFrag = createDocumentFragment();\n\t\t\t\t\t\tnewFragment.render( docFrag );\n\n\t\t\t\t\t\t// we use anchor.parentNode, not parentNode, because the sibling\n\t\t\t\t\t\t// may be temporarily detached as a result of a shuffle\n\t\t\t\t\t\tanchor.parentNode.insertBefore( docFrag, anchor );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewFragment.render( parentNode );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.fragment = newFragment;\n\t\t\t}\n\n\t\t\tif ( this.nextSibling ) {\n\t\t\t\tthis.nextSibling.dirty = true;\n\t\t\t\tthis.nextSibling.update();\n\t\t\t}\n\t\t};\n\n\t\treturn Section;\n\t}(Mustache));\n\n\tfunction valueContains ( selectValue, optionValue ) {\n\t\tvar i = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( selectValue[i] == optionValue ) return true;\n\t\t}\n\t}\n\n\tvar Select = (function (Element) {\n\t\tfunction Select ( options ) {\n\t\t\tElement.call( this, options );\n\t\t\tthis.options = [];\n\t\t}\n\n\t\tSelect.prototype = Object.create( Element && Element.prototype );\n\t\tSelect.prototype.constructor = Select;\n\n\t\tSelect.prototype.foundNode = function foundNode ( node ) {\n\t\t\tif ( this.binding ) {\n\t\t\t\tvar selectedOptions = getSelectedOptions( node );\n\n\t\t\t\tif ( selectedOptions.length > 0 ) {\n\t\t\t\t\tthis.selectedOptions = selectedOptions;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tSelect.prototype.render = function render ( target, occupants ) {\n\t\t\tElement.prototype.render.call( this, target, occupants );\n\t\t\tthis.sync();\n\n\t\t\tvar node = this.node;\n\n\t\t\tvar i = node.options.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tnode.options[i].defaultSelected = node.options[i].selected;\n\t\t\t}\n\n\t\t\tthis.rendered = true;\n\t\t};\n\n\t\tSelect.prototype.sync = function sync () {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar selectNode = this.node;\n\n\t\t\tif ( !selectNode ) return;\n\n\t\t\tvar options = toArray( selectNode.options );\n\n\t\t\tif ( this.selectedOptions ) {\n\t\t\t\toptions.forEach( function ( o ) {\n\t\t\t\t\tif ( this$1.selectedOptions.indexOf( o ) >= 0 ) o.selected = true;\n\t\t\t\t\telse o.selected = false;\n\t\t\t\t});\n\t\t\t\tthis.binding.setFromNode( selectNode );\n\t\t\t\tdelete this.selectedOptions;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar selectValue = this.getAttribute( 'value' );\n\t\t\tvar isMultiple = this.getAttribute( 'multiple' );\n\n\t\t\t// If the <select> has a specified value, that should override\n\t\t\t// these options\n\t\t\tif ( selectValue !== undefined ) {\n\t\t\t\tvar optionWasSelected;\n\n\t\t\t\toptions.forEach( function ( o ) {\n\t\t\t\t\tvar optionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\t\t\tvar shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\n\t\t\t\t\tif ( shouldSelect ) {\n\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t}\n\n\t\t\t\t\to.selected = shouldSelect;\n\t\t\t\t});\n\n\t\t\t\tif ( !optionWasSelected && !isMultiple ) {\n\t\t\t\t\tif ( this.binding ) {\n\t\t\t\t\t\tthis.binding.forceUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise the value should be initialised according to which\n\t\t\t// <option> element is selected, if twoway binding is in effect\n\t\t\telse if ( this.binding ) {\n\t\t\t\tthis.binding.forceUpdate();\n\t\t\t}\n\t\t};\n\n\t\tSelect.prototype.update = function update () {\n\t\t\tElement.prototype.update.call(this);\n\t\t\tthis.sync();\n\t\t};\n\n\t\treturn Select;\n\t}(Element));\n\n\tvar Textarea = (function (Input) {\n\t\tfunction Textarea( options ) {\n\t\t\tvar template = options.template;\n\n\t\t\toptions.deferContent = true;\n\n\t\t\tInput.call( this, options );\n\n\t\t\t// check for single interpolator binding\n\t\t\tif ( !this.attributeByName.value ) {\n\t\t\t\tif ( template.f && isBindable( { template: template } ) ) {\n\t\t\t\t\tthis.attributes.push( createItem( {\n\t\t\t\t\t\towner: this,\n\t\t\t\t\t\ttemplate: { t: ATTRIBUTE, f: template.f, n: 'value' },\n\t\t\t\t\t\tparentFragment: this.parentFragment\n\t\t\t\t\t} ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis.fragment = new Fragment({ owner: this, cssIds: null, template: template.f });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTextarea.prototype = Object.create( Input && Input.prototype );\n\t\tTextarea.prototype.constructor = Textarea;\n\n\t\tTextarea.prototype.bubble = function bubble () {\n\t\t\tvar this$1 = this;\n\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\n\t\t\t\tif ( this.rendered && !this.binding && this.fragment ) {\n\t\t\t\t\trunloop.scheduleTask( function () {\n\t\t\t\t\t\tthis$1.dirty = false;\n\t\t\t\t\t\tthis$1.node.value = this$1.fragment.toString();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis.parentFragment.bubble(); // default behaviour\n\t\t\t}\n\t\t};\n\n\t\treturn Textarea;\n\t}(Input));\n\n\tvar Text = (function (Item) {\n\t\tfunction Text ( options ) {\n\t\t\tItem.call( this, options );\n\t\t\tthis.type = TEXT;\n\t\t}\n\n\t\tText.prototype = Object.create( Item && Item.prototype );\n\t\tText.prototype.constructor = Text;\n\n\t\tText.prototype.bind = function bind () {\n\t\t\t// noop\n\t\t};\n\n\t\tText.prototype.detach = function detach () {\n\t\t\treturn detachNode( this.node );\n\t\t};\n\n\t\tText.prototype.firstNode = function firstNode () {\n\t\t\treturn this.node;\n\t\t};\n\n\t\tText.prototype.render = function render ( target, occupants ) {\n\t\t\tif ( inAttributes() ) return;\n\t\t\tthis.rendered = true;\n\n\t\t\tif ( occupants ) {\n\t\t\t\tvar n = occupants[0];\n\t\t\t\tif ( n && n.nodeType === 3 ) {\n\t\t\t\t\toccupants.shift();\n\t\t\t\t\tif ( n.nodeValue !== this.template ) {\n\t\t\t\t\t\tn.nodeValue = this.template;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn = this.node = doc.createTextNode( this.template );\n\t\t\t\t\tif ( occupants[0] ) {\n\t\t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.appendChild( n );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.node = n;\n\t\t\t} else {\n\t\t\t\tthis.node = doc.createTextNode( this.template );\n\t\t\t\ttarget.appendChild( this.node );\n\t\t\t}\n\t\t};\n\n\t\tText.prototype.toString = function toString ( escape ) {\n\t\t\treturn escape ? escapeHtml( this.template ) : this.template;\n\t\t};\n\n\t\tText.prototype.unbind = function unbind () {\n\t\t\t// noop\n\t\t};\n\n\t\tText.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tif ( this.rendered && shouldDestroy ) this.detach();\n\t\t\tthis.rendered = false;\n\t\t};\n\n\t\tText.prototype.update = function update () {\n\t\t\t// noop\n\t\t};\n\n\t\tText.prototype.valueOf = function valueOf () {\n\t\t\treturn this.template;\n\t\t};\n\n\t\treturn Text;\n\t}(Item));\n\n\tfunction camelCase ( hyphenatedStr ) {\n\t\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t\t\treturn $1.toUpperCase();\n\t\t});\n\t}\n\n\tvar prefix;\n\n\tif ( !isClient ) {\n\t\tprefix = null;\n\t} else {\n\t\tvar prefixCache = {};\n\t\tvar testStyle = createElement( 'div' ).style;\n\n\t\tprefix = function ( prop ) {\n\t\t\tprop = camelCase( prop );\n\n\t\t\tif ( !prefixCache[ prop ] ) {\n\t\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\t// test vendors...\n\t\t\t\t\tvar capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\n\t\t\t\t\tvar i = vendors.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvar vendor = vendors[i];\n\t\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn prefixCache[ prop ];\n\t\t};\n\t}\n\n\tvar prefix$1 = prefix;\n\n\tvar visible;\n\tvar hidden = 'hidden';\n\n\tif ( doc ) {\n\t\tvar prefix$2;\n\n\t\tif ( hidden in doc ) {\n\t\t\tprefix$2 = '';\n\t\t} else {\n\t\t\tvar i$1 = vendors.length;\n\t\t\twhile ( i$1-- ) {\n\t\t\t\tvar vendor = vendors[i$1];\n\t\t\t\thidden = vendor + 'Hidden';\n\n\t\t\t\tif ( hidden in doc ) {\n\t\t\t\t\tprefix$2 = vendor;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( prefix$2 !== undefined ) {\n\t\t\tdoc.addEventListener( prefix$2 + 'visibilitychange', onChange );\n\t\t\tonChange();\n\t\t} else {\n\t\t\t// gah, we're in an old browser\n\t\t\tif ( 'onfocusout' in doc ) {\n\t\t\t\tdoc.addEventListener( 'focusout', onHide );\n\t\t\t\tdoc.addEventListener( 'focusin', onShow );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\twin.addEventListener( 'pagehide', onHide );\n\t\t\t\twin.addEventListener( 'blur', onHide );\n\n\t\t\t\twin.addEventListener( 'pageshow', onShow );\n\t\t\t\twin.addEventListener( 'focus', onShow );\n\t\t\t}\n\n\t\t\tvisible = true; // until proven otherwise. Not ideal but hey\n\t\t}\n\t}\n\n\tfunction onChange () {\n\t\tvisible = !doc[ hidden ];\n\t}\n\n\tfunction onHide () {\n\t\tvisible = false;\n\t}\n\n\tfunction onShow () {\n\t\tvisible = true;\n\t}\n\n\tvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\n\tfunction unprefix ( prop ) {\n\t\treturn prop.replace( unprefixPattern, '' );\n\t}\n\n\tvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\n\tfunction hyphenate ( str ) {\n\t\tif ( !str ) return ''; // edge case\n\n\t\tif ( vendorPattern.test( str ) ) str = '-' + str;\n\n\t\treturn str.replace( /[A-Z]/g, function ( match ) { return '-' + match.toLowerCase(); } );\n\t}\n\n\tvar createTransitions;\n\n\tif ( !isClient ) {\n\t\tcreateTransitions = null;\n\t} else {\n\t\tvar testStyle$1 = createElement( 'div' ).style;\n\t\tvar linear$1 = function ( x ) { return x; };\n\n\t\tvar canUseCssTransitions = {};\n\t\tvar cannotUseCssTransitions = {};\n\n\t\t// determine some facts about our environment\n\t\tvar TRANSITION$1;\n\t\tvar TRANSITIONEND;\n\t\tvar CSS_TRANSITIONS_ENABLED;\n\t\tvar TRANSITION_DURATION;\n\t\tvar TRANSITION_PROPERTY;\n\t\tvar TRANSITION_TIMING_FUNCTION;\n\n\t\tif ( testStyle$1.transition !== undefined ) {\n\t\t\tTRANSITION$1 = 'transition';\n\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else if ( testStyle$1.webkitTransition !== undefined ) {\n\t\t\tTRANSITION$1 = 'webkitTransition';\n\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else {\n\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t}\n\n\t\tif ( TRANSITION$1 ) {\n\t\t\tTRANSITION_DURATION = TRANSITION$1 + 'Duration';\n\t\t\tTRANSITION_PROPERTY = TRANSITION$1 + 'Property';\n\t\t\tTRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';\n\t\t}\n\n\t\tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\n\t\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t\t// TODO use a fastdom-style mechanism?\n\t\t\tsetTimeout( function () {\n\t\t\t\tvar jsTransitionsComplete;\n\t\t\t\tvar cssTransitionsComplete;\n\t\t\t\tvar cssTimeout;\n\n\t\t\t\tfunction transitionDone () { clearTimeout( cssTimeout ); }\n\n\t\t\t\tfunction checkComplete () {\n\t\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t\tt.unregisterCompleteHandler( transitionDone );\n\t\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\t\tt.ractive.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t\t// which properties\n\t\t\t\tvar hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\n\t\t\t\t// need to reset transition properties\n\t\t\t\tvar style = t.node.style;\n\t\t\t\tvar previous = {\n\t\t\t\t\tproperty: style[ TRANSITION_PROPERTY ],\n\t\t\t\t\ttiming: style[ TRANSITION_TIMING_FUNCTION ],\n\t\t\t\t\tduration: style[ TRANSITION_DURATION ]\n\t\t\t\t};\n\n\t\t\t\tstyle[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );\n\t\t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\t\tstyle[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\n\t\t\t\tfunction transitionEndHandler ( event ) {\n\t\t\t\t\tvar index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t\t// still transitioning...\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout( cssTimeout );\n\t\t\t\t\tcssTransitionsDone();\n\t\t\t\t}\n\n\t\t\t\tfunction cssTransitionsDone () {\n\t\t\t\t\tstyle[ TRANSITION_PROPERTY ] = previous.property;\n\t\t\t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = previous.duration;\n\t\t\t\t\tstyle[ TRANSITION_DURATION ] = previous.timing;\n\n\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\n\t\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\t\t// safety net in case transitionend never fires\n\t\t\t\tcssTimeout = setTimeout( function () {\n\t\t\t\t\tchangedProperties = [];\n\t\t\t\t\tcssTransitionsDone();\n\t\t\t\t}, options.duration + ( options.delay || 0 ) + 50 );\n\t\t\t\tt.registerCompleteHandler( transitionDone );\n\n\t\t\t\tsetTimeout( function () {\n\t\t\t\t\tvar i = changedProperties.length;\n\t\t\t\t\tvar hash;\n\t\t\t\t\tvar originalValue;\n\t\t\t\t\tvar index;\n\t\t\t\t\tvar propertiesToTransitionInJs = [];\n\t\t\t\t\tvar prop;\n\t\t\t\t\tvar suffix;\n\t\t\t\t\tvar interpolator;\n\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprop = changedProperties[i];\n\t\t\t\t\t\thash = hashPrefix + prop;\n\n\t\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\tstyle[ prefix$1( prop ) ] = to[ prop ];\n\n\t\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\n\t\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\n\t\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\tstyle[ prefix$1( prop ) ] = originalValue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n\t\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\t\t\t\t\t\t\tinterpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );\n\n\t\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t\t\t\t\t\t\t\tname: prefix$1( prop ),\n\t\t\t\t\t\t\t\tinterpolator: interpolator,\n\t\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// javascript transitions\n\t\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\t\tvar easing;\n\n\t\t\t\t\t\tif ( typeof options.easing === 'string' ) {\n\t\t\t\t\t\t\teasing = t.ractive.easing[ options.easing ];\n\n\t\t\t\t\t\t\tif ( !easing ) {\n\t\t\t\t\t\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n\t\t\t\t\t\t\t\teasing = linear$1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if ( typeof options.easing === 'function' ) {\n\t\t\t\t\t\t\teasing = options.easing;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teasing = linear$1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnew Ticker({\n\t\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\t\teasing: easing,\n\t\t\t\t\t\t\tstep: function ( pos ) {\n\t\t\t\t\t\t\t\tvar i = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\t\tvar prop = propertiesToTransitionInJs[i];\n\t\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t}, 0 );\n\t\t\t}, options.delay || 0 );\n\t\t};\n\t}\n\n\tvar createTransitions$1 = createTransitions;\n\n\tfunction resetStyle ( node, style ) {\n\t\tif ( style ) {\n\t\t\tnode.setAttribute( 'style', style );\n\t\t} else {\n\t\t\t// Next line is necessary, to remove empty style attribute!\n\t\t\t// See http://stackoverflow.com/a/7167553\n\t\t\tnode.getAttribute( 'style' );\n\t\t\tnode.removeAttribute( 'style' );\n\t\t}\n\t}\n\n\tvar getComputedStyle = win && ( win.getComputedStyle || legacy.getComputedStyle );\n\tvar resolved = Promise$1.resolve();\n\n\tvar names = {\n\t\tt0: 'intro-outro',\n\t\tt1: 'intro',\n\t\tt2: 'outro'\n\t};\n\n\tvar Transition = function Transition ( options ) {\n\t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t\tthis.ractive = this.owner.ractive;\n\t\tthis.template = options.template;\n\t\tthis.parentFragment = options.parentFragment;\n\t\tthis.options = options;\n\t\tthis.onComplete = [];\n\t};\n\n\tTransition.prototype.animateStyle = function animateStyle ( style, value, options ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( arguments.length === 4 ) {\n\t\t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t\t}\n\n\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t// that way you'll never get CSS transitionend events\n\t\tif ( !visible ) {\n\t\t\tthis.setStyle( style, value );\n\t\t\treturn resolved;\n\t\t}\n\n\t\tvar to;\n\n\t\tif ( typeof style === 'string' ) {\n\t\t\tto = {};\n\t\t\tto[ style ] = value;\n\t\t} else {\n\t\t\tto = style;\n\n\t\t\t// shuffle arguments\n\t\t\toptions = value;\n\t\t}\n\n\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t// callback function that gets called after the animation completes\n\n\t\t// TODO remove this check in a future version\n\t\tif ( !options ) {\n\t\t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t\t\toptions = this;\n\t\t}\n\n\t\treturn new Promise$1( function ( fulfil ) {\n\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\tif ( !options.duration ) {\n\t\t\t\tthis$1.setStyle( to );\n\t\t\t\tfulfil();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get a list of the properties we're animating\n\t\t\tvar propertyNames = Object.keys( to );\n\t\t\tvar changedProperties = [];\n\n\t\t\t// Store the current styles\n\t\t\tvar computedStyle = getComputedStyle( this$1.node );\n\n\t\t\tvar i = propertyNames.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tvar prop = propertyNames[i];\n\t\t\t\tvar current = computedStyle[ prefix$1( prop ) ];\n\n\t\t\t\tif ( current === '0px' ) current = 0;\n\n\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\tchangedProperties.push( prop );\n\n\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\tthis$1.node.style[ prefix$1( prop ) ] = current;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t// will never fire! So we complete early\n\t\t\tif ( !changedProperties.length ) {\n\t\t\t\tfulfil();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcreateTransitions$1( this$1, to, options, changedProperties, fulfil );\n\t\t});\n\t};\n\n\tTransition.prototype.bind = function bind () {\n\t\tvar this$1 = this;\n\n\t\t\tvar options = this.options;\n\t\tvar type = options.template && options.template.v;\n\t\tif ( type ) {\n\t\t\tif ( type === 't0' || type === 't1' ) this.element._introTransition = this;\n\t\t\tif ( type === 't0' || type === 't2' ) this.element._outroTransition = this;\n\t\t\tthis.eventName = names[ type ];\n\t\t}\n\n\t\tvar ractive = this.owner.ractive;\n\n\t\tif ( options.name ) {\n\t\t\tthis.name = options.name;\n\t\t} else {\n\t\t\tvar name = options.template.f;\n\t\t\tif ( typeof name.n === 'string' ) name = name.n;\n\n\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\tvar fragment = new Fragment({\n\t\t\t\t\towner: this.owner,\n\t\t\t\t\ttemplate: name.n\n\t\t\t\t}).bind(); // TODO need a way to capture values without bind()\n\n\t\t\t\tname = fragment.toString();\n\t\t\t\tfragment.unbind();\n\n\t\t\t\tif ( name === '' ) {\n\t\t\t\t\t// empty string okay, just no transition\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tif ( options.params ) {\n\t\t\tthis.params = options.params;\n\t\t} else {\n\t\t\tif ( options.template.f.a && !options.template.f.a.s ) {\n\t\t\t\tthis.params = options.template.f.a;\n\t\t\t}\n\n\t\t\telse if ( options.template.f.d ) {\n\t\t\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t\t\t// 'dependency thrashing'?\n\t\t\t\tvar fragment$1 = new Fragment({\n\t\t\t\t\towner: this.owner,\n\t\t\t\t\ttemplate: options.template.f.d\n\t\t\t\t}).bind();\n\n\t\t\t\tthis.params = fragment$1.getArgsList();\n\t\t\t\tfragment$1.unbind();\n\t\t\t}\n\t\t}\n\n\t\tif ( typeof this.name === 'function' ) {\n\t\t\tthis._fn = this.name;\n\t\t\tthis.name = this._fn.name;\n\t\t} else {\n\t\t\tthis._fn = findInViewHierarchy( 'transitions', ractive, this.name );\n\t\t}\n\n\t\tif ( !this._fn ) {\n\t\t\twarnOnceIfDebug( missingPlugin( this.name, 'transition' ), { ractive: ractive });\n\t\t}\n\n\t\t// TODO: dry up after deprecation is done\n\t\tif ( options.template && this.template.f.a && this.template.f.a.s ) {\n\t\t\tthis.resolvers = [];\n\t\t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n\t\t\t\tvar resolver;\n\t\t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t\t\t\tif ( !model ) {\n\t\t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t\t\t\t\t\tthis$1.models[i] = model;\n\t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t\t\t\t\t\tmodel.register( this$1 );\n\t\t\t\t\t});\n\n\t\t\t\t\tthis$1.resolvers.push( resolver );\n\t\t\t\t} else model.register( this$1 );\n\n\t\t\t\treturn model;\n\t\t\t});\n\t\t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n\t\t}\n\t};\n\n\tTransition.prototype.destroyed = function destroyed () {};\n\n\tTransition.prototype.getStyle = function getStyle ( props ) {\n\t\tvar computedStyle = getComputedStyle( this.node );\n\n\t\tif ( typeof props === 'string' ) {\n\t\t\tvar value = computedStyle[ prefix$1( props ) ];\n\t\t\treturn value === '0px' ? 0 : value;\n\t\t}\n\n\t\tif ( !isArray( props ) ) {\n\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t}\n\n\t\tvar styles = {};\n\n\t\tvar i = props.length;\n\t\twhile ( i-- ) {\n\t\t\tvar prop = props[i];\n\t\t\tvar value$1 = computedStyle[ prefix$1( prop ) ];\n\n\t\t\tif ( value$1 === '0px' ) value$1 = 0;\n\t\t\tstyles[ prop ] = value$1;\n\t\t}\n\n\t\treturn styles;\n\t};\n\n\tTransition.prototype.processParams = function processParams ( params, defaults ) {\n\t\tif ( typeof params === 'number' ) {\n\t\t\tparams = { duration: params };\n\t\t}\n\n\t\telse if ( typeof params === 'string' ) {\n\t\t\tif ( params === 'slow' ) {\n\t\t\t\tparams = { duration: 600 };\n\t\t\t} else if ( params === 'fast' ) {\n\t\t\t\tparams = { duration: 200 };\n\t\t\t} else {\n\t\t\t\tparams = { duration: 400 };\n\t\t\t}\n\t\t} else if ( !params ) {\n\t\t\tparams = {};\n\t\t}\n\n\t\treturn extendObj( {}, defaults, params );\n\t};\n\n\tTransition.prototype.rebinding = function rebinding ( next, previous ) {\n\t\tvar idx = this.models.indexOf( previous );\n\t\tif ( !~idx ) return;\n\n\t\tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n\t\tif ( next === previous ) return;\n\n\t\tprevious.unregister( this );\n\t\tthis.models.splice( idx, 1, next );\n\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t};\n\n\tTransition.prototype.registerCompleteHandler = function registerCompleteHandler ( fn ) {\n\t\taddToArray( this.onComplete, fn );\n\t};\n\n\tTransition.prototype.render = function render () {};\n\n\tTransition.prototype.setStyle = function setStyle ( style, value ) {\n\t\tif ( typeof style === 'string' ) {\n\t\t\tthis.node.style[ prefix$1( style ) ] = value;\n\t\t}\n\n\t\telse {\n\t\t\tvar prop;\n\t\t\tfor ( prop in style ) {\n\t\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\t\tthis.node.style[ prefix$1( prop ) ] = style[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tTransition.prototype.start = function start () {\n\t\tvar this$1 = this;\n\n\t\t\tvar node = this.node = this.element.node;\n\t\tvar originalStyle = node.getAttribute( 'style' );\n\n\t\tvar completed;\n\t\tvar args = this.params;\n\n\t\t// create t.complete() - we don't want this on the prototype,\n\t\t// because we don't want `this` silliness when passing it as\n\t\t// an argument\n\t\tthis.complete = function ( noReset ) {\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis$1.onComplete.forEach( function ( fn ) { return fn(); } );\n\t\t\tif ( !noReset && this$1.isIntro ) {\n\t\t\t\tresetStyle( node, originalStyle);\n\t\t\t}\n\n\t\t\tthis$1._manager.remove( this$1 );\n\n\t\t\tcompleted = true;\n\t\t};\n\n\t\t// If the transition function doesn't exist, abort\n\t\tif ( !this._fn ) {\n\t\t\tthis.complete();\n\t\t\treturn;\n\t\t}\n\n\t\t// get expression args if supplied\n\t\tif ( this.argsFn ) {\n\t\t\tvar values = this.models.map( function ( model ) {\n\t\t\t\tif ( !model ) return undefined;\n\n\t\t\t\treturn model.get();\n\t\t\t});\n\t\t\targs = this.argsFn.apply( this.ractive, values );\n\t\t}\n\n\t\tvar promise = this._fn.apply( this.ractive, [ this ].concat( args ) );\n\t\tif ( promise ) promise.then( this.complete );\n\t};\n\n\tTransition.prototype.toString = function toString () { return ''; };\n\n\tTransition.prototype.unbind = function unbind$1 () {\n\t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t\tif ( !this.element.attributes.unbinding ) {\n\t\t\tvar type = this.options && this.options.template && this.options.template.v;\n\t\t\tif ( type === 't0' || type === 't1' ) this.element._introTransition = null;\n\t\t\tif ( type === 't0' || type === 't2' ) this.element._outroTransition = null;\n\t\t}\n\t};\n\n\tTransition.prototype.unregisterCompleteHandler = function unregisterCompleteHandler ( fn ) {\n\t\tremoveFromArray( this.onComplete, fn );\n\t};\n\n\tTransition.prototype.unrender = function unrender () {};\n\n\tTransition.prototype.update = function update () {};\n\n\tvar elementCache = {};\n\n\tvar ieBug;\n\tvar ieBlacklist;\n\n\ttry {\n\t\tcreateElement( 'table' ).innerHTML = 'foo';\n\t} catch ( err ) {\n\t\tieBug = true;\n\n\t\tieBlacklist = {\n\t\t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n\t\t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n\t\t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n\t\t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n\t\t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n\t\t};\n\t}\n\n\tfunction insertHtml ( html, node, docFrag ) {\n\t\tvar nodes = [];\n\n\t\t// render 0 and false\n\t\tif ( html == null || html === '' ) return nodes;\n\n\t\tvar container;\n\t\tvar wrapper;\n\t\tvar selectedOption;\n\n\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n\t\t\tcontainer = container.querySelector( '.x' );\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\telse if ( node.namespaceURI === svg$1 ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\tcontainer = container.querySelector( '.x' );\n\t\t}\n\n\t\telse if ( node.tagName === 'TEXTAREA' ) {\n\t\t\tcontainer = createElement( 'div' );\n\n\t\t\tif ( typeof container.textContent !== 'undefined' ) {\n\t\t\t\tcontainer.textContent = html;\n\t\t\t} else {\n\t\t\t\tcontainer.innerHTML = html;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tcontainer = element( node.tagName );\n\t\t\tcontainer.innerHTML = html;\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\tvar child;\n\t\twhile ( child = container.firstChild ) {\n\t\t\tnodes.push( child );\n\t\t\tdocFrag.appendChild( child );\n\t\t}\n\n\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t// temporary container <select> causes the remaining ones to\n\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t// amaze me. You really do\n\t\t// ...and now Chrome too\n\t\tvar i;\n\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\ti = nodes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( nodes[i] !== selectedOption ) {\n\t\t\t\t\tnodes[i].selected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\tfunction element ( tagName ) {\n\t\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n\t}\n\n\tvar Triple = (function (Mustache) {\n\t\tfunction Triple ( options ) {\n\t\t\tMustache.call( this, options );\n\t\t}\n\n\t\tTriple.prototype = Object.create( Mustache && Mustache.prototype );\n\t\tTriple.prototype.constructor = Triple;\n\n\t\tTriple.prototype.detach = function detach () {\n\t\t\tvar docFrag = createDocumentFragment();\n\t\t\tthis.nodes.forEach( function ( node ) { return docFrag.appendChild( node ); } );\n\t\t\treturn docFrag;\n\t\t};\n\n\t\tTriple.prototype.find = function find ( selector ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar len = this.nodes.length;\n\t\t\tvar i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar node = this$1.nodes[i];\n\n\t\t\t\tif ( node.nodeType !== 1 ) continue;\n\n\t\t\t\tif ( matches( node, selector ) ) return node;\n\n\t\t\t\tvar queryResult = node.querySelector( selector );\n\t\t\t\tif ( queryResult ) return queryResult;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tTriple.prototype.findAll = function findAll ( selector, query ) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar len = this.nodes.length;\n\t\t\tvar i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar node = this$1.nodes[i];\n\n\t\t\t\tif ( node.nodeType !== 1 ) continue;\n\n\t\t\t\tif ( query.test( node ) ) query.add( node );\n\n\t\t\t\tvar queryAllResult = node.querySelectorAll( selector );\n\t\t\t\tif ( queryAllResult ) {\n\t\t\t\t\tvar numNodes = queryAllResult.length;\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\t\t\tquery.add( queryAllResult[j] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tTriple.prototype.findComponent = function findComponent () {\n\t\t\treturn null;\n\t\t};\n\n\t\tTriple.prototype.firstNode = function firstNode () {\n\t\t\treturn this.nodes[0];\n\t\t};\n\n\t\tTriple.prototype.render = function render ( target ) {\n\t\t\tvar html = this.model ? this.model.get() : '';\n\t\t\tthis.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );\n\t\t\tthis.rendered = true;\n\t\t};\n\n\t\tTriple.prototype.toString = function toString () {\n\t\t\treturn this.model && this.model.get() != null ? decodeCharacterReferences( '' + this.model.get() ) : '';\n\t\t};\n\n\t\tTriple.prototype.unrender = function unrender () {\n\t\t\tif ( this.nodes ) this.nodes.forEach( function ( node ) { return detachNode( node ); } );\n\t\t\tthis.rendered = false;\n\t\t};\n\n\t\tTriple.prototype.update = function update () {\n\t\t\tif ( this.rendered && this.dirty ) {\n\t\t\t\tthis.dirty = false;\n\n\t\t\t\tthis.unrender();\n\t\t\t\tvar docFrag = createDocumentFragment();\n\t\t\t\tthis.render( docFrag );\n\n\t\t\t\tvar parentNode = this.parentFragment.findParentNode();\n\t\t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\n\t\t\t\tparentNode.insertBefore( docFrag, anchor );\n\t\t\t} else {\n\t\t\t\t// make sure to reset the dirty flag even if not rendered\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\t\t};\n\n\t\treturn Triple;\n\t}(Mustache));\n\n\tvar Yielder = (function (Item) {\n\t\tfunction Yielder ( options ) {\n\t\t\tItem.call( this, options );\n\n\t\t\tthis.container = options.parentFragment.ractive;\n\t\t\tthis.component = this.container.component;\n\n\t\t\tthis.containerFragment = options.parentFragment;\n\t\t\tthis.parentFragment = this.component.parentFragment;\n\n\t\t\t// {{yield}} is equivalent to {{yield content}}\n\t\t\tthis.name = options.template.n || '';\n\t\t}\n\n\t\tYielder.prototype = Object.create( Item && Item.prototype );\n\t\tYielder.prototype.constructor = Yielder;\n\n\t\tYielder.prototype.bind = function bind () {\n\t\t\tvar name = this.name;\n\n\t\t\t( this.component.yielders[ name ] || ( this.component.yielders[ name ] = [] ) ).push( this );\n\n\t\t\t// TODO don't parse here\n\t\t\tvar template = this.container._inlinePartials[ name || 'content' ];\n\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\ttemplate = parse( template ).t;\n\t\t\t}\n\n\t\t\tif ( !template ) {\n\t\t\t\twarnIfDebug( (\"Could not find template for partial \\\"\" + name + \"\\\"\"), { ractive: this.ractive });\n\t\t\t\ttemplate = [];\n\t\t\t}\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\towner: this,\n\t\t\t\tractive: this.container.parent,\n\t\t\t\ttemplate: template\n\t\t\t}).bind();\n\t\t};\n\n\t\tYielder.prototype.bubble = function bubble () {\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.containerFragment.bubble();\n\t\t\t\tthis.dirty = true;\n\t\t\t}\n\t\t};\n\n\t\tYielder.prototype.detach = function detach () {\n\t\t\treturn this.fragment.detach();\n\t\t};\n\n\t\tYielder.prototype.find = function find ( selector ) {\n\t\t\treturn this.fragment.find( selector );\n\t\t};\n\n\t\tYielder.prototype.findAll = function findAll ( selector, queryResult ) {\n\t\t\tthis.fragment.findAll( selector, queryResult );\n\t\t};\n\n\t\tYielder.prototype.findComponent = function findComponent ( name ) {\n\t\t\treturn this.fragment.findComponent( name );\n\t\t};\n\n\t\tYielder.prototype.findAllComponents = function findAllComponents ( name, queryResult ) {\n\t\t\tthis.fragment.findAllComponents( name, queryResult );\n\t\t};\n\n\t\tYielder.prototype.findNextNode = function findNextNode() {\n\t\t\treturn this.containerFragment.findNextNode( this );\n\t\t};\n\n\t\tYielder.prototype.firstNode = function firstNode ( skipParent ) {\n\t\t\treturn this.fragment.firstNode( skipParent );\n\t\t};\n\n\t\tYielder.prototype.render = function render ( target, occupants ) {\n\t\t\treturn this.fragment.render( target, occupants );\n\t\t};\n\n\t\tYielder.prototype.setTemplate = function setTemplate ( name ) {\n\t\t\tvar template = this.parentFragment.ractive.partials[ name ];\n\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\ttemplate = parse( template ).t;\n\t\t\t}\n\n\t\t\tthis.partialTemplate = template || []; // TODO warn on missing partial\n\t\t};\n\n\t\tYielder.prototype.toString = function toString ( escape ) {\n\t\t\treturn this.fragment.toString( escape );\n\t\t};\n\n\t\tYielder.prototype.unbind = function unbind () {\n\t\t\tthis.fragment.unbind();\n\t\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t\t};\n\n\t\tYielder.prototype.unrender = function unrender ( shouldDestroy ) {\n\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t};\n\n\t\tYielder.prototype.update = function update () {\n\t\t\tthis.dirty = false;\n\t\t\tthis.fragment.update();\n\t\t};\n\n\t\treturn Yielder;\n\t}(Item));\n\n\t// finds the component constructor in the registry or view hierarchy registries\n\tfunction getComponentConstructor ( ractive, name ) {\n\t\tvar instance = findInstance( 'components', ractive, name );\n\t\tvar Component;\n\n\t\tif ( instance ) {\n\t\t\tComponent = instance.components[ name ];\n\n\t\t\t// best test we have for not Ractive.extend\n\t\t\tif ( !Component._Parent ) {\n\t\t\t\t// function option, execute and store for reset\n\t\t\t\tvar fn = Component.bind( instance );\n\t\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\t\tComponent = fn();\n\n\t\t\t\tif ( !Component ) {\n\t\t\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( typeof Component === 'string' ) {\n\t\t\t\t\t// allow string lookup\n\t\t\t\t\tComponent = getComponentConstructor( ractive, Component );\n\t\t\t\t}\n\n\t\t\t\tComponent._fn = fn;\n\t\t\t\tinstance.components[ name ] = Component;\n\t\t\t}\n\t\t}\n\n\t\treturn Component;\n\t}\n\n\tvar constructors = {};\n\tconstructors[ ALIAS ] = Alias;\n\tconstructors[ DOCTYPE ] = Doctype;\n\tconstructors[ INTERPOLATOR ] = Interpolator;\n\tconstructors[ PARTIAL ] = Partial;\n\tconstructors[ SECTION ] = Section;\n\tconstructors[ TRIPLE ] = Triple;\n\tconstructors[ YIELDER ] = Yielder;\n\n\tconstructors[ ATTRIBUTE ] = Attribute;\n\tconstructors[ BINDING_FLAG ] = BindingFlag;\n\tconstructors[ DECORATOR ] = Decorator;\n\tconstructors[ EVENT ] = EventDirective;\n\tconstructors[ TRANSITION ] = Transition;\n\n\tvar specialElements = {\n\t\tdoctype: Doctype,\n\t\tform: Form,\n\t\tinput: Input,\n\t\toption: Option,\n\t\tselect: Select,\n\t\ttextarea: Textarea\n\t};\n\n\tfunction createItem ( options ) {\n\t\tif ( typeof options.template === 'string' ) {\n\t\t\treturn new Text( options );\n\t\t}\n\n\t\tif ( options.template.t === ELEMENT ) {\n\t\t\t// could be component or element\n\t\t\tvar ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );\n\t\t\tif ( ComponentConstructor ) {\n\t\t\t\treturn new Component( options, ComponentConstructor );\n\t\t\t}\n\n\t\t\tvar tagName = options.template.e.toLowerCase();\n\n\t\t\tvar ElementConstructor = specialElements[ tagName ] || Element;\n\t\t\treturn new ElementConstructor( options );\n\t\t}\n\n\t\tvar Item;\n\n\t\t// component mappings are a special case of attribute\n\t\tif ( options.template.t === ATTRIBUTE ) {\n\t\t\tvar el = options.owner;\n\t\t\tif ( !el || ( el.type !== COMPONENT && el.type !== ELEMENT ) ) {\n\t\t\t\tel = findElement( options.parentFragment );\n\t\t\t}\n\t\t\toptions.element = el;\n\n\t\t\tItem = el.type === COMPONENT ? Mapping : Attribute;\n\t\t} else {\n\t\t\tItem = constructors[ options.template.t ];\n\t\t}\n\n\t\tif ( !Item ) throw new Error( (\"Unrecognised item type \" + (options.template.t)) );\n\n\t\treturn new Item( options );\n\t}\n\n\t// TODO all this code needs to die\n\tfunction processItems ( items, values, guid, counter ) {\n\t\tif ( counter === void 0 ) counter = 0;\n\n\t\treturn items.map( function ( item ) {\n\t\t\tif ( item.type === TEXT ) {\n\t\t\t\treturn item.template;\n\t\t\t}\n\n\t\t\tif ( item.fragment ) {\n\t\t\t\tif ( item.fragment.iterations ) {\n\t\t\t\t\treturn item.fragment.iterations.map( function ( fragment ) {\n\t\t\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t\t\t\t\t}).join( '' );\n\t\t\t\t} else {\n\t\t\t\t\treturn processItems( item.fragment.items, values, guid, counter );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar placeholderId = \"\" + guid + \"-\" + (counter++);\n\t\t\tvar model = item.model || item.newModel;\n\n\t\t\tvalues[ placeholderId ] = model ?\n\t\t\t\tmodel.wrapper ?\n\t\t\t\t\tmodel.wrapperValue :\n\t\t\t\t\tmodel.get() :\n\t\t\t\tundefined;\n\n\t\t\treturn '${' + placeholderId + '}';\n\t\t}).join( '' );\n\t}\n\n\tfunction unrenderAndDestroy$1 ( item ) {\n\t\titem.unrender( true );\n\t}\n\n\tvar Fragment = function Fragment ( options ) {\n\t\tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\n\t\tthis.isRoot = !options.owner.parentFragment;\n\t\tthis.parent = this.isRoot ? null : this.owner.parentFragment;\n\t\tthis.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );\n\n\t\tthis.componentParent = ( this.isRoot && this.ractive.component ) ? this.ractive.component.parentFragment : null;\n\n\t\tthis.context = null;\n\t\tthis.rendered = false;\n\n\t\t// encapsulated styles should be inherited until they get applied by an element\n\t\tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\n\t\tthis.resolvers = [];\n\n\t\tthis.dirty = false;\n\t\tthis.dirtyArgs = this.dirtyValue = true; // TODO getArgsList is nonsense - should deprecate legacy directives style\n\n\t\tthis.template = options.template || [];\n\t\tthis.createItems();\n\t};\n\n\tFragment.prototype.bind = function bind$1$$ ( context ) {\n\t\tthis.context = context;\n\t\tthis.items.forEach( bind$1 );\n\t\tthis.bound = true;\n\n\t\t// in rare cases, a forced resolution (or similar) will cause the\n\t\t// fragment to be dirty before it's even finished binding. In those\n\t\t// cases we update immediately\n\t\tif ( this.dirty ) this.update();\n\n\t\treturn this;\n\t};\n\n\tFragment.prototype.bubble = function bubble () {\n\t\tthis.dirtyArgs = this.dirtyValue = true;\n\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\n\t\t\tif ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?\n\t\t\t\tif ( this.ractive.component ) {\n\t\t\t\t\tthis.ractive.component.bubble();\n\t\t\t\t} else if ( this.bound ) {\n\t\t\t\t\trunloop.addFragment( this );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.owner.bubble();\n\t\t\t}\n\t\t}\n\t};\n\n\tFragment.prototype.createItems = function createItems () {\n\t\t// this is a hot code path\n\t\tvar this$1 = this;\n\n\t\t\tvar max = this.template.length;\n\t\tthis.items = [];\n\t\tfor ( var i = 0; i < max; i++ ) {\n\t\t\tthis$1.items[i] = createItem({ parentFragment: this$1, template: this$1.template[i], index: i });\n\t\t}\n\t};\n\n\tFragment.prototype.destroyed = function destroyed () {\n\t\tthis.items.forEach( function ( i ) { return i.destroyed(); } );\n\t};\n\n\tFragment.prototype.detach = function detach () {\n\t\tvar docFrag = createDocumentFragment();\n\t\tthis.items.forEach( function ( item ) { return docFrag.appendChild( item.detach() ); } );\n\t\treturn docFrag;\n\t};\n\n\tFragment.prototype.find = function find ( selector ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar len = this.items.length;\n\t\tvar i;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tvar found = this$1.items[i].find( selector );\n\t\t\tif ( found ) return found;\n\t\t}\n\t};\n\n\tFragment.prototype.findAll = function findAll ( selector, query ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.items ) {\n\t\t\tvar len = this.items.length;\n\t\t\tvar i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar item = this$1.items[i];\n\n\t\t\t\tif ( item.findAll ) {\n\t\t\t\t\titem.findAll( selector, query );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn query;\n\t};\n\n\tFragment.prototype.findComponent = function findComponent ( name ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar len = this.items.length;\n\t\tvar i;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tvar found = this$1.items[i].findComponent( name );\n\t\t\tif ( found ) return found;\n\t\t}\n\t};\n\n\tFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t\tvar this$1 = this;\n\n\t\t\tif ( this.items ) {\n\t\t\tvar len = this.items.length;\n\t\t\tvar i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar item = this$1.items[i];\n\n\t\t\t\tif ( item.findAllComponents ) {\n\t\t\t\t\titem.findAllComponents( name, query );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn query;\n\t};\n\n\tFragment.prototype.findContext = function findContext () {\n\t\tvar fragment = this;\n\t\twhile ( fragment && !fragment.context ) fragment = fragment.parent;\n\t\tif ( !fragment ) return this.ractive.viewmodel;\n\t\telse return fragment.context;\n\t};\n\n\tFragment.prototype.findNextNode = function findNextNode ( item ) {\n\t\t// search for the next node going forward\n\t\tvar this$1 = this;\n\n\t\t\tif ( item ) {\n\t\t\tfor ( var i = item.index + 1; i < this$1.items.length; i++ ) {\n\t\t\t\tif ( !this$1.items[ i ] ) continue;\n\n\t\t\t\tvar node = this$1.items[ i ].firstNode( true );\n\t\t\t\tif ( node ) return node;\n\t\t\t}\n\t\t}\n\n\t\t// if this is the root fragment, and there are no more items,\n\t\t// it means we're at the end...\n\t\tif ( this.isRoot ) {\n\t\t\tif ( this.ractive.component ) {\n\t\t\t\treturn this.ractive.component.parentFragment.findNextNode( this.ractive.component );\n\t\t\t}\n\n\t\t\t// TODO possible edge case with other content\n\t\t\t// appended to this.ractive.el?\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( this.parent ) return this.owner.findNextNode( this ); // the argument is in case the parent is a RepeatedFragment\n\t};\n\n\tFragment.prototype.findParentNode = function findParentNode () {\n\t\tvar fragment = this;\n\n\t\tdo {\n\t\t\tif ( fragment.owner.type === ELEMENT ) {\n\t\t\t\treturn fragment.owner.node;\n\t\t\t}\n\n\t\t\tif ( fragment.isRoot && !fragment.ractive.component ) { // TODO encapsulate check\n\t\t\t\treturn fragment.ractive.el;\n\t\t\t}\n\n\t\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\t\tfragment = fragment.owner.containerFragment;\n\t\t\t} else {\n\t\t\t\tfragment = fragment.componentParent || fragment.parent; // TODO ugh\n\t\t\t}\n\t\t} while ( fragment );\n\n\t\tthrow new Error( 'Could not find parent node' ); // TODO link to issue tracker\n\t};\n\n\tFragment.prototype.findRepeatingFragment = function findRepeatingFragment () {\n\t\tvar fragment = this;\n\t\t// TODO better check than fragment.parent.iterations\n\t\twhile ( ( fragment.parent || fragment.componentParent ) && !fragment.isIteration ) {\n\t\t\tfragment = fragment.parent || fragment.componentParent;\n\t\t}\n\n\t\treturn fragment;\n\t};\n\n\tFragment.prototype.firstNode = function firstNode ( skipParent ) {\n\t\tvar this$1 = this;\n\n\t\t\tvar node;\n\t\tfor ( var i = 0; i < this$1.items.length; i++ ) {\n\t\t\tnode = this$1.items[i].firstNode( true );\n\n\t\t\tif ( node ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\n\t\tif ( skipParent ) return null;\n\n\t\treturn this.parent.findNextNode( this.owner );\n\t};\n\n\t// TODO ideally, this would be deprecated in favour of an\n\t// expression-like approach\n\tFragment.prototype.getArgsList = function getArgsList () {\n\t\tif ( this.dirtyArgs ) {\n\t\t\tvar values = {};\n\t\t\tvar source = processItems( this.items, values, this.ractive._guid );\n\t\t\tvar parsed = parseJSON( '[' + source + ']', values );\n\n\t\t\tthis.argsList = parsed ?\n\t\t\t\tparsed.value :\n\t\t\t\t[ this.toString() ];\n\n\t\t\tthis.dirtyArgs = false;\n\t\t}\n\n\t\treturn this.argsList;\n\t};\n\n\tFragment.prototype.rebinding = function rebinding ( next ) {\n\t\tthis.context = next;\n\t};\n\n\tFragment.prototype.render = function render ( target, occupants ) {\n\t\tif ( this.rendered ) throw new Error( 'Fragment is already rendered!' );\n\t\tthis.rendered = true;\n\n\t\tthis.items.forEach( function ( item ) { return item.render( target, occupants ); } );\n\t};\n\n\tFragment.prototype.resetTemplate = function resetTemplate ( template ) {\n\t\tvar wasBound = this.bound;\n\t\tvar wasRendered = this.rendered;\n\n\t\t// TODO ensure transitions are disabled globally during reset\n\n\t\tif ( wasBound ) {\n\t\t\tif ( wasRendered ) this.unrender( true );\n\t\t\tthis.unbind();\n\t\t}\n\n\t\tthis.template = template;\n\t\tthis.createItems();\n\n\t\tif ( wasBound ) {\n\t\t\tthis.bind( this.context );\n\n\t\t\tif ( wasRendered ) {\n\t\t\t\tvar parentNode = this.findParentNode();\n\t\t\t\tvar anchor = this.findNextNode();\n\n\t\t\t\tif ( anchor ) {\n\t\t\t\t\tvar docFrag = createDocumentFragment();\n\t\t\t\t\tthis.render( docFrag );\n\t\t\t\t\tparentNode.insertBefore( docFrag, anchor );\n\t\t\t\t} else {\n\t\t\t\t\tthis.render( parentNode );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tFragment.prototype.resolve = function resolve ( template, callback ) {\n\t\tif ( !this.context && this.parent.resolve ) {\n\t\t\treturn this.parent.resolve( template, callback );\n\t\t}\n\n\t\tvar resolver = new ReferenceResolver( this, template, callback );\n\t\tthis.resolvers.push( resolver );\n\n\t\treturn resolver; // so we can e.g. force resolution\n\t};\n\n\tFragment.prototype.shuffled = function shuffled () {\n\t\tthis.items.forEach( function ( i ) { return i.shuffled(); } );\n\t};\n\n\tFragment.prototype.toHtml = function toHtml () {\n\t\treturn this.toString();\n\t};\n\n\tFragment.prototype.toString = function toString$1$$ ( escape ) {\n\t\treturn this.items.map( escape ? toEscapedString : toString$1 ).join( '' );\n\t};\n\n\tFragment.prototype.unbind = function unbind$1 () {\n\t\tthis.items.forEach( unbind );\n\t\tthis.bound = false;\n\n\t\treturn this;\n\t};\n\n\tFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t\tthis.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );\n\t\tthis.rendered = false;\n\t};\n\n\tFragment.prototype.update = function update$1 () {\n\t\tif ( this.dirty ) {\n\t\t\tif ( !this.updating ) {\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.items.forEach( update );\n\t\t\t\tthis.updating = false;\n\t\t\t} else if ( this.isRoot ) {\n\t\t\t\trunloop.addFragmentToRoot( this );\n\t\t\t}\n\t\t}\n\t};\n\n\tFragment.prototype.valueOf = function valueOf () {\n\t\tif ( this.items.length === 1 ) {\n\t\t\treturn this.items[0].valueOf();\n\t\t}\n\n\t\tif ( this.dirtyValue ) {\n\t\t\tvar values = {};\n\t\t\tvar source = processItems( this.items, values, this.ractive._guid );\n\t\t\tvar parsed = parseJSON( source, values );\n\n\t\t\tthis.value = parsed ?\n\t\t\t\tparsed.value :\n\t\t\t\tthis.toString();\n\n\t\t\tthis.dirtyValue = false;\n\t\t}\n\n\t\treturn this.value;\n\t};\n\n\t// TODO should resetTemplate be asynchronous? i.e. should it be a case\n\t// of outro, update template, intro? I reckon probably not, since that\n\t// could be achieved with unrender-resetTemplate-render. Also, it should\n\t// conceptually be similar to resetPartial, which couldn't be async\n\n\tfunction Ractive$resetTemplate ( template ) {\n\t\ttemplateConfigurator.init( null, this, { template: template });\n\n\t\tvar transitionsEnabled = this.transitionsEnabled;\n\t\tthis.transitionsEnabled = false;\n\n\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t// flag, otherwise it will assume by default that a parent node\n\t\t// will be detached, and therefore it doesn't need to bother\n\t\t// detaching its own nodes\n\t\tvar component = this.component;\n\t\tif ( component ) component.shouldDestroy = true;\n\t\tthis.unrender();\n\t\tif ( component ) component.shouldDestroy = false;\n\n\t\t// remove existing fragment and create new one\n\t\tthis.fragment.unbind().unrender( true );\n\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: this.template,\n\t\t\troot: this,\n\t\t\towner: this\n\t\t});\n\n\t\tvar docFrag = createDocumentFragment();\n\t\tthis.fragment.bind( this.viewmodel ).render( docFrag );\n\n\t\t// if this is a component, its el may not be valid, so find a\n\t\t// target based on the component container\n\t\tif ( component ) {\n\t\t\tthis.fragment.findParentNode().insertBefore( docFrag, component.findNextNode() );\n\t\t} else {\n\t\t\tthis.el.insertBefore( docFrag, this.anchor );\n\t\t}\n\n\t\tthis.transitionsEnabled = transitionsEnabled;\n\t}\n\n\tvar reverse$1 = makeArrayMethod( 'reverse' ).path;\n\n\tfunction Ractive$set ( keypath, value ) {\n\t\tvar ractive = this;\n\n\t\treturn set( ractive, build( ractive, keypath, value ) );\n\t}\n\n\tvar shift$1 = makeArrayMethod( 'shift' ).path;\n\n\tvar sort$1 = makeArrayMethod( 'sort' ).path;\n\n\tvar splice$1 = makeArrayMethod( 'splice' ).path;\n\n\tfunction Ractive$subtract ( keypath, d ) {\n\t\treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n\t}\n\n\tvar teardownHook$1 = new Hook( 'teardown' );\n\n\t// Teardown. This goes through the root fragment and all its children, removing observers\n\t// and generally cleaning up after itself\n\n\tfunction Ractive$teardown () {\n\t\tif ( this.torndown ) {\n\t\t\twarnIfDebug( 'ractive.teardown() was called on a Ractive instance that was already torn down' );\n\t\t\treturn Promise$1.resolve();\n\t\t}\n\n\t\tthis.torndown = true;\n\t\tthis.fragment.unbind();\n\t\tthis.viewmodel.teardown();\n\n\t\tthis._observers.forEach( cancel );\n\n\t\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t}\n\n\t\tthis.shouldDestroy = true;\n\t\tvar promise = ( this.fragment.rendered ? this.unrender() : Promise$1.resolve() );\n\n\t\tteardownHook$1.fire( this );\n\n\t\treturn promise;\n\t}\n\n\tfunction Ractive$toggle ( keypath ) {\n\t\tif ( typeof keypath !== 'string' ) {\n\t\t\tthrow new TypeError( badArguments );\n\t\t}\n\n\t\treturn set( this, gather( this, keypath ).map( function ( m ) { return [ m, !m.get() ]; } ) );\n\t}\n\n\tfunction Ractive$toCSS() {\n\t\tvar cssIds = [ this.cssId ].concat( this.findAllComponents().map( function ( c ) { return c.cssId; } ) );\n\t\tvar uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));\n\t\treturn getCSS( uniqueCssIds );\n\t}\n\n\tfunction Ractive$toHTML () {\n\t\treturn this.fragment.toString( true );\n\t}\n\n\tfunction toText () {\n\t\treturn this.fragment.toString( false );\n\t}\n\n\tfunction Ractive$transition ( name, node, params ) {\n\n\t\tif ( node instanceof HTMLElement ) {\n\t\t\t// good to go\n\t\t}\n\t\telse if ( isObject( node ) ) {\n\t\t\t// omitted, use event node\n\t\t\tparams = node;\n\t\t}\n\n\t\t// if we allow query selector, then it won't work\n\t\t// simple params like \"fast\"\n\n\t\t// else if ( typeof node === 'string' ) {\n\t\t// \t// query selector\n\t\t// \tnode = this.find( node )\n\t\t// }\n\n\t\tnode = node || this.event.node;\n\n\t\tif ( !node || !node._ractive ) {\n\t\t\tfatal( (\"No node was supplied for transition \" + name) );\n\t\t}\n\n\t\tparams = params || {};\n\t\tvar owner = node._ractive.proxy;\n\t\tvar transition = new Transition({ owner: owner, parentFragment: owner.parentFragment, name: name, params: params });\n\t\ttransition.bind();\n\n\t\tvar promise = runloop.start( this, true );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.end();\n\n\t\tpromise.then( function () { return transition.unbind(); } );\n\t\treturn promise;\n\t}\n\n\tfunction unlink$1( here ) {\n\t\tvar promise = runloop.start();\n\t\tthis.viewmodel.joinAll( splitKeypathI( here ), { lastLink: false } ).unlink();\n\t\trunloop.end();\n\t\treturn promise;\n\t}\n\n\tvar unrenderHook$1 = new Hook( 'unrender' );\n\n\tfunction Ractive$unrender () {\n\t\tif ( !this.fragment.rendered ) {\n\t\t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t\t\treturn Promise$1.resolve();\n\t\t}\n\n\t\tvar promise = runloop.start( this, true );\n\n\t\t// If this is a component, and the component isn't marked for destruction,\n\t\t// don't detach nodes from the DOM unnecessarily\n\t\tvar shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\t\tthis.fragment.unrender( shouldDestroy );\n\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\n\t\tunrenderHook$1.fire( this );\n\n\t\trunloop.end();\n\t\treturn promise;\n\t}\n\n\tvar unshift$1 = makeArrayMethod( 'unshift' ).path;\n\n\tfunction Ractive$updateModel ( keypath, cascade ) {\n\t\tvar promise = runloop.start( this, true );\n\n\t\tif ( !keypath ) {\n\t\t\tthis.viewmodel.updateFromBindings( true );\n\t\t} else {\n\t\t\tthis.viewmodel.joinAll( splitKeypathI( keypath ) ).updateFromBindings( cascade !== false );\n\t\t}\n\n\t\trunloop.end();\n\n\t\treturn promise;\n\t}\n\n\tvar proto = {\n\t\tadd: Ractive$add,\n\t\tanimate: Ractive$animate,\n\t\tdetach: Ractive$detach,\n\t\tfind: Ractive$find,\n\t\tfindAll: Ractive$findAll,\n\t\tfindAllComponents: Ractive$findAllComponents,\n\t\tfindComponent: Ractive$findComponent,\n\t\tfindContainer: Ractive$findContainer,\n\t\tfindParent: Ractive$findParent,\n\t\tfire: Ractive$fire,\n\t\tget: Ractive$get,\n\t\tgetNodeInfo: getNodeInfo,\n\t\tinsert: Ractive$insert,\n\t\tlink: link$1,\n\t\tmerge: thisRactive$merge,\n\t\tobserve: observe,\n\t\tobserveList: observeList,\n\t\tobserveOnce: observeOnce,\n\t\t// TODO reinstate these\n\t\t// observeListOnce,\n\t\toff: Ractive$off,\n\t\ton: Ractive$on,\n\t\tonce: Ractive$once,\n\t\tpop: pop$1,\n\t\tpush: push$1,\n\t\trender: Ractive$render,\n\t\treset: Ractive$reset,\n\t\tresetPartial: resetPartial,\n\t\tresetTemplate: Ractive$resetTemplate,\n\t\treverse: reverse$1,\n\t\tset: Ractive$set,\n\t\tshift: shift$1,\n\t\tsort: sort$1,\n\t\tsplice: splice$1,\n\t\tsubtract: Ractive$subtract,\n\t\tteardown: Ractive$teardown,\n\t\ttoggle: Ractive$toggle,\n\t\ttoCSS: Ractive$toCSS,\n\t\ttoCss: Ractive$toCSS,\n\t\ttoHTML: Ractive$toHTML,\n\t\ttoHtml: Ractive$toHTML,\n\t\ttoText: toText,\n\t\ttransition: Ractive$transition,\n\t\tunlink: unlink$1,\n\t\tunrender: Ractive$unrender,\n\t\tunshift: unshift$1,\n\t\tupdate: Ractive$update,\n\t\tupdateModel: Ractive$updateModel\n\t};\n\n\tfunction wrap$1 ( method, superMethod, force ) {\n\n\t\tif ( force || needsSuper( method, superMethod ) )  {\n\n\t\t\treturn function () {\n\n\t\t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\n\t\t\t\tthis._super = superMethod;\n\n\t\t\t\tresult = method.apply( this, arguments );\n\n\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\tthis._super = _super;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\n\t\telse {\n\t\t\treturn method;\n\t\t}\n\t}\n\n\tfunction needsSuper ( method, superMethod ) {\n\t\treturn typeof superMethod === 'function' && /_super/.test( method );\n\t}\n\n\tfunction unwrap ( Child ) {\n\t\tvar options = {};\n\n\t\twhile ( Child ) {\n\t\t\taddRegistries( Child, options );\n\t\t\taddOtherOptions( Child, options );\n\n\t\t\tif ( Child._Parent !== Ractive ) {\n\t\t\t\tChild = Child._Parent;\n\t\t\t} else {\n\t\t\t\tChild = false;\n\t\t\t}\n\t\t}\n\n\t\treturn options;\n\t}\n\n\tfunction addRegistries ( Child, options ) {\n\t\tregistries.forEach( function ( r ) {\n\t\t\taddRegistry(\n\t\t\t\tr.useDefaults ? Child.prototype : Child,\n\t\t\t\toptions, r.name );\n\t\t});\n\t}\n\n\tfunction addRegistry ( target, options, name ) {\n\t\tvar registry, keys = Object.keys( target[ name ] );\n\n\t\tif ( !keys.length ) { return; }\n\n\t\tif ( !( registry = options[ name ] ) ) {\n\t\t\tregistry = options[ name ] = {};\n\t\t}\n\n\t\tkeys\n\t\t\t.filter( function ( key ) { return !( key in registry ); } )\n\t\t\t.forEach( function ( key ) { return registry[ key ] = target[ name ][ key ]; } );\n\t}\n\n\tfunction addOtherOptions ( Child, options ) {\n\t\tObject.keys( Child.prototype ).forEach( function ( key ) {\n\t\t\tif ( key === 'computed' ) { return; }\n\n\t\t\tvar value = Child.prototype[ key ];\n\n\t\t\tif ( !( key in options ) ) {\n\t\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t\t}\n\n\t\t\t// is it a wrapped function?\n\t\t\telse if ( typeof options[ key ] === 'function'\n\t\t\t\t\t&& typeof value === 'function'\n\t\t\t\t\t&& options[ key ]._method ) {\n\n\t\t\t\tvar result, needsSuper = value._method;\n\n\t\t\t\tif ( needsSuper ) { value = value._method; }\n\n\t\t\t\t// rewrap bound directly to parent fn\n\t\t\t\tresult = wrap$1( options[ key ]._method, value );\n\n\t\t\t\tif ( needsSuper ) { result._method = result; }\n\n\t\t\t\toptions[ key ] = result;\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction extend () {\n\t\tvar options = [], len = arguments.length;\n\t\twhile ( len-- ) options[ len ] = arguments[ len ];\n\n\t\tif( !options.length ) {\n\t\t\treturn extendOne( this );\n\t\t} else {\n\t\t\treturn options.reduce( extendOne, this );\n\t\t}\n\t}\n\n\tfunction extendOne ( Parent, options ) {\n\t\tif ( options === void 0 ) options = {};\n\n\t\tvar Child, proto;\n\n\t\t// if we're extending with another Ractive instance...\n\t\t//\n\t\t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t\t//   var Spiderman = Human.extend( Spider );\n\t\t//\n\t\t// ...inherit prototype methods and default options as well\n\t\tif ( options.prototype instanceof Ractive ) {\n\t\t\toptions = unwrap( options );\n\t\t}\n\n\t\tChild = function ( options ) {\n\t\t\tif ( !( this instanceof Child ) ) return new Child( options );\n\n\t\t\tconstruct( this, options || {} );\n\t\t\tinitialise( this, options || {}, {} );\n\t\t};\n\n\t\tproto = create( Parent.prototype );\n\t\tproto.constructor = Child;\n\n\t\t// Static properties\n\t\tdefineProperties( Child, {\n\t\t\t// alias prototype as defaults\n\t\t\tdefaults: { value: proto },\n\n\t\t\t// extendable\n\t\t\textend: { value: extend, writable: true, configurable: true },\n\n\t\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t\t_Parent: { value: Parent }\n\t\t});\n\n\t\t// extend configuration\n\t\tconfig.extend( Parent, proto, options );\n\n\t\tdataConfigurator.extend( Parent, proto, options );\n\n\t\tif ( options.computed ) {\n\t\t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n\t\t}\n\n\t\tChild.prototype = proto;\n\n\t\treturn Child;\n\t}\n\n\tfunction joinKeys () {\n\t\tvar keys = [], len = arguments.length;\n\t\twhile ( len-- ) keys[ len ] = arguments[ len ];\n\n\t\treturn keys.map( escapeKey ).join( '.' );\n\t}\n\n\tfunction splitKeypath ( keypath ) {\n\t\treturn splitKeypathI( keypath ).map( unescapeKey );\n\t}\n\n\t// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n\t// older browsers, these are made available via a shim - here, we do a quick\n\t// pre-flight check to make sure that either a) we're not in a shit browser,\n\t// or b) we're using a Ractive-legacy.js build\n\tvar FUNCTION = 'function';\n\n\tif (\n\t\ttypeof Date.now !== FUNCTION                 ||\n\t\ttypeof String.prototype.trim !== FUNCTION    ||\n\t\ttypeof Object.keys !== FUNCTION              ||\n\t\ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\t\ttypeof Array.prototype.forEach !== FUNCTION  ||\n\t\ttypeof Array.prototype.map !== FUNCTION      ||\n\t\ttypeof Array.prototype.filter !== FUNCTION   ||\n\t\t( win && typeof win.addEventListener !== FUNCTION )\n\t) {\n\t\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n\t}\n\n\tfunction Ractive ( options ) {\n\t\tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\n\t\tconstruct( this, options || {} );\n\t\tinitialise( this, options || {}, {} );\n\t}\n\n\textendObj( Ractive.prototype, proto, defaults );\n\tRactive.prototype.constructor = Ractive;\n\n\t// alias prototype as `defaults`\n\tRactive.defaults = Ractive.prototype;\n\n\t// static properties\n\tdefineProperties( Ractive, {\n\n\t\t// debug flag\n\t\tDEBUG:          { writable: true, value: true },\n\t\tDEBUG_PROMISES: { writable: true, value: true },\n\n\t\t// static methods:\n\t\textend:         { value: extend },\n\t\tescapeKey:      { value: escapeKey },\n\t\tgetNodeInfo:    { value: staticInfo },\n\t\tjoinKeys:       { value: joinKeys },\n\t\tparse:          { value: parse },\n\t\tsplitKeypath:   { value: splitKeypath },\n\t\tunescapeKey:    { value: unescapeKey },\n\t\tgetCSS:         { value: getCSS },\n\n\t\t// namespaced constructors\n\t\tPromise:        { value: Promise$1 },\n\n\t\t// support\n\t\tenhance:        { writable: true, value: false },\n\t\tsvg:            { value: svg },\n\t\tmagic:          { value: magicSupported },\n\n\t\t// version\n\t\tVERSION:        { value: '0.8.9' },\n\n\t\t// plugins\n\t\tadaptors:       { writable: true, value: {} },\n\t\tcomponents:     { writable: true, value: {} },\n\t\tdecorators:     { writable: true, value: {} },\n\t\teasing:         { writable: true, value: easing },\n\t\tevents:         { writable: true, value: {} },\n\t\tinterpolators:  { writable: true, value: interpolators },\n\t\tpartials:       { writable: true, value: {} },\n\t\ttransitions:    { writable: true, value: {} }\n\t});\n\n\treturn Ractive;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ractive/ractive.js\n// module id = 1\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 2\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 3\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../node_modules/sass-loader/index.js!./main.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../node_modules/sass-loader/index.js!./main.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../node_modules/sass-loader/index.js!./main.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ractivePOC/components/main/main.scss\n// module id = 4\n// module chunks = 0","import $ from 'jquery';\n\nimport Ractive from 'ractive';\nimport css from './main.scss';\nimport template from './main.hbs';\n\nimport SortableDragList from './../shared/sortable/sortableDragList/sortableDragList.js';\nimport SortableDragItem from './../shared/sortable/sortableDragItem/sortableDragItem.js';\n\nconst Main = Ractive.extend({\n    template,\n    modifyArrays: true,\n    components: {\n        SortableDragList,\n        SortableDragItem\n    },\n    data: ()=>{return {\n        css,\n        list1: [\n            {key:0,value:'One'},\n            {key:1,value:'Two'},\n            {key:2,value:'Three'},\n            {key:3,value:'Four'},\n            {key:4,value:'Five'},\n            {key:5,value:'Six'},\n            {key:6,value:'Seven'},\n            {key:7,value:'Eight'},\n            {key:8,value:'Nine'},\n            {key:9,value:'Ten'}\n        ],\n        list2: [],\n        currentDrag: null,\n        currentDrop: null,\n        currentHolder: null,\n        currentPos: null,\n        currentInsertPoint: null\n    }},\n\n    oninit: function(){\n        this.on('SortableDragItem.dragStart',this.handleSortableDragStart);\n        this.on('SortableDragItem.dragEnd',this.handleSortableDragEnd);\n        this.on('SortableDragList.dragEnter',this.handleSortableDragEnter);\n        this.on('SortableDragList.dragOver',this.handleSortableDragOver);\n        this.on('SortableDragList.dragLeave',this.handleSortableDragLeave);\n        this.on('SortableDragList.dragDrop',this.handleSortableDragDrop);\n    },\n\n    handleSortableDragStart: function(ev) {\n        this.set('currentDrag',ev.component);\n    },\n\n    handleSortableDragEnd: function(ev) {\n        this.set('currentDrag',null);\n        this.set('currentHolder',null);\n        this.set('currentInsertPoint',null);\n    },\n\n    handleSortableDragEnter: function(ev) {\n        window.setTimeout((()=> {\n            this.set('currentDrop', ev.component);\n            if (!this.get('currentHolder'))\n                this.set('currentHolder', ev.component);\n        }).bind(this),1);\n    },\n\n    handleSortableDragOver: function(ev) {\n        let pos = {x:ev.original.pageX,y:ev.original.pageY};\n        this.set('currentPos',pos);\n\n        if (!this.get('currentDrop')) {\n            this.set('currentInsertionPoint',null);\n            return;\n        }\n        let destComp = this.getDropBeforeComp();\n        this.set('currentInsertPoint', destComp ? destComp.get('key') : this.get('currentDrop').get('key'));\n    },\n\n    handleSortableDragLeave: function(ev) {\n        this.set('currentDrop',null);\n    },\n\n    handleSortableDragDrop: function(ev) {\n        ev.original.stopPropagation();\n        this.set('currentDrop',ev.component);\n\n        let srcComp = this.get('currentDrag');\n        let destComp = this.getDropBeforeComp();\n\n        if (srcComp!=destComp) {\n            let srcKey = srcComp.get('key');\n            let srcData = this.get(this.get('currentHolder').get('key'));\n            let srcObj = srcData.filter(obj=>{return obj.key==srcKey})[0];\n            srcData.splice(srcData.indexOf(srcObj),1);\n            let destData = this.get(this.get('currentDrop').get('key'));\n            let destKey = destComp ? destComp.get('key') : null;\n            let dest = destData.filter(obj=>{return obj.key===destKey});\n            let destInd = dest.length ? destData.indexOf(dest[0]) : destData.length;\n            destData.splice(destInd,0,srcObj);\n        }\n        this.set('currentHolder',null);\n        this.set('currentInsertPoint',null);\n    },\n\n    getDropBeforeComp: function() {\n        let dropPos = this.get('currentPos');\n        if (!this.get('currentDrop'))\n            return null;\n\n        return this.get('currentDrop').findAllComponents('SortableDragItem').reduce((aggr,comp)=>{\n            let el = $(comp.find('*'));\n            return  !aggr && el.offset().top+(el.outerHeight()*0.75) > dropPos.y\n                ?comp\n                :aggr;\n        },null);\n    }\n});\n\nexport default Main;\n\n\n\n// WEBPACK FOOTER //\n// ./src/ractivePOC/components/main/main.js","import Ractive from 'ractive';\nimport css from './sortableDragItem.scss';\nimport template from './sortableDragItem.hbs';\n\nconst SortableDragItem = Ractive.extend({\n    template,\n    data: ()=>{return {\n        css,\n        isDragging: false\n    }},\n\n    oninit: function() {\n        this.on('dragStart',this.handleDragStart);\n        this.on('dragEnd',this.handleDragEnd);\n    },\n\n    handleDragStart: function(ev) {\n        this.set('isDragging', true);\n    },\n\n    handleDragEnd: function(ev) {\n        this.set('isDragging', false)\n    },\n\n    onDragOver: (inst,ev)=>{\n        ev.preventDefault();\n        ev.dataTransfer.dropEffect = 'move';\n    }\n});\n\nexport default SortableDragItem;\n\n\n\n// WEBPACK FOOTER //\n// ./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.js","import Ractive from 'ractive';\nimport css from './sortableDragList.scss';\nimport template from './sortableDragList.hbs';\n\nconst SortableDragList = Ractive.extend({\n    template,\n    data: ()=>{return {\n        css,\n        isDropping: false\n    }},\n\n    oninit: function() {\n        this.on('dragEnter',this.handleDragEnter);\n        this.on('dragOver',this.handleDragOver);\n        this.on('dragLeave',this.handleDragLeave);\n    },\n\n    handleDragEnter: function(ev) {\n        this.set('isDropping', true);\n    },\n\n    handleDragOver: function(ev) {\n        ev.original.preventDefault();\n        ev.original.dataTransfer.dropEffect = 'move';\n    },\n\n    handleDragLeave: function(ev) {\n        this.set('isDropping', false)\n    },\n});\n\nexport default SortableDragList;\n\n\n\n// WEBPACK FOOTER //\n// ./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.js","import Ractive from 'ractive';\n\nimport Main from './components/main/main.js';\n//import Store from './store/store.js';\n\nRactive.defaults.twoWay = false;\n\nif (['complete', 'loaded', 'interactive'].includes(document.readyState) && document.body)\n    run();\nelse\n    window.addEventListener('DOMContentLoaded', run, false);\n\nfunction run() {\n    let ractive = new Ractive({\n        twoWay: false,\n        el: '#main',\n        template: '<Main />',\n        components: {Main}\n    });\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/ractivePOC/entry.js","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".main--x41Ty{width:800px}.main--x41Ty ul{float:left;margin-right:20px}.insertAfter--2pLYf li:last-child{border-bottom:1px dotted #000!important}.insertBefore--3ajF-{border-top:1px dotted #000!important}\", \"\", {\"version\":3,\"sources\":[\"/./src/ractivePOC/components/main/main.scss\"],\"names\":[],\"mappings\":\"AAAA,aAAc,WAAW,CAAC,gBAAiB,WAAW,iBAAiB,CAAC,kCAAmC,uCAAwC,CAAC,qBAAsB,oCAAqC,CAAC\",\"file\":\"main.scss\",\"sourcesContent\":[\":local(.main){width:800px}:local(.main) ul{float:left;margin-right:20px}:local(.insertAfter) li:last-child{border-bottom:1px dotted #000 !important}:local(.insertBefore){border-top:1px dotted #000 !important}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\nexports.locals = {\n\t\"main\": \"main--x41Ty\",\n\t\"insertAfter\": \"insertAfter--2pLYf\",\n\t\"insertBefore\": \"insertBefore--3ajF-\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?sourceMap&localIdentName=[local]--[hash:base64:5]!./~/sass-loader!./src/ractivePOC/components/main/main.scss\n// module id = 9\n// module chunks = 0","exports = module.exports = require(\"./../../../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".sortableDragItem--YNU05{padding:4px 5px;display:block;border-top:1px solid transparent;border-bottom:1px solid transparent;background-color:transparent}.sortableDragItem--YNU05 a{background-color:#ddd;display:block;padding:5px 10px;cursor:pointer}.sortableDragItem--YNU05 a:hover{background-color:#afa}\", \"\", {\"version\":3,\"sources\":[\"/./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.scss\"],\"names\":[],\"mappings\":\"AAAA,yBAA0B,gBAAgB,cAAc,iCAAiC,oCAAoC,4BAA4B,CAAC,2BAA4B,sBAAsB,cAAc,iBAAiB,cAAc,CAAC,iCAAkC,qBAAqB,CAAC\",\"file\":\"sortableDragItem.scss\",\"sourcesContent\":[\":local(.sortableDragItem){padding:4px 5px;display:block;border-top:1px solid transparent;border-bottom:1px solid transparent;background-color:transparent}:local(.sortableDragItem) a{background-color:#ddd;display:block;padding:5px 10px;cursor:pointer}:local(.sortableDragItem) a:hover{background-color:#afa}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\nexports.locals = {\n\t\"sortableDragItem\": \"sortableDragItem--YNU05\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?sourceMap&localIdentName=[local]--[hash:base64:5]!./~/sass-loader!./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.scss\n// module id = 10\n// module chunks = 0","exports = module.exports = require(\"./../../../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".sortableDragList--3SFZ-{margin:20px;padding:5px;background-color:#eee;list-style:none;display:block;width:200px;min-height:400px}\", \"\", {\"version\":3,\"sources\":[\"/./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.scss\"],\"names\":[],\"mappings\":\"AAAA,yBAA0B,YAAY,YAAY,sBAAsB,gBAAgB,cAAc,YAAY,gBAAgB,CAAC\",\"file\":\"sortableDragList.scss\",\"sourcesContent\":[\":local(.sortableDragList){margin:20px;padding:5px;background-color:#eee;list-style:none;display:block;width:200px;min-height:400px}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\nexports.locals = {\n\t\"sortableDragList\": \"sortableDragList--3SFZ-\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?sourceMap&localIdentName=[local]--[hash:base64:5]!./~/sass-loader!./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.scss\n// module id = 11\n// module chunks = 0","/*!\n * jQuery JavaScript Library v3.1.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-09-22T22:30Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.1.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\tresolve.call( undefined, value );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.call( undefined, value );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\nfunction manipulationTarget( elem, content ) {\n\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE <=9 only\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === \"width\" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar val,\n\t\tvalueIsBorderBox = true,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Support: IE <=11 only\n\t// Running getBoundingClientRect on a disconnected node\n\t// in IE throws an error.\n\tif ( elem.getClientRects().length ) {\n\t\tval = elem.getBoundingClientRect()[ name ];\n\t}\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction raf() {\n\tif ( timerId ) {\n\t\twindow.requestAnimationFrame( raf );\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off or if document is hidden\n\tif ( jQuery.fx.off || document.hidden ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.requestAnimationFrame ?\n\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tif ( window.cancelAnimationFrame ) {\n\t\twindow.cancelAnimationFrame( timerId );\n\t} else {\n\t\twindow.clearInterval( timerId );\n\t}\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win, rect, doc,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\t// Make sure element is not hidden (display: none)\n\t\tif ( rect.width || rect.height ) {\n\t\t\tdoc = elem.ownerDocument;\n\t\t\twin = getWindow( doc );\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\treturn rect;\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\njQuery.parseJSON = JSON.parse;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\n\nreturn jQuery;\n} );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jquery/dist/jquery.js\n// module id = 12\n// module chunks = 0","module.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":[{\"t\":2,\"r\":\"css.main\"}],\"t\":13}],\"f\":[{\"t\":7,\"e\":\"SortableDragList\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"css.insertAfter\"],\"s\":\"_0==\\\"list1\\\"?_1:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":\"list1\",\"t\":13}],\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"SortableDragItem\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"key\",\"css.insertBefore\"],\"s\":\"_0==_1?_2:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":[{\"t\":2,\"r\":\"key\"}],\"t\":13}],\"f\":[{\"t\":2,\"r\":\"value\"}]}],\"r\":\"list1\"}]},\" \",{\"t\":7,\"e\":\"SortableDragList\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"css.insertAfter\"],\"s\":\"_0==\\\"list2\\\"?_1:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":\"list2\",\"t\":13}],\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"SortableDragItem\",\"m\":[{\"n\":\"className\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"currentInsertPoint\",\"key\",\"css.insertBefore\"],\"s\":\"_0==_1?_2:\\\"\\\"\"}}],\"t\":13},{\"n\":\"key\",\"f\":[{\"t\":2,\"r\":\"key\"}],\"t\":13}],\"f\":[{\"t\":2,\"r\":\"value\"}]}],\"r\":\"list2\"}]}]}],\"e\":{}};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ractivePOC/components/main/main.hbs\n// module id = 13\n// module chunks = 0","module.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"li\",\"m\":[{\"n\":\"dragstart\",\"f\":\"dragStart\",\"t\":70},{\"n\":\"dragend\",\"f\":\"dragEnd\",\"t\":70},{\"n\":\"draggable\",\"f\":\"true\",\"t\":13},{\"n\":\"class\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"css.sortableDragItem\",\"isDragging\",\"css.isDragging\",\"className\"],\"s\":\"_0+\\\" \\\"+(_1?_2:\\\"\\\")+\\\" \\\"+_3\"}}],\"t\":13},{\"n\":\"rel\",\"f\":[{\"t\":2,\"r\":\"key\"}],\"t\":13}],\"f\":[{\"t\":7,\"e\":\"a\",\"f\":[{\"t\":16}]}]}],\"e\":{}};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.hbs\n// module id = 14\n// module chunks = 0","module.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"ul\",\"m\":[{\"n\":\"dragenter\",\"f\":\"dragEnter\",\"t\":70},{\"n\":\"dragover\",\"f\":\"dragOver\",\"t\":70},{\"n\":\"dragleave\",\"f\":\"dragLeave\",\"t\":70},{\"n\":\"drop\",\"f\":\"dragDrop\",\"t\":70},{\"n\":\"class\",\"f\":[{\"t\":2,\"x\":{\"r\":[\"css.sortableDragList\",\"isDropping\",\"css.isDropping\",\"className\"],\"s\":\"_0+\\\" \\\"+(_1?_2:\\\"\\\")+\\\" \\\"+_3\"}}],\"t\":13}],\"f\":[{\"t\":16}]}],\"e\":{}};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.hbs\n// module id = 15\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragItem.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragItem.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragItem.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ractivePOC/components/shared/sortable/sortableDragItem/sortableDragItem.scss\n// module id = 16\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragList.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragList.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../../../node_modules/css-loader/index.js?sourceMap&localIdentName=[local]--[hash:base64:5]!./../../../../../../node_modules/sass-loader/index.js!./sortableDragList.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ractivePOC/components/shared/sortable/sortableDragList/sortableDragList.scss\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}